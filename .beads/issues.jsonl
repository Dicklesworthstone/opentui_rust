{"id":"bd-10de","title":"demo_showcase tests: compile coverage for --bin demo_showcase","description":"# demo_showcase Tests — Compile Coverage for `--bin demo_showcase`\n\n## Purpose\n\nThe demo is a flagship deliverable. It must not silently stop compiling.\n\nThis bead adds automated compile coverage so CI will fail if the binary breaks.\n\n## Implementation\n\nPrefer modifying existing test infrastructure instead of adding new test files:\n\n- Update `tests/examples_compile.rs` to also run:\n  - `cargo build --all-features --bin demo_showcase`\n\nOptionally also validate that it links under `--release` in a separate (slower) job, but the core requirement is debug build coverage.\n\n## Acceptance Notes\n\n- `cargo test` runs the compile coverage test.\n- Breaking the demo binary fails CI quickly with useful stderr.","acceptance_criteria":"Checklist:\n- A test builds the binary with `cargo build --all-features --bin demo_showcase`.\n- On failure, the test prints the cargo stderr so CI logs are actionable.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:29:06.059756038Z","created_by":"ubuntu","updated_at":"2026-01-27T22:44:47.322873942Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","testing"],"dependencies":[{"issue_id":"bd-10de","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-01-27T22:29:06.104418076Z","created_by":"ubuntu"},{"issue_id":"bd-10de","depends_on_id":"bd-z1b","type":"blocks","created_at":"2026-01-27T22:32:32.910610712Z","created_by":"ubuntu"}]}
{"id":"bd-12l","title":"Improve render_to vs render_to_with_pool documentation","description":"The render_to() method in TextBufferView creates placeholder GraphemeIds for multi-codepoint graphemes when no pool is provided. This is intentional but could be better documented. Tasks: 1) Add doc comment warning to render_to() about placeholder behavior, 2) Add doc comment to render_to_with_pool() explaining when to use it, 3) Consider adding example in module docs","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T17:40:09.094777229Z","created_by":"ubuntu","updated_at":"2026-01-27T17:42:05.554193601Z","closed_at":"2026-01-27T17:42:05.554130183Z","close_reason":"Documentation improved in eaf58ab","compaction_level":0,"original_size":0}
{"id":"bd-132","title":"Extend E2E Test Harness for Input/Output","description":"## Overview\nExtend the existing test harness to support input injection and output verification for end-to-end testing.\n\n## Already Implemented\nIn `tests/common/harness.rs`:\n- `ArtifactConfig` for controlling test artifacts ✓\n- `ArtifactLogger` for logging test cases to files ✓\n- `CaseResult` and `Summary` structures ✓\n- `case_timer()` and `case_result()` helpers ✓\n- Artifact directory management ✓\n\nIn `tests/conformance.rs`:\n- Conformance testing framework ✓\n\n## Scope (Extensions to Add)\nExtend the harness to support full input/output testing:\n\n```rust\n// tests/common/harness.rs (additions)\n\n/// Full E2E test harness with input injection and output capture.\npub struct E2EHarness {\n    artifact_logger: ArtifactLogger,\n    input_buffer: Vec<u8>,\n    output_buffer: OptimizedBuffer,\n    parser: InputParser,\n    events: Vec<(Duration, Event)>,\n    start_time: Instant,\n}\n\nimpl E2EHarness {\n    /// Create a new E2E harness for a test.\n    pub fn new(suite: &str, test: &str, width: u32, height: u32) -> Self {\n        Self {\n            artifact_logger: ArtifactLogger::new(suite, test),\n            input_buffer: Vec::new(),\n            output_buffer: OptimizedBuffer::new(width, height),\n            parser: InputParser::new(),\n            events: Vec::new(),\n            start_time: Instant::now(),\n        }\n    }\n\n    /// Inject input bytes and parse events.\n    pub fn inject_input(&mut self, bytes: &[u8]) -> Vec<Event> {\n        eprintln!(\"[HARNESS] Injecting {} bytes: {:02x?}\", bytes.len(), bytes);\n        self.input_buffer.extend_from_slice(bytes);\n        \n        let mut events = Vec::new();\n        loop {\n            match self.parser.parse(&self.input_buffer) {\n                Ok((event, consumed)) => {\n                    let elapsed = self.start_time.elapsed();\n                    eprintln!(\"[HARNESS] {:?} Parsed event: {:?}\", elapsed, event);\n                    self.events.push((elapsed, event.clone()));\n                    events.push(event);\n                    self.input_buffer.drain(..consumed);\n                }\n                Err(_) => break,\n            }\n        }\n        events\n    }\n\n    /// Get the output buffer for rendering.\n    pub fn buffer_mut(&mut self) -> &mut OptimizedBuffer {\n        &mut self.output_buffer\n    }\n\n    /// Dump buffer contents to artifact file.\n    pub fn dump_buffer(&self, name: &str) {\n        let mut output = String::new();\n        for y in 0..self.output_buffer.height() {\n            for x in 0..self.output_buffer.width() {\n                if let Some(cell) = self.output_buffer.get(x, y) {\n                    if let Some(g) = &cell.content.grapheme {\n                        output.push_str(g);\n                    } else {\n                        output.push(' ');\n                    }\n                }\n            }\n            output.push('\\n');\n        }\n        \n        eprintln!(\"[HARNESS] Buffer dump '{}':\\n{}\", name, output);\n        \n        // Also write to artifact file\n        self.artifact_logger.log_text(name, &output, &output);\n    }\n\n    /// Assert cell at position has expected content.\n    pub fn assert_cell(&self, x: u32, y: u32, expected_char: char, msg: &str) {\n        let cell = self.output_buffer.get(x, y).expect(\"Cell should exist\");\n        let actual = cell.content.grapheme.as_deref().unwrap_or(\" \");\n        let expected = expected_char.to_string();\n        \n        eprintln!(\"[HARNESS] assert_cell({},{}) expected='{}' actual='{}'\", x, y, expected, actual);\n        \n        assert_eq!(actual, expected, \"{} at ({},{})\", msg, x, y);\n    }\n\n    /// Assert cell style matches predicate.\n    pub fn assert_style<F>(&self, x: u32, y: u32, predicate: F, msg: &str)\n    where\n        F: Fn(&Style) -> bool,\n    {\n        let cell = self.output_buffer.get(x, y).expect(\"Cell should exist\");\n        eprintln!(\"[HARNESS] assert_style({},{}) style={:?}\", x, y, cell.style);\n        \n        assert!(predicate(&cell.style), \"{} at ({},{})\", msg, x, y);\n    }\n\n    /// Get all parsed events.\n    pub fn events(&self) -> &[(Duration, Event)] {\n        &self.events\n    }\n\n    /// Write test summary.\n    pub fn finish(&self, passed: bool) {\n        let cases: Vec<CaseResult> = self.events\n            .iter()\n            .enumerate()\n            .map(|(i, (dur, event))| CaseResult {\n                name: format!(\"event_{}\", i),\n                result: format!(\"{:?}\", event),\n                duration_ms: dur.as_millis(),\n            })\n            .collect();\n        \n        self.artifact_logger.write_summary(passed, &cases);\n    }\n}\n```\n\n## Files to Modify\n- tests/common/harness.rs - Add E2EHarness struct\n\n## Testing Requirements\n\n### E2E Test Examples\n```rust\n// tests/e2e/input_output.rs\n\n#[test]\nfn test_e2e_key_input_and_render() {\n    let mut harness = E2EHarness::new(\"input_output\", \"key_input\", 80, 24);\n    \n    // Create an editor\n    let mut buffer = EditBuffer::with_text(\"Hello\");\n    let mut view = EditorView::new(buffer);\n    \n    // Inject arrow key input\n    let events = harness.inject_input(b\"\\x1b[C\");  // Right arrow\n    \n    eprintln!(\"[TEST] Parsed events: {:?}\", events);\n    assert_eq!(events.len(), 1);\n    \n    if let Event::Key(key) = &events[0] {\n        assert_eq!(key.code, KeyCode::Right);\n        view.edit_buffer_mut().move_right();\n    }\n    \n    // Render\n    view.render_to(harness.buffer_mut(), 0, 0, 80, 24);\n    \n    // Verify\n    harness.assert_cell(0, 0, 'H', \"First char should be H\");\n    harness.dump_buffer(\"after_right_arrow\");\n    \n    harness.finish(true);\n    eprintln!(\"[TEST] PASS: E2E key input and render works\");\n}\n\n#[test]\nfn test_e2e_mouse_click_and_selection() {\n    let mut harness = E2EHarness::new(\"input_output\", \"mouse_selection\", 80, 24);\n    \n    // Create editor with text\n    let buffer = EditBuffer::with_text(\"Click here to select\");\n    let mut view = EditorView::new(buffer);\n    \n    // Inject mouse click\n    let events = harness.inject_input(b\"\\x1b[<0;6;1M\");  // Click at (5, 0)\n    \n    eprintln!(\"[TEST] Mouse events: {:?}\", events);\n    \n    if let Some(Event::Mouse(mouse)) = events.first() {\n        eprintln!(\"[TEST] Mouse click at ({}, {})\", mouse.x, mouse.y);\n        // Handle click...\n    }\n    \n    harness.finish(true);\n    eprintln!(\"[TEST] PASS: E2E mouse click works\");\n}\n\n#[test]\nfn test_e2e_bracketed_paste() {\n    let mut harness = E2EHarness::new(\"input_output\", \"bracketed_paste\", 80, 24);\n    \n    let buffer = EditBuffer::new();\n    let mut view = EditorView::new(buffer);\n    \n    // Inject paste sequence\n    let paste_input = b\"\\x1b[200~Pasted text\\x1b[201~\";\n    let events = harness.inject_input(paste_input);\n    \n    eprintln!(\"[TEST] Paste events: {:?}\", events);\n    \n    if let Some(Event::Paste(paste)) = events.first() {\n        eprintln!(\"[TEST] Paste content: {:?}\", paste.content());\n        assert_eq!(paste.content(), \"Pasted text\");\n        \n        // Insert pasted text\n        view.edit_buffer_mut().insert(paste.content());\n    }\n    \n    view.render_to(harness.buffer_mut(), 0, 0, 80, 24);\n    harness.dump_buffer(\"after_paste\");\n    \n    harness.finish(true);\n    eprintln!(\"[TEST] PASS: E2E bracketed paste works\");\n}\n```\n\n## Acceptance Criteria\n- [ ] E2EHarness can inject input bytes\n- [ ] E2EHarness parses events from input\n- [ ] E2EHarness provides output buffer for rendering\n- [ ] Buffer dumping works for debugging\n- [ ] Cell and style assertions work with logging\n- [ ] Test summary written to artifacts\n- [ ] All 3 E2E example tests pass\n- [ ] Existing harness tests still pass (no regression)\n\nDependencies:\n  -> bd-219 (blocks) - Fix Bracketed Paste Mode Bug\n  -> bd-vde (blocks) - Add Comprehensive Mouse Input Tests","acceptance_criteria":"- [ ] Harness can inject arbitrary input\n- [ ] Harness captures all output\n- [ ] Logging is comprehensive\n- [ ] Tests run in CI (no real terminal)\n- [ ] All E2E tests pass\n- [ ] Logs provide clear debugging info\n\n---","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:43:43.219129558Z","closed_at":"2026-01-19T22:43:43.219063132Z","close_reason":"Implemented E2EHarness with input injection and output verification. Created 3 E2E tests: key input, mouse click, and bracketed paste. All tests pass.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-132","depends_on_id":"bd-219","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-132","depends_on_id":"bd-vde","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"}]}
{"id":"bd-19n","title":"Fix OSC 8 hyperlink URL injection vulnerability","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-27T16:54:09.712815124Z","created_by":"ubuntu","updated_at":"2026-01-27T16:57:41.923274898Z","closed_at":"2026-01-27T16:57:41.923215146Z","close_reason":"done","compaction_level":0,"original_size":0}
{"id":"bd-19qi","title":"demo_showcase features: pixel rendering showpiece (PixelBuffer + Grayscale + supersampling)","description":"# demo_showcase Features — Pixel Rendering Showpiece (PixelBuffer + Grayscale + Supersampling)\n\n## Purpose\n\nPixel-level rendering is a unique capability for a terminal UI engine. This bead ensures the demo has an unmistakable “graphics” moment using:\n\n- `PixelBuffer` (RGBA pixels)\n- `GrayscaleBuffer` (intensity buffers)\n- `OptimizedBuffer::draw_supersample_buffer` (2x2 quadrants)\n- `draw_grayscale_buffer_unicode` for sparklines / heatmaps\n\n## Requirements\n\n- The preview panel must render:\n  - an animated effect (gradient waves, plasma, noise, or oscilloscope)\n  - a small chart (sparkline) driven by deterministic metrics\n\n- The render should be clipped to the panel via scissor.\n- Add a semi-transparent UI overlay (labels + toggles) on top of the pixels to demonstrate blending.\n\n## Acceptance Notes\n\n- The preview looks visually impressive (not just static blocks).\n- The effect is smooth under the frame pacing system.\n- Works in reduced-color terminals with a graceful palette fallback.","acceptance_criteria":"Done when:\n- The preview panel renders a clearly animated pixel effect using `PixelBuffer` + supersampling (not just static blocks).\n- The panel also renders at least one grayscale-driven visualization (sparkline/heatmap) using `GrayscaleBuffer` helpers.\n- Pixel drawing is clipped to the panel’s inner rect via scissor (no bleed).\n- A translucent UI overlay (labels/toggles) is drawn over the pixels to visibly prove alpha blending.\n- With reduced-color constraints (e.g., `--cap-preset no_truecolor` in headless), the preview still looks good via a graceful palette fallback.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:28:17.567728370Z","created_by":"ubuntu","updated_at":"2026-01-27T23:16:29.381344329Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","features"],"dependencies":[{"issue_id":"bd-19qi","depends_on_id":"bd-2t3","type":"blocks","created_at":"2026-01-27T22:32:24.480066053Z","created_by":"ubuntu"},{"issue_id":"bd-19qi","depends_on_id":"bd-37p","type":"parent-child","created_at":"2026-01-27T22:28:17.582950207Z","created_by":"ubuntu"},{"issue_id":"bd-19qi","depends_on_id":"bd-qn5","type":"blocks","created_at":"2026-01-27T22:32:23.922800553Z","created_by":"ubuntu"}]}
{"id":"bd-1al","title":"demo_showcase UI: overlay system (modals + glass + focus capture)","description":"# demo_showcase UI — Overlay System (Modals + Glass + Focus Capture)\n\n## Purpose\n\nThe demo app needs multiple overlays that all share the same core behavior:\n\n- semi-transparent “glass” panels layered over the main UI\n- dimmed / tinted backdrop\n- animated enter/exit (subtle fade / slide)\n- input capture (overlay takes focus; underlying UI stops receiving events)\n- hit testing for clickable controls inside overlays\n\nThis bead builds a reusable overlay foundation so **Help**, **Command Palette**, and **Tour** don’t each reinvent modal behavior.\n\n## Core Requirements\n\n### Rendering\n\n- Overlays render in the final render pass (highest z-order).\n- Backdrop uses `push_opacity()` + translucent `fill_rect()` so alpha blending is obvious.\n- Overlay body uses:\n  - rounded/double border styles\n  - soft gradients / subtle noise patterns (procedural) to look “premium”\n  - clipped internal scrolling content (scissor stack)\n\n### Input / Focus\n\n- Overlay manager owns:\n  - `active: Option<Overlay>` (or a small stack if needed)\n  - `focus: OverlayFocus` (which control is focused)\n- When an overlay is active:\n  - keyboard shortcuts are handled by overlay first\n  - mouse hit testing only targets overlay regions\n  - optional “click outside to dismiss” behavior\n\n### HitGrid integration\n\n- Overlay rendering must also register hit areas (`Renderer::register_hit_area`).\n- Use `Renderer::push_hit_scissor` around overlay internals so hit areas respect clipping.\n\n## Suggested Structure (demo-only)\n\nInside `src/bin/demo_showcase.rs`:\n\n- `enum Overlay { Help(HelpState), Palette(PaletteState), Tour(TourState) }`\n- `struct OverlayManager { active: Option<Overlay>, anim: OverlayAnim, ... }`\n- `fn render_overlays(&mut self, ctx: &mut RenderCtx, ...)` called from the render pass bead.\n\n## Acceptance Notes\n\nWe consider this “done” when:\n\n- The overlay visuals clearly demonstrate alpha blending + opacity stack (no “flat” look).\n- Focus is trapped inside overlays and underlying UI does not react.\n- Overlay hit targets work and do not leak outside clipped regions.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:23:19.127313380Z","created_by":"ubuntu","updated_at":"2026-01-27T22:31:59.560697225Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","ui"],"dependencies":[{"issue_id":"bd-1al","depends_on_id":"bd-1pd","type":"blocks","created_at":"2026-01-27T22:31:58.427687351Z","created_by":"ubuntu"},{"issue_id":"bd-1al","depends_on_id":"bd-35g","type":"blocks","created_at":"2026-01-27T22:31:59.010613409Z","created_by":"ubuntu"},{"issue_id":"bd-1al","depends_on_id":"bd-3l0","type":"blocks","created_at":"2026-01-27T22:31:59.560668591Z","created_by":"ubuntu"},{"issue_id":"bd-1al","depends_on_id":"bd-c75","type":"parent-child","created_at":"2026-01-27T22:23:19.140058070Z","created_by":"ubuntu"},{"issue_id":"bd-1al","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:31:57.881744685Z","created_by":"ubuntu"}]}
{"id":"bd-1by","title":"demo_showcase runtime: robust cleanup + panic hook (restore terminal on crash)","description":"# demo_showcase Runtime — Robust Cleanup + Panic Hook\n\n## Purpose\n\nEven though `Renderer` and `Terminal` try to restore state on Drop, a panic can still leave the user’s terminal in a bad state (especially if aborting).\n\nThis bead adds belt-and-suspenders cleanup so the demo is “safe to run”.\n\n## Approach\n\n- Install a panic hook that:\n  - attempts best-effort cleanup\n  - prints a helpful message (`reset` / `stty sane`)\n\nImportant:\n\n- Keep it minimal and avoid introducing dependencies.\n- Do not swallow panic info; chain to the original hook.\n\n## Scope\n\nThis is demo-only code in `src/bin/demo_showcase.rs`.","acceptance_criteria":"Checklist:\n- [ ] Panic hook attempts terminal cleanup\n- [ ] Original panic hook is preserved\n- [ ] Crash instructions are printed clearly","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-27T22:11:17.714696250Z","created_by":"ubuntu","updated_at":"2026-01-27T22:12:31.148161976Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","resilience","runtime"],"dependencies":[{"issue_id":"bd-1by","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:11:17.733296335Z","created_by":"ubuntu"},{"issue_id":"bd-1by","depends_on_id":"bd-z1b","type":"blocks","created_at":"2026-01-27T22:12:31.148134484Z","created_by":"ubuntu"}]}
{"id":"bd-1c6","title":"[EPIC] Expanded Examples Suite","description":"# Epic: Expanded Examples Suite\n\n## Background & Motivation\n\nOpenTUI currently has only two examples:\n1. `hello.rs` - Basic buffer creation and text drawing (doesn't even render to terminal)\n2. `editor.rs` - Full interactive editor demo\n\nThere's a significant gap between these. Users need:\n- Simple, focused examples showing one feature at a time\n- Progressive complexity to learn the library\n- Real-world patterns they can copy into their projects\n- Examples demonstrating all major features\n\n## Goals\n\n1. Provide examples covering all major OpenTUI features\n2. Order examples by complexity (beginner → advanced)\n3. Each example should be self-contained and focused on one concept\n4. Include inline comments explaining key patterns\n5. Examples should be runnable and visually interesting\n\n## Proposed Example Structure\n\n```\nexamples/\n├── 01_hello_terminal.rs     # Basic terminal setup + text output\n├── 02_colors.rs             # RGBA colors, hex, HSV, blending\n├── 03_styles.rs             # Bold, italic, underline, inverse\n├── 04_drawing.rs            # Boxes, lines, fill_rect\n├── 05_scissoring.rs         # Scissor clipping demonstration\n├── 06_opacity.rs            # Opacity stacks and transparency\n├── 07_input.rs              # Keyboard and mouse input handling\n├── 08_animation.rs          # Simple animation loop\n├── 09_text_buffer.rs        # TextBuffer and styled segments\n├── 10_edit_buffer.rs        # Editable text with cursor\n├── 11_highlighting.rs       # Syntax highlighting (after highlight impl)\n├── 12_panels.rs             # Multiple panels/windows pattern\n├── 13_menu.rs               # Dropdown/popup menu pattern\n├── 14_progress.rs           # Progress bars and spinners\n├── 15_dashboard.rs          # Complex multi-widget dashboard\n└── editor.rs                # (Existing) Full editor demo\n```\n\n## Design Principles\n\n- **Progressive disclosure** - Start simple, build complexity\n- **One concept per example** - Don't overwhelm with features\n- **Copy-paste friendly** - Code should work with minimal modification\n- **Visual appeal** - Make examples look good so users are inspired\n- **Commented thoroughly** - Explain the \"why\" not just the \"what\"\n\n## Non-Goals\n\n- Complete application examples (that's what the editor demo is for)\n- Platform-specific examples\n- Integration with external crates (keep dependencies minimal)\n\n## Success Criteria\n\n- [ ] At least 10 new example files\n- [ ] Examples build and run without errors\n- [ ] README or doc comments explain what each example demonstrates\n- [ ] New user can understand OpenTUI by reading examples in order\n- [ ] Examples showcase features not obvious from API docs\n\n## Dependencies\n\nMost examples can be created immediately. The highlighting example (11) depends on the syntax highlighting epic completion.\n\n## Estimated Scope\n\n~1500-2000 LOC across all examples.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:09:23.805421096Z","created_by":"ubuntu","updated_at":"2026-01-25T17:55:13.555654383Z","closed_at":"2026-01-25T17:55:13.555508939Z","close_reason":"done","compaction_level":0,"original_size":0,"labels":["epic","examples"]}
{"id":"bd-1c6.1","title":"Example: Basic terminal setup and rendering","description":"# Example: Basic Terminal Setup and Rendering\n\n## Purpose\n\nThis is the true \"hello world\" - demonstrating the minimum code to:\n1. Create a Renderer\n2. Draw something to the buffer\n3. Present it to the terminal\n4. Handle cleanup\n\nThe existing `hello.rs` doesn't actually render to terminal - it just creates a buffer and prints dimensions. This example fills that gap.\n\n## Code Structure\n\n```rust\n//! Example 01: Basic Terminal Rendering\n//! \n//! This example demonstrates the fundamental OpenTUI rendering loop:\n//! 1. Create a Renderer (enters alternate screen, hides cursor)\n//! 2. Get the back buffer and draw to it\n//! 3. Present the frame (writes to terminal)\n//! 4. Wait for user input to exit\n//! 5. Renderer drops and restores terminal automatically\n\nuse opentui::{Renderer, Rgba, Style};\nuse std::io::{self, Read};\n\nfn main() -> io::Result<()> {\n    // Create renderer with terminal dimensions\n    // This automatically:\n    // - Enters alternate screen (saves current terminal content)\n    // - Hides the cursor\n    // - Enables raw mode (direct key input)\n    let mut renderer = Renderer::new(80, 24)?;\n    \n    // Clear the buffer with a dark background\n    let buffer = renderer.buffer();\n    buffer.clear(Rgba::from_hex(\"#1a1a2e\").unwrap());\n    \n    // Draw centered text\n    let title = \"Welcome to OpenTUI!\";\n    let x = (80 - title.len() as u32) / 2;\n    buffer.draw_text(x, 10, title, Style::fg(Rgba::from_hex(\"#00ff88\").unwrap()).with_bold());\n    \n    let subtitle = \"Press any key to exit...\";\n    let x = (80 - subtitle.len() as u32) / 2;\n    buffer.draw_text(x, 12, subtitle, Style::fg(Rgba::from_hex(\"#888888\").unwrap()));\n    \n    // Present the frame (diff-based, efficient)\n    renderer.present()?;\n    \n    // Wait for any key\n    let _ = io::stdin().read(&mut [0u8]);\n    \n    // Renderer::drop() automatically:\n    // - Exits alternate screen (restores previous content)\n    // - Shows the cursor\n    // - Disables raw mode\n    \n    Ok(())\n}\n```\n\n## Key Concepts Demonstrated\n\n1. **Renderer lifecycle** - Create → draw → present → drop\n2. **Alternate screen** - Terminal content preserved\n3. **Automatic cleanup** - RAII pattern with Drop trait\n4. **Basic drawing** - `clear()` and `draw_text()`\n5. **Color creation** - `Rgba::from_hex()`\n6. **Style application** - `Style::fg()` and `.with_bold()`\n\n## Testing\n\n- Run example: `cargo run --example 01_hello_terminal`\n- Verify text appears centered on dark background\n- Verify pressing a key exits cleanly\n- Verify terminal is restored after exit\n\n## File to Create\n\n- `examples/01_hello_terminal.rs`\n\n## Acceptance Criteria\n\n- [ ] Example compiles and runs\n- [ ] Output is visually appealing\n- [ ] Terminal restores properly on exit\n- [ ] Code has thorough comments\n- [ ] Demonstrates minimum viable OpenTUI usage","notes":"## Testing Requirements\n\nPer bd-1c6.11 (Examples Validation Test Suite):\n- Example MUST compile with `cargo build --example 01_hello_terminal`\n- Run with: `cargo run --example 01_hello_terminal`\n- Verify terminal restores correctly on exit (no corruption)\n- Test on both light and dark terminal backgrounds\n\n## User Experience\n\nThis is the FIRST example users will see. It must:\n- Work flawlessly on first try\n- Have clear, educational comments\n- Demonstrate OpenTUI's \"just works\" philosophy\n- Leave the terminal in pristine condition on exit","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:09:42.262261577Z","created_by":"ubuntu","updated_at":"2026-01-25T12:41:42.829409444Z","closed_at":"2026-01-25T12:41:42.829391049Z","close_reason":"Added 01_hello_terminal example with renderer flow and README entry","compaction_level":0,"original_size":0,"labels":["beginner","examples"],"dependencies":[{"issue_id":"bd-1c6.1","depends_on_id":"bd-1c6","type":"parent-child","created_at":"2026-01-27T06:52:23Z","created_by":"import"}]}
{"id":"bd-1c6.10","title":"Example: Multi-panel dashboard layout","description":"# Example: Multi-Panel Dashboard Layout\n\n## Purpose\n\nDemonstrate how to build a complex multi-panel UI:\n- Split-pane layouts (horizontal and vertical)\n- Multiple independent panels\n- Focused panel indicator\n- Panel resizing concepts\n- Real-world dashboard pattern\n\n## Key Concepts\n\n1. **Layout Calculation**\n   ```rust\n   struct Panel {\n       x: u32, y: u32,\n       width: u32, height: u32,\n       title: String,\n   }\n   \n   fn calculate_layout(width: u32, height: u32) -> Vec<Panel> {\n       // Split horizontally: sidebar (20%) + main (80%)\n       // Split main vertically: content (70%) + logs (30%)\n   }\n   ```\n\n2. **Panel Rendering**\n   ```rust\n   fn render_panel(buffer: &mut OptimizedBuffer, panel: &Panel, focused: bool) {\n       let border_style = if focused {\n           Style::fg(Rgba::CYAN)\n       } else {\n           Style::fg(Rgba::from_hex(\"#555555\").unwrap())\n       };\n       \n       buffer.push_scissor(ClipRect::new(panel.x, panel.y, panel.width, panel.height));\n       buffer.draw_box(panel.x, panel.y, panel.width, panel.height, BoxStyle::single());\n       // ... draw panel content ...\n       buffer.pop_scissor();\n   }\n   ```\n\n3. **Focus Management**\n   - Tab/Shift+Tab to cycle focus\n   - Visual indicator on focused panel\n   - Key handling scoped to focused panel\n\n## Visual Layout\n\n```\n╔════════════════════════════════════════════════════════════════════╗\n║  Dashboard Demo                                         [Tab] Focus║\n╠════════════════════════════════════════════════════════════════════╣\n║  ┌─ Sidebar ─┬─────────────────── Main Panel ───────────────────┐ ║\n║  │           │                                                    │ ║\n║  │ ► System  │  CPU Usage                                        │ ║\n║  │   Network │  ████████████████████░░░░░░░░░░░░ 68%            │ ║\n║  │   Storage │                                                    │ ║\n║  │   Logs    │  Memory Usage                                     │ ║\n║  │           │  ██████████░░░░░░░░░░░░░░░░░░░░░░ 31%            │ ║\n║  │           │                                                    │ ║\n║  │           │  Disk I/O                                          │ ║\n║  │           │  Read:  125 MB/s  Write: 42 MB/s                  │ ║\n║  │           ├────────────────────────────────────────────────────┤ ║\n║  │           │  Recent Events                                     │ ║\n║  │           │  12:34:56 [INFO] Service started                  │ ║\n║  │           │  12:34:57 [WARN] High memory usage                │ ║\n║  │           │  12:34:58 [INFO] Cache cleared                    │ ║\n║  └───────────┴────────────────────────────────────────────────────┘ ║\n╚════════════════════════════════════════════════════════════════════╝\n```\n\n## Implementation Structure\n\n```rust\nstruct Dashboard {\n    panels: Vec<Panel>,\n    focused: usize,\n    \n    // Panel-specific state\n    sidebar_selection: usize,\n    event_log: Vec<LogEntry>,\n}\n\nimpl Dashboard {\n    fn handle_input(&mut self, event: &Event) {\n        match event {\n            Event::Key(key) if key.code == KeyCode::Tab => {\n                self.focused = (self.focused + 1) % self.panels.len();\n            }\n            _ => {\n                // Delegate to focused panel\n                self.panels[self.focused].handle_input(event);\n            }\n        }\n    }\n    \n    fn render(&self, buffer: &mut OptimizedBuffer) {\n        for (i, panel) in self.panels.iter().enumerate() {\n            panel.render(buffer, i == self.focused);\n        }\n    }\n}\n```\n\n## File to Create\n\n- `examples/15_dashboard.rs`\n\n## Acceptance Criteria\n\n- [ ] Multiple panels with different content\n- [ ] Focus indicator (border color change)\n- [ ] Tab to switch focus\n- [ ] Scissor clipping per panel\n- [ ] Simulated data updates\n- [ ] Responsive to terminal resize\n- [ ] Clean visual design","notes":"Run with: cargo run --example 15_dashboard. Advanced example demonstrating multi-panel layouts with scissoring and focus management. Requires terminal resize handling. Test coverage via bd-1c6.11.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T01:12:48.163599100Z","created_by":"ubuntu","updated_at":"2026-01-25T15:54:27.844085033Z","closed_at":"2026-01-25T15:54:27.843931464Z","close_reason":"Implemented dashboard example and README entry","compaction_level":0,"original_size":0,"labels":["advanced","examples"],"dependencies":[{"issue_id":"bd-1c6.10","depends_on_id":"bd-1c6","type":"parent-child","created_at":"2026-01-27T06:52:23Z","created_by":"import"}]}
{"id":"bd-1c6.11","title":"Examples Validation Test Suite","description":"# Examples Validation Test Suite\n\n## Purpose\n\nAutomated test suite that validates all examples compile, run correctly, and produce expected output. This ensures examples remain working as the library evolves.\n\n## Test Architecture\n\n### 1. Compile-time Validation\n\nCreate `tests/examples_compile.rs`:\n\n```rust\n//\\! Validates all examples compile successfully\n//\\! Run with: cargo test --test examples_compile\n\nuse std::process::Command;\nuse tracing::{info, error, warn};\n\nfn init_logging() {\n    let _ = tracing_subscriber::fmt()\n        .with_max_level(tracing::Level::INFO)\n        .try_init();\n}\n\n#[test]\nfn all_examples_compile() {\n    init_logging();\n    \n    let examples = [\n        \"01_hello_terminal\",\n        \"02_colors\", \n        \"03_styles\",\n        \"04_drawing\",\n        \"05_scissoring\",\n        \"06_opacity\",\n        \"07_input\",\n        \"08_animation\",\n        \"09_text_buffer\",\n        \"10_dashboard\",\n        \"editor\",\n    ];\n    \n    let mut failures = Vec::new();\n    \n    for example in examples {\n        info\\!(example, \"Checking compilation\");\n        \n        let output = Command::new(\"cargo\")\n            .args([\"build\", \"--example\", example])\n            .output()\n            .expect(\"Failed to execute cargo\");\n        \n        if \\!output.status.success() {\n            error\\!(\n                example,\n                stderr = String::from_utf8_lossy(&output.stderr).as_ref(),\n                \"Compilation FAILED\"\n            );\n            failures.push(example);\n        } else {\n            info\\!(example, \"Compilation OK\");\n        }\n    }\n    \n    if \\!failures.is_empty() {\n        panic\\!(\"Examples failed to compile: {:?}\", failures);\n    }\n}\n```\n\n### 2. Runtime Smoke Tests\n\nFor examples that dont require interactive input, verify they run without crashing:\n\n```rust\n#[test]\nfn example_hello_runs() {\n    init_logging();\n    info\\!(\"Running hello terminal example\");\n    \n    // Run with timeout (example should exit on any input)\n    let output = Command::new(\"cargo\")\n        .args([\"run\", \"--example\", \"hello\", \"--\"])\n        .timeout(std::time::Duration::from_secs(2))\n        .output();\n    \n    // Timeout is expected (waiting for input), but shouldnt crash\n    match output {\n        Ok(out) => {\n            info\\!(\n                status = ?out.status,\n                \"Example completed\"\n            );\n        }\n        Err(e) if e.kind() == std::io::ErrorKind::TimedOut => {\n            info\\!(\"Example timed out (expected)\");\n        }\n        Err(e) => {\n            panic\\!(\"Example failed unexpectedly: {e}\");\n        }\n    }\n}\n```\n\n### 3. Output Verification\n\nFor non-interactive examples, capture and verify output:\n\n```rust\n#[test]\nfn example_colors_output() {\n    init_logging();\n    \n    // Some examples can be run with TERM=dumb to get basic output\n    let output = Command::new(\"cargo\")\n        .args([\"run\", \"--example\", \"colors_demo\"])\n        .env(\"TERM\", \"dumb\")\n        .output()\n        .expect(\"Failed to run example\");\n    \n    let stdout = String::from_utf8_lossy(&output.stdout);\n    info\\!(output_len = stdout.len(), \"Captured output\");\n    \n    // Verify expected content\n    assert\\!(stdout.contains(\"Color Demo\") || output.status.success(),\n           \"Example should produce expected output\");\n}\n```\n\n### 4. CI Integration Script\n\nCreate `scripts/test_examples.sh`:\n\n```bash\n#\\!/bin/bash\n# Test all examples for compilation and basic execution\n# Usage: ./scripts/test_examples.sh\n\nset -euo pipefail\n\nEXAMPLES_DIR=\"examples\"\nLOG_FILE=\"target/examples_test.log\"\n\necho \"=== Testing Examples ===\" | tee \"$LOG_FILE\"\necho \"Started at: $(date)\" | tee -a \"$LOG_FILE\"\n\nFAILURES=()\n\nfor example in \"$EXAMPLES_DIR\"/*.rs; do\n    name=$(basename \"$example\" .rs)\n    echo -n \"Testing $name... \" | tee -a \"$LOG_FILE\"\n    \n    # Compile\n    if cargo build --example \"$name\" 2>> \"$LOG_FILE\"; then\n        echo \"COMPILED\" | tee -a \"$LOG_FILE\"\n    else\n        echo \"COMPILE FAILED\" | tee -a \"$LOG_FILE\"\n        FAILURES+=(\"$name\")\n    fi\ndone\n\necho \"\" | tee -a \"$LOG_FILE\"\necho \"=== Summary ===\" | tee -a \"$LOG_FILE\"\necho \"Tested: $(ls \"$EXAMPLES_DIR\"/*.rs | wc -l) examples\" | tee -a \"$LOG_FILE\"\necho \"Failed: ${#FAILURES[@]}\" | tee -a \"$LOG_FILE\"\n\nif [ ${#FAILURES[@]} -gt 0 ]; then\n    echo \"Failures: ${FAILURES[*]}\" | tee -a \"$LOG_FILE\"\n    exit 1\nfi\n\necho \"All examples passed\\!\" | tee -a \"$LOG_FILE\"\nexit 0\n```\n\n## Files to Create\n\n- tests/examples_compile.rs\n- scripts/test_examples.sh (make executable)\n- .github/workflows/test-examples.yml (CI integration)\n\n## Acceptance Criteria\n\n- [ ] All examples compile without warnings\n- [ ] Non-interactive examples run without crashing\n- [ ] CI runs example tests on every PR\n- [ ] Test script produces clear pass/fail output\n- [ ] Detailed logs available for debugging failures\n- [ ] Test completes in reasonable time (<60s)\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:59:16.242320760Z","created_by":"ubuntu","updated_at":"2026-01-25T16:04:56.419374493Z","closed_at":"2026-01-25T16:04:56.419138508Z","close_reason":"Added example compile tests, script, and CI workflow","compaction_level":0,"original_size":0,"labels":["examples","testing"],"dependencies":[{"issue_id":"bd-1c6.11","depends_on_id":"bd-1c6","type":"parent-child","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-1c6.11","depends_on_id":"bd-1c6.1","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-1c6.11","depends_on_id":"bd-1c6.10","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-1c6.11","depends_on_id":"bd-1c6.12","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-1c6.11","depends_on_id":"bd-1c6.2","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-1c6.11","depends_on_id":"bd-1c6.3","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-1c6.11","depends_on_id":"bd-1c6.4","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-1c6.11","depends_on_id":"bd-1c6.5","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-1c6.11","depends_on_id":"bd-1c6.6","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-1c6.11","depends_on_id":"bd-1c6.7","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-1c6.11","depends_on_id":"bd-1c6.8","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-1c6.11","depends_on_id":"bd-1c6.9","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"}]}
{"id":"bd-1c6.12","title":"Example: Syntax highlighting demonstration","description":"# Example: Syntax Highlighting Demonstration\n\n## Purpose\n\nDemonstrate the syntax highlighting system in action. This example shows users how to:\n1. Enable syntax highlighting on a text buffer\n2. Switch between themes\n3. Display highlighted code in the terminal\n\nThis is the showcase example that proves the syntax highlighting epic delivers user value.\n\n## Code Structure\n\nCreate `examples/11_highlighting.rs`:\n\n```rust\n//\\! Example 11: Syntax Highlighting\n//\\!\n//\\! This example demonstrates the syntax highlighting system by:\n//\\! 1. Loading and displaying Rust source code with syntax colors\n//\\! 2. Allowing theme switching with keyboard shortcuts\n//\\! 3. Showing incremental highlighting updates\n//\\!\n//\\! Run with: cargo run --example 11_highlighting\n//\\! Controls:\n//\\!   1-4: Switch themes (Dark, Light, Solarized, High Contrast)\n//\\!   q: Quit\n\nuse opentui::{\n    Renderer, OptimizedBuffer, Rgba, Style,\n    highlight::{HighlightedBuffer, Theme, RustTokenizer},\n    text::TextBuffer,\n    input::{KeyCode, KeyEvent},\n};\nuse std::io;\nuse tracing::info;\n\nconst SAMPLE_CODE: &str = r#\"\n/// Calculate the factorial of a number.\nfn factorial(n: u64) -> u64 {\n    match n {\n        0 | 1 => 1,\n        _ => n * factorial(n - 1),\n    }\n}\n\nfn main() {\n    let numbers = [5, 10, 15];\n    for n in numbers {\n        println\\!(\"factorial({n}) = {}\", factorial(n));\n    }\n}\n\"#;\n\nfn main() -> io::Result<()> {\n    // Setup logging for debugging\n    let _ = tracing_subscriber::fmt()\n        .with_max_level(tracing::Level::INFO)\n        .try_init();\n    \n    info\\!(\"Starting syntax highlighting example\");\n    \n    // Create renderer\n    let mut renderer = Renderer::new(80, 24)?;\n    let (width, height) = renderer.size();\n    \n    // Create highlighted buffer\n    let text_buffer = TextBuffer::from_str(SAMPLE_CODE);\n    let mut highlighted = HighlightedBuffer::new(text_buffer)\n        .with_tokenizer(Box::new(RustTokenizer::new()))\n        .with_theme(Theme::dark());\n    highlighted.update_highlighting();\n    \n    let themes = [\n        (\"Dark\", Theme::dark()),\n        (\"Light\", Theme::light()),\n        (\"Solarized\", Theme::solarized_dark()),\n        (\"High Contrast\", Theme::high_contrast()),\n    ];\n    let mut current_theme = 0;\n    \n    loop {\n        // Clear and draw\n        let buffer = renderer.buffer();\n        buffer.clear(highlighted.theme().background());\n        \n        // Draw title bar\n        buffer.draw_text(\n            2, 0,\n            &format\\!(\"Syntax Highlighting Demo - Theme: {} (press 1-4 to switch, q to quit)\",\n                     themes[current_theme].0),\n            Style::fg(Rgba::from_hex(\"#888888\").unwrap()),\n        );\n        \n        // Draw highlighted code\n        for (line_idx, line_y) in (0..highlighted.line_count()).zip(2..height - 1) {\n            let styled_segments = highlighted.styled_line(line_idx);\n            let mut x = 2u32;\n            \n            for segment in styled_segments {\n                buffer.draw_text(x, line_y as u32, &segment.text, segment.style);\n                x += segment.text.len() as u32;\n            }\n        }\n        \n        renderer.present()?;\n        \n        // Handle input\n        if let Some(event) = renderer.poll_event(std::time::Duration::from_millis(100))? {\n            match event.key {\n                KeyEvent::Char('q') => break,\n                KeyEvent::Char('1') => {\n                    current_theme = 0;\n                    highlighted.set_theme(themes[0].1.clone());\n                    info\\!(theme = themes[0].0, \"Theme switched\");\n                }\n                KeyEvent::Char('2') => {\n                    current_theme = 1;\n                    highlighted.set_theme(themes[1].1.clone());\n                    info\\!(theme = themes[1].0, \"Theme switched\");\n                }\n                KeyEvent::Char('3') => {\n                    current_theme = 2;\n                    highlighted.set_theme(themes[2].1.clone());\n                    info\\!(theme = themes[2].0, \"Theme switched\");\n                }\n                KeyEvent::Char('4') => {\n                    current_theme = 3;\n                    highlighted.set_theme(themes[3].1.clone());\n                    info\\!(theme = themes[3].0, \"Theme switched\");\n                }\n                _ => {}\n            }\n        }\n    }\n    \n    info\\!(\"Example completed\");\n    Ok(())\n}\n```\n\n## Key Concepts Demonstrated\n\n1. **HighlightedBuffer usage** - How to wrap TextBuffer with highlighting\n2. **Theme switching** - Runtime theme changes without re-tokenization\n3. **Styled segments** - Rendering highlighted text to buffer\n4. **Tokenizer selection** - Choosing the right tokenizer for file type\n5. **Interactive demo** - Keyboard controls for theme switching\n\n## Dependencies\n\nThis example depends on:\n- bd-2x0.10 (Highlighting integration)\n- bd-2x0.3 (Theme system)\n- bd-2x0.4 (Rust tokenizer)\n\n## Files to Create\n\n- examples/11_highlighting.rs\n\n## Acceptance Criteria\n\n- [ ] Example compiles and runs\n- [ ] Rust code is displayed with syntax colors\n- [ ] Keywords, strings, comments visually distinct\n- [ ] Theme switching works immediately\n- [ ] No visible flickering or delay\n- [ ] Code is well-commented for learning\n- [ ] Keyboard controls documented in --help\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T02:01:18.194593985Z","created_by":"ubuntu","updated_at":"2026-01-25T11:26:19.397002735Z","closed_at":"2026-01-25T11:26:19.396974602Z","close_reason":"Example added + docs; fmt/check/clippy/test pass","compaction_level":0,"original_size":0,"labels":["examples","highlight"],"dependencies":[{"issue_id":"bd-1c6.12","depends_on_id":"bd-1c6","type":"parent-child","created_at":"2026-01-27T06:52:23Z","created_by":"import"},{"issue_id":"bd-1c6.12","depends_on_id":"bd-2x0.10","type":"blocks","created_at":"2026-01-27T06:52:23Z","created_by":"import"}]}
{"id":"bd-1c6.2","title":"Example: Colors and color blending","description":"# Example: Colors and Color Blending\n\n## Purpose\n\nDemonstrate OpenTUI's RGBA color system including:\n- Multiple ways to create colors (RGB, hex, HSV)\n- Alpha transparency\n- Porter-Duff blending\n- Built-in color constants\n\n## Key Concepts to Demonstrate\n\n1. **Color Creation Methods**\n   - `Rgba::new(r, g, b, a)` - f32 components\n   - `Rgba::rgb(r, g, b)` - opaque shorthand\n   - `Rgba::from_rgb_u8(r, g, b)` - u8 components\n   - `Rgba::from_hex(\"#RRGGBB\")` - CSS-style hex\n   - `Rgba::from_hsv(h, s, v)` - HSV color space\n   - Constants: `Rgba::RED`, `Rgba::BLACK`, etc.\n\n2. **Alpha Transparency**\n   - `.with_alpha(0.5)` - set alpha\n   - `.multiply_alpha(0.5)` - multiply alpha\n   - Creating translucent overlays\n\n3. **Color Blending**\n   - `set_blended()` vs `set()` \n   - Porter-Duff \"over\" compositing\n   - Visual demonstration of blending\n\n4. **Color Manipulation**\n   - `.lerp(other, t)` - linear interpolation\n   - `.to_rgb_u8()` - extract components\n\n## Visual Layout\n\n```\n╔════════════════════════════════════════════════════════════════╗\n║  OpenTUI Color Demonstration                                    ║\n╠════════════════════════════════════════════════════════════════╣\n║                                                                  ║\n║  Color Creation:                                                 ║\n║  ████ from_hex(\"#FF6600\")    ████ from_rgb_u8(102, 51, 153)    ║\n║  ████ from_hsv(120, 1, 1)    ████ Rgba::CYAN                    ║\n║                                                                  ║\n║  Alpha Blending (red over blue):                                ║\n║  ████ 100%   ████ 75%   ████ 50%   ████ 25%   ████ 0%          ║\n║                                                                  ║\n║  Color Gradient (lerp):                                          ║\n║  ██████████████████████████████████████████████████████████     ║\n║                                                                  ║\n╚════════════════════════════════════════════════════════════════╝\n```\n\n## Code Highlights\n\n```rust\n// Alpha blending demonstration\nfor (i, alpha) in [1.0, 0.75, 0.5, 0.25, 0.0].iter().enumerate() {\n    let overlay = Rgba::RED.with_alpha(*alpha);\n    let x = 5 + i as u32 * 8;\n    \n    // First draw blue background\n    buffer.set(x, y, Cell::new('█', Style::fg(Rgba::BLUE)));\n    \n    // Then blend red on top\n    buffer.set_blended(x, y, Cell::new('█', Style::fg(overlay)));\n}\n\n// Gradient using lerp\nfor i in 0..60 {\n    let t = i as f32 / 59.0;\n    let color = Rgba::RED.lerp(Rgba::BLUE, t);\n    buffer.set(5 + i, y, Cell::new('█', Style::fg(color)));\n}\n```\n\n## File to Create\n\n- `examples/02_colors.rs`\n\n## Acceptance Criteria\n\n- [ ] Shows all color creation methods\n- [ ] Alpha blending is visually clear\n- [ ] Gradient demonstrates lerp\n- [ ] Terminal supports true color (or graceful fallback)\n- [ ] Code comments explain each technique","notes":"Run with: cargo run --example 02_colors. Requires true color terminal (COLORTERM=truecolor). Uses Porter-Duff blending per AGENTS.md color.rs requirements. Test coverage via bd-1c6.11.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:10:00.438336091Z","created_by":"ubuntu","updated_at":"2026-01-25T12:53:36.249968583Z","closed_at":"2026-01-25T12:53:36.249948936Z","close_reason":"Added 02_colors example covering RGBA creation, alpha blending, and gradients","compaction_level":0,"original_size":0,"labels":["beginner","examples"],"dependencies":[{"issue_id":"bd-1c6.2","depends_on_id":"bd-1c6","type":"parent-child","created_at":"2026-01-27T06:52:23Z","created_by":"import"}]}
{"id":"bd-1c6.3","title":"Example: Text styles and attributes","description":"# Example: Text Styles and Attributes\n\n## Purpose\n\nDemonstrate all text styling options:\n- Foreground and background colors\n- Text attributes (bold, italic, underline, etc.)\n- Style builder pattern\n- Combining multiple attributes\n\n## Key Concepts\n\n1. **Style Builder**\n   ```rust\n   Style::builder()\n       .fg(Rgba::WHITE)\n       .bg(Rgba::BLUE)\n       .bold()\n       .italic()\n       .build()\n   ```\n\n2. **Shorthand Methods**\n   ```rust\n   Style::fg(color)\n   Style::bg(color)\n   Style::bold()\n   Style::italic()\n   Style::underline()\n   Style::dim()\n   Style::inverse()\n   ```\n\n3. **TextAttributes Bitflags**\n   - BOLD\n   - DIM\n   - ITALIC\n   - UNDERLINE\n   - BLINK\n   - INVERSE (reverse video)\n   - HIDDEN\n   - STRIKETHROUGH\n\n4. **Combining Styles**\n   ```rust\n   Style::fg(color).with_bold().with_italic()\n   ```\n\n## Visual Layout\n\n```\n╔══════════════════════════════════════════════════════════════════╗\n║  Text Styles Demo                                                 ║\n╠══════════════════════════════════════════════════════════════════╣\n║                                                                   ║\n║  Individual Attributes:                                           ║\n║  Normal text   Bold text   Italic text   Underlined             ║\n║  Dim text      Inverse     Strikethrough                         ║\n║                                                                   ║\n║  Combined Attributes:                                             ║\n║  Bold + Italic   Bold + Underline   All three combined           ║\n║                                                                   ║\n║  Colors + Attributes:                                             ║\n║  Red bold   Green italic   Blue underline   Yellow inverse       ║\n║                                                                   ║\n║  Background Colors:                                               ║\n║   White on Black    Black on White    Blue on Yellow            ║\n║                                                                   ║\n╚══════════════════════════════════════════════════════════════════╝\n```\n\n## Implementation Notes\n\n- Some terminals don't support all attributes (italic, strikethrough)\n- Show graceful degradation where applicable\n- Demonstrate that styles are value types (Copy)\n\n## File to Create\n\n- `examples/03_styles.rs`\n\n## Acceptance Criteria\n\n- [ ] All TextAttributes demonstrated\n- [ ] Style builder pattern shown\n- [ ] Shorthand methods shown\n- [ ] Combined attributes demonstrated\n- [ ] Colors with attributes\n- [ ] Background colors\n- [ ] Comments explain terminal compatibility","notes":"Run with: cargo run --example 03_styles. Demonstrates TextAttributes bitflags. Note: some terminals dont support all attributes (italic, strikethrough). Test coverage via bd-1c6.11.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:10:16.629315250Z","created_by":"ubuntu","updated_at":"2026-01-25T12:58:07.545405615Z","closed_at":"2026-01-25T12:58:07.545387381Z","close_reason":"Added 03_styles example demonstrating text attributes, builder patterns, and background colors","compaction_level":0,"original_size":0,"labels":["beginner","examples"],"dependencies":[{"issue_id":"bd-1c6.3","depends_on_id":"bd-1c6","type":"parent-child","created_at":"2026-01-27T06:52:23Z","created_by":"import"}]}
{"id":"bd-1c6.4","title":"Example: Drawing primitives (boxes, lines, fills)","description":"# Example: Drawing Primitives\n\n## Purpose\n\nDemonstrate buffer drawing operations:\n- `draw_box()` with different box styles\n- `draw_hline()` and `draw_vline()`\n- `fill_rect()` for solid rectangles\n- Combining primitives to create UI layouts\n\n## Key Concepts\n\n1. **Box Styles**\n   ```rust\n   BoxStyle::single()    // ┌─┐│ │└─┘\n   BoxStyle::double()    // ╔═╗║ ║╚═╝\n   BoxStyle::rounded()   // ╭─╮│ │╰─╯\n   BoxStyle::heavy()     // ┏━┓┃ ┃┗━┛\n   BoxStyle::ascii()     // +-+| |+-+\n   ```\n\n2. **Drawing Operations**\n   ```rust\n   buffer.draw_box(x, y, width, height, box_style);\n   buffer.draw_hline(x, y, length, '─', style);\n   buffer.draw_vline(x, y, length, '│', style);\n   buffer.fill_rect(x, y, width, height, bg_color);\n   ```\n\n3. **Box Drawing Options**\n   - Custom corner characters\n   - Selective sides (draw only top, left+right, etc.)\n   - With title text\n\n## Visual Layout\n\n```\n╔════════════════════════════════════════════════════════════════╗\n║  Drawing Primitives                                             ║\n╠════════════════════════════════════════════════════════════════╣\n║                                                                  ║\n║  Box Styles:                                                     ║\n║  ┌────────┐  ╔════════╗  ╭────────╮  ┏━━━━━━━━┓  +--------+    ║\n║  │ Single │  ║ Double ║  │Rounded │  ┃ Heavy  ┃  | ASCII  |    ║\n║  └────────┘  ╚════════╝  ╰────────╯  ┗━━━━━━━━┛  +--------+    ║\n║                                                                  ║\n║  Lines:                                                          ║\n║  ────────────────  Horizontal                                    ║\n║  │                                                               ║\n║  │  Vertical                                                     ║\n║  │                                                               ║\n║                                                                  ║\n║  ╔═══════════════════╗                                          ║\n║  ║   Filled Rect     ║  <- fill_rect() with box overlay        ║\n║  ╚═══════════════════╝                                          ║\n║                                                                  ║\n╚════════════════════════════════════════════════════════════════╝\n```\n\n## Advanced Patterns\n\nShow common UI patterns built from primitives:\n- Panel with title\n- Split panes (horizontal and vertical)\n- Bordered content area\n\n## File to Create\n\n- `examples/04_drawing.rs`\n\n## Acceptance Criteria\n\n- [ ] All box styles demonstrated\n- [ ] Horizontal and vertical lines\n- [ ] fill_rect with transparency\n- [ ] Composite patterns (panel with title)\n- [ ] Code shows combining primitives","notes":"Run with: cargo run --example 04_drawing. Demonstrates BoxStyle variants from buffer/drawing.rs. Uses unicode box-drawing characters. Test coverage via bd-1c6.11.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:10:34.986508251Z","created_by":"ubuntu","updated_at":"2026-01-25T13:02:46.472070737Z","closed_at":"2026-01-25T13:02:46.472051300Z","close_reason":"Added 04_drawing example covering box styles, lines, fill_rect, and composite panels","compaction_level":0,"original_size":0,"labels":["beginner","examples"],"dependencies":[{"issue_id":"bd-1c6.4","depends_on_id":"bd-1c6","type":"parent-child","created_at":"2026-01-27T06:52:23Z","created_by":"import"}]}
{"id":"bd-1c6.5","title":"Example: Scissor clipping","description":"# Example: Scissor Clipping\n\n## Purpose\n\nDemonstrate the scissor (clipping) system:\n- Basic scissor rectangles\n- Nested scissors (intersection)\n- Practical use cases (scrolling content, panels)\n\n## Key Concepts\n\n1. **Scissor Stack**\n   ```rust\n   buffer.push_scissor(ClipRect::new(x, y, width, height));\n   // Drawing operations are clipped to the scissor rect\n   buffer.draw_text(0, 0, \"This text clips at boundaries\", style);\n   buffer.pop_scissor();\n   ```\n\n2. **Nested Scissors**\n   - Inner scissor is intersection of outer and inner\n   - Enables hierarchical UI layouts\n\n3. **ClipRect**\n   ```rust\n   ClipRect::new(x, y, width, height)\n   ClipRect::from_dimensions(width, height)  // At origin\n   ```\n\n## Visual Demonstration\n\n```\n╔════════════════════════════════════════════════════════════════════╗\n║  Scissor Clipping Demo                                              ║\n╠════════════════════════════════════════════════════════════════════╣\n║                                                                      ║\n║  Without scissor:                                                    ║\n║  ┌──────────────────────────────────────────────────────────────┐  ║\n║  │ This is a very long line of text that extends beyond the box │→ ║\n║  └──────────────────────────────────────────────────────────────┘  ║\n║                                                                      ║\n║  With scissor:                                                       ║\n║  ┌──────────────────────────────────────────────────────────────┐  ║\n║  │ This is a very long line of text that exten                   │  ║\n║  └──────────────────────────────────────────────────────────────┘  ║\n║  (Text is cleanly clipped at box boundary)                          ║\n║                                                                      ║\n║  Nested scissors (blue outer, red inner):                           ║\n║  ┌────────────────────────┐                                         ║\n║  │  ████████████████████  │  ← Red area visible                     ║\n║  │  ████████████████████  │    (intersection)                       ║\n║  │                        │                                         ║\n║  └────────────────────────┘                                         ║\n║                                                                      ║\n╚════════════════════════════════════════════════════════════════════╝\n```\n\n## Practical Pattern: Scrollable Content\n\n```rust\n// Viewport for scrollable content\nbuffer.push_scissor(ClipRect::new(panel_x, panel_y, panel_w, panel_h));\n\n// Draw content at scrolled position (may be partially outside viewport)\nfor (i, line) in content.iter().enumerate() {\n    let y = panel_y + i as u32 - scroll_offset;\n    buffer.draw_text(panel_x, y as u32, line, style);\n}\n\nbuffer.pop_scissor();\n```\n\n## File to Create\n\n- `examples/05_scissoring.rs`\n\n## Acceptance Criteria\n\n- [ ] Basic scissor clipping demonstrated\n- [ ] Nested scissor intersection shown\n- [ ] Practical scrolling example\n- [ ] Visual comparison with/without scissor\n- [ ] Comments explain scissor stack semantics","notes":"Run with: cargo run --example 05_scissoring. Demonstrates ScissorStack from buffer/scissor.rs. Key pattern for scrollable content and panel layouts. Test coverage via bd-1c6.11.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:10:52.717827794Z","created_by":"ubuntu","updated_at":"2026-01-25T13:07:48.111581930Z","closed_at":"2026-01-25T13:07:48.111559358Z","close_reason":"Added 05_scissor example demonstrating scissor clipping and nested regions","compaction_level":0,"original_size":0,"labels":["examples","intermediate"],"dependencies":[{"issue_id":"bd-1c6.5","depends_on_id":"bd-1c6","type":"parent-child","created_at":"2026-01-27T06:52:23Z","created_by":"import"}]}
{"id":"bd-1c6.6","title":"Example: Opacity and transparency","description":"# Example: Opacity and Transparency\n\n## Purpose\n\nDemonstrate the opacity stack system and transparent overlays:\n- Opacity stack (multiplicative)\n- Layered UI elements\n- Modal dialogs with dimmed backgrounds\n- Ghost/watermark effects\n\n## Key Concepts\n\n1. **Opacity Stack**\n   ```rust\n   buffer.push_opacity(0.5);  // 50% opacity\n   // All drawing operations affected\n   buffer.draw_text(x, y, \"Semi-transparent\", style);\n   buffer.pop_opacity();\n   ```\n\n2. **Multiplicative Opacity**\n   - Outer 0.5 × Inner 0.5 = 0.25 effective opacity\n   - Enables nested transparency\n\n3. **Respect Alpha Mode**\n   ```rust\n   buffer.set_respect_alpha(true);  // Enable alpha blending\n   ```\n\n## Visual Demonstration\n\n```\n╔════════════════════════════════════════════════════════════════════╗\n║  Opacity and Transparency Demo                                      ║\n╠════════════════════════════════════════════════════════════════════╣\n║                                                                      ║\n║  Background pattern: ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║\n║                      ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║\n║                      ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ║\n║                                                                      ║\n║  Opacity levels (100%, 75%, 50%, 25%):                              ║\n║  ████████  ████████  ████████  ████████                             ║\n║  100%      75%       50%       25%                                  ║\n║                                                                      ║\n║  Modal dialog pattern:                                               ║\n║  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░                   ║\n║  ░░░░░░░┌────────────────────────┐░░░░░░░░░░░░░                     ║\n║  ░░░░░░░│      Modal Dialog      │░░░░░░░░░░░░░                     ║\n║  ░░░░░░░│                        │░░░░░░░░░░░░░                     ║\n║  ░░░░░░░│   Content here         │░░░░░░░░░░░░░                     ║\n║  ░░░░░░░└────────────────────────┘░░░░░░░░░░░░░                     ║\n║  ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░                   ║\n║  (Background dimmed with 50% opacity overlay)                        ║\n║                                                                      ║\n╚════════════════════════════════════════════════════════════════════╝\n```\n\n## Practical Pattern: Modal Dialog\n\n```rust\n// Draw main content\ndraw_main_ui(buffer);\n\n// Dim background\nbuffer.push_opacity(0.5);\nbuffer.fill_rect(0, 0, width, height, Rgba::BLACK);\nbuffer.pop_opacity();\n\n// Draw dialog (full opacity)\nbuffer.draw_box(dialog_x, dialog_y, dialog_w, dialog_h, BoxStyle::double());\nbuffer.draw_text(dialog_x + 2, dialog_y + 2, \"Modal Dialog\", title_style);\n```\n\n## File to Create\n\n- `examples/06_opacity.rs`\n\n## Acceptance Criteria\n\n- [ ] Opacity stack demonstrated\n- [ ] Nested opacity (multiplicative)\n- [ ] Modal dialog pattern\n- [ ] Visual comparison at different opacity levels\n- [ ] Background shows through transparent elements","notes":"Run with: cargo run --example 06_opacity. Demonstrates OpacityStack from buffer/opacity.rs. Key pattern for modal dialogs and layered UI. Test coverage via bd-1c6.11.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:11:15.149907368Z","created_by":"ubuntu","updated_at":"2026-01-25T13:09:43.686871122Z","closed_at":"2026-01-25T13:09:43.686849371Z","close_reason":"Added 06_opacity example covering opacity stack and blended overlays","compaction_level":0,"original_size":0,"labels":["examples","intermediate"],"dependencies":[{"issue_id":"bd-1c6.6","depends_on_id":"bd-1c6","type":"parent-child","created_at":"2026-01-27T06:52:23Z","created_by":"import"}]}
{"id":"bd-1c6.7","title":"Example: Keyboard and mouse input","description":"# Example: Keyboard and Mouse Input\n\n## Purpose\n\nDemonstrate OpenTUI's input parsing system:\n- Keyboard events (keys, modifiers)\n- Mouse events (clicks, movement, scroll)\n- The input parser and event types\n- Building an interactive application\n\n## Key Concepts\n\n1. **InputParser**\n   ```rust\n   let mut parser = InputParser::new();\n   \n   // Feed raw bytes from stdin\n   match parser.parse(&input_bytes) {\n       Ok((event, consumed)) => { /* handle event */ }\n       Err(ParseError::Incomplete) => { /* need more bytes */ }\n       Err(ParseError::Empty) => { /* no input */ }\n       Err(_) => { /* unrecognized sequence */ }\n   }\n   ```\n\n2. **Event Types**\n   ```rust\n   Event::Key(KeyEvent { code, ctrl, alt, shift })\n   Event::Mouse(MouseEvent { kind, x, y, modifiers })\n   Event::Resize(width, height)\n   Event::Paste(text)\n   Event::Focus(focused)\n   ```\n\n3. **KeyCode Variants**\n   - `Char('a')` - Regular characters\n   - `Enter`, `Escape`, `Tab`, `Backspace`, `Delete`\n   - `Up`, `Down`, `Left`, `Right`\n   - `Home`, `End`, `PageUp`, `PageDown`\n   - `F(1)` through `F(12)`\n\n4. **MouseEventKind**\n   - `Press` - Button pressed\n   - `Release` - Button released\n   - `Move` - Mouse moved (if tracking enabled)\n   - `ScrollUp`, `ScrollDown`\n\n## Visual Layout\n\n```\n╔════════════════════════════════════════════════════════════════════╗\n║  Input Demo                                               [Ctrl+Q] ║\n╠════════════════════════════════════════════════════════════════════╣\n║                                                                      ║\n║  Last keyboard event:                                                ║\n║  ┌──────────────────────────────────────────────────────────────┐  ║\n║  │  Key: 'a'  Ctrl: false  Alt: false  Shift: false              │  ║\n║  └──────────────────────────────────────────────────────────────┘  ║\n║                                                                      ║\n║  Last mouse event:                                                   ║\n║  ┌──────────────────────────────────────────────────────────────┐  ║\n║  │  Kind: Press  Button: Left  Position: (42, 15)                │  ║\n║  └──────────────────────────────────────────────────────────────┘  ║\n║                                                                      ║\n║  Event log:                                                          ║\n║  ┌──────────────────────────────────────────────────────────────┐  ║\n║  │  Key(Enter)                                                    │  ║\n║  │  Mouse(Move, 30, 10)                                          │  ║\n║  │  Key(Char('h'), ctrl=true)                                    │  ║\n║  │  Mouse(ScrollDown, 30, 10)                                    │  ║\n║  └──────────────────────────────────────────────────────────────┘  ║\n║                                                                      ║\n║  Click anywhere • Press any key • Ctrl+Q to quit                    ║\n╚════════════════════════════════════════════════════════════════════╝\n```\n\n## Implementation Pattern\n\n```rust\nloop {\n    // Render current state\n    renderer.buffer().clear(bg);\n    draw_ui(renderer.buffer(), &last_key, &last_mouse, &event_log);\n    renderer.present()?;\n    \n    // Read input with timeout\n    if let Ok(n) = read_with_timeout(&stdin, &mut buf, Duration::from_millis(16)) {\n        if n > 0 {\n            let mut offset = 0;\n            while offset < n {\n                match parser.parse(&buf[offset..n]) {\n                    Ok((event, consumed)) => {\n                        offset += consumed;\n                        match &event {\n                            Event::Key(key) if key.is_ctrl_c() || \n                                (key.ctrl && key.code == KeyCode::Char('q')) => {\n                                return Ok(());\n                            }\n                            Event::Key(key) => last_key = Some(key.clone()),\n                            Event::Mouse(mouse) => last_mouse = Some(mouse.clone()),\n                            _ => {}\n                        }\n                        event_log.push(format!(\"{:?}\", event));\n                    }\n                    Err(_) => break,\n                }\n            }\n        }\n    }\n}\n```\n\n## File to Create\n\n- `examples/07_input.rs`\n\n## Acceptance Criteria\n\n- [ ] Keyboard events displayed\n- [ ] Mouse events displayed (click, move, scroll)\n- [ ] Modifier keys shown (Ctrl, Alt, Shift)\n- [ ] Event log scrolls to show history\n- [ ] Clean exit with Ctrl+Q or Ctrl+C\n- [ ] Non-blocking input reading","notes":"Run with: cargo run --example 07_input. Demonstrates InputParser from input module. Uses non-blocking stdin read. Exit with Ctrl+Q or Ctrl+C. Test coverage via bd-1c6.11.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:11:40.770318511Z","created_by":"ubuntu","updated_at":"2026-01-25T13:11:39.592005188Z","closed_at":"2026-01-25T13:11:39.591983267Z","close_reason":"Added 07_input example demonstrating keyboard/mouse input parsing","compaction_level":0,"original_size":0,"labels":["examples","intermediate"],"dependencies":[{"issue_id":"bd-1c6.7","depends_on_id":"bd-1c6","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1c6.8","title":"Example: Simple animation loop","description":"# Example: Simple Animation Loop\n\n## Purpose\n\nDemonstrate how to create smooth animations with OpenTUI:\n- Frame-based animation loop\n- Delta time calculation\n- Moving elements\n- Color transitions\n- Frame rate control\n\n## Key Concepts\n\n1. **Animation Loop Structure**\n   ```rust\n   let mut last_frame = Instant::now();\n   loop {\n       let now = Instant::now();\n       let dt = now.duration_since(last_frame).as_secs_f32();\n       last_frame = now;\n       \n       update(dt);  // Update animation state\n       render();    // Draw current frame\n       \n       // Cap frame rate\n       let frame_time = Instant::now().duration_since(now);\n       if frame_time < FRAME_DURATION {\n           thread::sleep(FRAME_DURATION - frame_time);\n       }\n   }\n   ```\n\n2. **Animation Types**\n   - Position animation (moving text)\n   - Color animation (pulsing, fading)\n   - Progress bars\n   - Spinners and loading indicators\n\n3. **Easing Functions**\n   - Linear\n   - Ease-in/out (quadratic, sine)\n   - Bounce\n\n## Visual Demonstration\n\n```\n╔════════════════════════════════════════════════════════════════════╗\n║  Animation Demo                                          60 FPS    ║\n╠════════════════════════════════════════════════════════════════════╣\n║                                                                      ║\n║  Bouncing text:                                                      ║\n║           ★ OpenTUI ★                                               ║\n║                                                                      ║\n║  Color pulse:                                                        ║\n║  ████████████████████████████████████████████                       ║\n║                                                                      ║\n║  Progress bar:                                                       ║\n║  [████████████████████░░░░░░░░░░░░░░░░░░░░] 47%                    ║\n║                                                                      ║\n║  Spinner:  ⠋ Loading...                                             ║\n║                                                                      ║\n║  Wave:                                                               ║\n║  ∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿∿          ║\n║                                                                      ║\n║                                                     Press Q to quit ║\n╚════════════════════════════════════════════════════════════════════╝\n```\n\n## Animation Implementations\n\n```rust\n// Bouncing position\nlet bounce_y = (time * 2.0).sin().abs() * 5.0;\n\n// Color pulse\nlet pulse = ((time * 3.0).sin() + 1.0) / 2.0;  // 0.0 to 1.0\nlet color = Rgba::RED.lerp(Rgba::BLUE, pulse);\n\n// Spinner frames\nconst SPINNER: &[char] = &['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];\nlet frame = (time * 10.0) as usize % SPINNER.len();\n\n// Progress bar\nlet progress = (time * 0.1) % 1.0;  // Loops 0.0 to 1.0\nlet filled = (progress * bar_width as f32) as u32;\n```\n\n## File to Create\n\n- `examples/08_animation.rs`\n\n## Acceptance Criteria\n\n- [ ] Smooth animation at ~60 FPS\n- [ ] Multiple animation types shown\n- [ ] Delta time used for frame-independent animation\n- [ ] FPS counter displayed\n- [ ] Clean exit handling\n- [ ] No flicker (synchronized output working)","notes":"Run with: cargo run --example 08_animation. Targets 60 FPS with delta-time animation. Uses Instant::now() for timing. Key pattern for dynamic TUI apps. Test coverage via bd-1c6.11.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T01:12:04.625622906Z","created_by":"ubuntu","updated_at":"2026-01-25T13:13:51.717012705Z","closed_at":"2026-01-25T13:13:51.716991535Z","close_reason":"Added 08_animation example with simple render loop and bouncing dot","compaction_level":0,"original_size":0,"labels":["examples","intermediate"],"dependencies":[{"issue_id":"bd-1c6.8","depends_on_id":"bd-1c6","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1c6.9","title":"Example: TextBuffer and styled segments","description":"# Example: TextBuffer and Styled Segments\n\n## Purpose\n\nDemonstrate the text module's TextBuffer and StyledSegment:\n- Creating styled text with multiple colors/styles\n- TextBuffer operations\n- Rendering styled text to the buffer\n- Text manipulation\n\n## Key Concepts\n\n1. **StyledSegment**\n   ```rust\n   StyledSegment::new(\"Hello \", Style::fg(Rgba::WHITE))\n   StyledSegment::new(\"World\", Style::fg(Rgba::GREEN).with_bold())\n   ```\n\n2. **TextBuffer**\n   ```rust\n   let mut tb = TextBuffer::new();\n   tb.push_segment(\"Hello \", Style::default());\n   tb.push_segment(\"World\", Style::fg(Rgba::GREEN));\n   \n   // Or from segments\n   let tb = TextBuffer::from_segments(vec![\n       StyledSegment::new(\"Error: \", Style::fg(Rgba::RED).with_bold()),\n       StyledSegment::new(\"File not found\", Style::default()),\n   ]);\n   ```\n\n3. **Rendering to OptimizedBuffer**\n   ```rust\n   for segment in text_buffer.segments() {\n       buffer.draw_text(x, y, &segment.text, segment.style);\n       x += segment.display_width() as u32;\n   }\n   ```\n\n## Visual Demonstration\n\n```\n╔════════════════════════════════════════════════════════════════════╗\n║  TextBuffer Demo                                                    ║\n╠════════════════════════════════════════════════════════════════════╣\n║                                                                      ║\n║  Simple styled text:                                                 ║\n║  The quick brown fox jumps over the lazy dog.                       ║\n║       ^^^^^ ^^^^^                      ^^^^                          ║\n║       green orange                     blue                          ║\n║                                                                      ║\n║  Log message styling:                                                ║\n║  [INFO]  Application started successfully                           ║\n║  [WARN]  Configuration file missing, using defaults                 ║\n║  [ERROR] Failed to connect to database                              ║\n║                                                                      ║\n║  Code snippet:                                                       ║\n║  fn main() {                                                         ║\n║      let x = 42;                                                    ║\n║      println!(\"Hello, {x}!\");                                       ║\n║  }                                                                   ║\n║  (Keywords blue, strings green, numbers purple)                     ║\n║                                                                      ║\n╚════════════════════════════════════════════════════════════════════╝\n```\n\n## Practical Patterns\n\n```rust\n// Log message formatter\nfn format_log(level: LogLevel, message: &str) -> TextBuffer {\n    let (level_text, level_style) = match level {\n        LogLevel::Info => (\"[INFO]  \", Style::fg(Rgba::CYAN)),\n        LogLevel::Warn => (\"[WARN]  \", Style::fg(Rgba::YELLOW)),\n        LogLevel::Error => (\"[ERROR] \", Style::fg(Rgba::RED).with_bold()),\n    };\n    \n    TextBuffer::from_segments(vec![\n        StyledSegment::new(level_text, level_style),\n        StyledSegment::new(message, Style::default()),\n    ])\n}\n\n// Highlighted search result\nfn highlight_match(text: &str, query: &str) -> TextBuffer {\n    let mut tb = TextBuffer::new();\n    let highlight = Style::bg(Rgba::YELLOW).fg(Rgba::BLACK);\n    \n    for (i, part) in text.split(query).enumerate() {\n        if i > 0 {\n            tb.push_segment(query, highlight);\n        }\n        tb.push_segment(part, Style::default());\n    }\n    tb\n}\n```\n\n## File to Create\n\n- `examples/09_text_buffer.rs`\n\n## Acceptance Criteria\n\n- [ ] TextBuffer creation demonstrated\n- [ ] Multiple segments with different styles\n- [ ] Rendering to OptimizedBuffer\n- [ ] Practical use cases (log formatting, search highlight)\n- [ ] Display width handling for wide characters","notes":"Run with: cargo run --example 09_text_buffer. Demonstrates TextBuffer and StyledSegment from text module. Key pattern for syntax highlighting integration. Test coverage via bd-1c6.11.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T01:12:26.240986541Z","created_by":"ubuntu","updated_at":"2026-01-25T15:29:16.266252754Z","closed_at":"2026-01-25T15:29:16.266223689Z","close_reason":"done","compaction_level":0,"original_size":0,"labels":["examples","intermediate"],"dependencies":[{"issue_id":"bd-1c6.9","depends_on_id":"bd-1c6","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1co","title":"[EPIC] demo_showcase: flagship standalone app (turned up to 11)","description":"# Epic: `demo_showcase` — Flagship Standalone App (Turned Up To 11)\n\n## What We’re Building\n\nA **single standalone Rust binary** named `demo_showcase` that you can run with:\n\n```bash\ncargo run --bin demo_showcase\n```\n\nIt should feel like a real, modern terminal application (dashboard + editor + inspector) that proves OpenTUI is:\n\n- **Correct** (alpha blending / graphemes / width / clipping)\n- **Fast** (diff rendering, minimal ANSI bytes, smooth frame pacing)\n- **Practical** (you can actually build serious apps with it)\n- **Aesthetically elite** (polished, stylish, highly legible, fun)\n\nThis is **not** a toy slideshow. It’s a cohesive “product-grade” demo app where *every* OpenTUI subsystem shows up naturally.\n\n## Why This Matters (Project-Level Goals)\n\nOpenTUI’s pitch is “rendering engine, not framework.” A flagship demo app should:\n\n1. Demonstrate *engine primitives* (buffer composition, clipping, blending) in a way that looks like real UI.\n2. Provide a credible reference architecture for how to drive OpenTUI in an app loop.\n3. Be a visual calling card: screenshots/videos should instantly communicate capability.\n\n## Hard Requirements (Feature Coverage Matrix)\n\nThe demo must exercise **all advanced capabilities** in a way a viewer can recognize:\n\n### Rendering / Output\n- Double-buffered rendering + diff detection (`Renderer::present`) with visible “no flicker” behavior.\n- Synchronized output (`\\x1b[?2026h`) when the terminal supports it.\n- Debug overlay / stats (FPS, cells updated, memory estimate) to prove perf characteristics.\n\n### Composition\n- Real RGBA alpha blending (Porter–Duff “over”) with visually obvious layering.\n- Opacity stack affecting whole UI subtrees.\n- Scissor stack with nested clip rects (scrollable lists, clipped charts, etc.).\n\n### Text & Unicode\n- Accurate width handling for wide chars (CJK) and emoji.\n- **Grapheme pool** path used somewhere non-trivially (multi-codepoint ZWJ emoji rendered correctly).\n\n### Editing & Highlighting\n- A real “editor panel” using `EditBuffer` / `EditorView`:\n  - undo/redo\n  - word/char wrap toggles\n  - selection rendering\n  - cursor navigation\n- Syntax highlighting with tokenizer + theme switching.\n\n### Input & Interactivity\n- Keyboard input parsing (arrows, function keys, modifiers).\n- Bracketed paste handling (paste a block into the editor; show it worked).\n- Focus events (gain/loss) reflected in UI state.\n- Resize handling (`renderer.resize`).\n- Mouse support:\n  - click to focus panels / select items\n  - scroll wheel to scroll a list\n  - hit testing via `HitGrid` (clickable UI “buttons”)\n\n### Extra Capability Showpieces\n- Hyperlinks via OSC 8 (`LinkPool` + style packed link id).\n- Pixel-level rendering demo (`PixelBuffer`, `GrayscaleBuffer`, supersampling/quadrants) integrated into a “preview” panel.\n\n## Non‑Goals (Guardrails)\n\n- Do **not** turn OpenTUI into a widget framework.\n- Keep demo-specific abstractions **inside the binary** (or a minimal internal module) so the library remains lean.\n- Avoid adding new third-party dependencies unless there is a very strong justification (the demo should showcase OpenTUI, not an ecosystem stack).\n\n## Deliverables\n\n- `src/bin/demo_showcase.rs` (primary entry point; real-world quality)\n- Minimal supporting code (prefer inline modules inside the binary; avoid file proliferation)\n- Tests:\n  - compile test for the bin\n  - headless smoke tests for deterministic render building blocks\n  - optional ignored interactive tests for real-terminal verification\n- Docs:\n  - README entry: how to run + what it demonstrates\n  - in-app help overlay that documents keybinds and interaction model\n\n## Design Pillars (“Turned Up To 11”)\n\n- Modern visual language: gradients, glassy overlays, crisp borders, strong spacing rhythm.\n- Animations that feel intentional (subtle, smooth, never jittery).\n- Realistic information architecture: sidebar nav, editor, preview, logs, command palette.\n- Great usability defaults: discoverable keybinds, status hints, consistent focus/selection styling.","acceptance_criteria":"Checklist:\n- [ ] `cargo run --bin demo_showcase` launches a cohesive multi-panel app\n- [ ] Demonstrates alpha blending + opacity + scissor in visually obvious ways\n- [ ] Demonstrates editor + undo/redo + selection + wrap + highlighting\n- [ ] Demonstrates mouse hit testing and clickable UI elements\n- [ ] Demonstrates OSC 8 hyperlinks (clickable in supporting terminals)\n- [ ] Demonstrates pixel buffer rendering integrated into UI\n- [ ] Handles resize safely (no panic, layout stays readable)\n- [ ] Has an in-app help overlay and a guided “tour” mode\n- [ ] Includes headless/compile tests so CI proves it stays working\n- [ ] `cargo fmt --check`, `cargo clippy --all-targets -- -D warnings`, `cargo test` all pass","notes":"## Implementation Notes\n\n- Prefer a deterministic “tour script” mode that auto-drives the UI for screenshots/video capture.\n- Use `Renderer::buffer_with_pool()` and pool-aware drawing paths where we intentionally render multi-codepoint graphemes.\n- Keep the demo robust in non-ideal terminals (small size, no truecolor): degrade gracefully.\n\n## Coordination\n\n- All implementation work should reference this epic’s ID (`bd-1co`) for file reservations / agent mail threads.","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-27T22:02:11.047102160Z","created_by":"ubuntu","updated_at":"2026-01-27T22:03:36.566022399Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","epic"]}
{"id":"bd-1e4","title":"demo_showcase UI: app chrome (top bar + status bar + focus indicator)","description":"# demo_showcase UI — App Chrome (Top Bar + Status Bar)\n\n## Purpose\n\nImplement persistent chrome that makes the app feel “real”:\n\n- top bar: branding, project, mode, time, clickable actions\n- status bar: key hints + perf stats + notifications\n\n## Top Bar Requirements\n\n- Full-width gradient background (subtle animated pulse)\n- Brand left: `OpenTUI Showcase`\n- Center: current section / file\n- Right: mode badge + time\n- Clickable buttons (prove HitGrid):\n  - `Help` (F1)\n  - `Palette` (Ctrl+P)\n  - `Tour` (Ctrl+T)\n\n## Status Bar Requirements\n\n- Left: context-sensitive key hints (changes by mode)\n- Right: performance snapshot:\n  - fps (from `RenderStats`)\n  - changed cells (last frame)\n  - memory estimate\n\n## Implementation Notes\n\n- Use design tokens from `bd-1pd`.\n- HitGrid:\n  - each top-bar button gets a hit id\n  - click routes to actions","acceptance_criteria":"Checklist:\n- [ ] Top bar renders with gradient + brand + mode/time\n- [ ] Top bar buttons are clickable and toggle overlays\n- [ ] Status bar renders key hints and perf stats\n- [ ] Focused panel is visible in chrome (badge or border)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:12:59.147085059Z","created_by":"ubuntu","updated_at":"2026-01-27T22:33:24.331367840Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","ui"],"dependencies":[{"issue_id":"bd-1e4","depends_on_id":"bd-1pd","type":"blocks","created_at":"2026-01-27T22:31:50.100288466Z","created_by":"ubuntu"},{"issue_id":"bd-1e4","depends_on_id":"bd-35g","type":"blocks","created_at":"2026-01-27T22:31:50.637937443Z","created_by":"ubuntu"},{"issue_id":"bd-1e4","depends_on_id":"bd-3ii","type":"blocks","created_at":"2026-01-27T22:31:51.198606372Z","created_by":"ubuntu"},{"issue_id":"bd-1e4","depends_on_id":"bd-c75","type":"parent-child","created_at":"2026-01-27T22:12:59.198380679Z","created_by":"ubuntu"},{"issue_id":"bd-1e4","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:33:24.331341782Z","created_by":"ubuntu"}]}
{"id":"bd-1ei","title":"demo_showcase spec: content pack (sample code, logs, links, unicode strings, metrics)","description":"# demo_showcase Spec — Content Pack\n\n## Purpose\n\nThe demo needs a high-quality “content pack” so it looks like a real application and also proves correctness:\n\n- realistic code to edit (highlighting + editing)\n- logs that look like real systems output\n- deterministic metrics for charts\n- Unicode strings that prove grapheme + width correctness\n- hyperlink URLs to prove OSC 8 integration\n\nThis bead defines the canonical content sets so every other bead can reference them without re-inventing strings.\n\n## Content Sets\n\n### 1) Editor Sample Content (highlighting + editing)\n\nPrimary buffer: a small Rust module that contains:\n\n- `struct`/`enum` + `impl`\n- lifetimes + generics\n- doc comments + line comments\n- `match`, `if let`, `Result`/`?`\n- strings with escapes + raw strings\n- a few `TODO:` style comments (to look realistic)\n\nSecondary buffer (optional): Markdown with fenced Rust code blocks to prove tokenizer switching (if supported by the built-in registries).\n\n**Important constraint:** keep the editor sample mostly to single-codepoint characters. Avoid multi-codepoint graphemes (ZWJ emoji, combining sequences) in the editor text itself, because `EditorView::render_to` does not use the grapheme pool path.\n\n### 2) Logs Content (event stream)\n\nThe logs panel should show an event stream with:\n\n- timestamps\n- `INFO/WARN/ERROR` levels\n- subsystem tags (`renderer`, `input`, `preview`, `tour`, etc.)\n- a few “actionable” entries that are linkified via OSC 8\n\nExample (conceptual):\n\n- `[22:05:12] INFO  renderer: diff=124 cells, bytes=3.1KB`\n- `[22:05:13] WARN  input: focus lost (paused)`\n- `[22:05:14] ERROR preview: simulated failure (press R to retry)`\n\n### 3) Metrics Content (charts + animation)\n\nMetrics must be deterministic (derived from time + fixed parameters):\n\n- FPS + frame time\n- “CPU usage” synthetic waveform\n- “memory bytes” synthetic counter\n- a periodic “pulse” value for glow animations\n\nNo randomness (so tour mode is reproducible and tests can assert on values).\n\n### 4) Unicode / Width Prove‑Out Strings (pool-rendered)\n\nThese strings must be rendered using the grapheme pool path (`buffer_with_pool` + `draw_text_with_pool` / `render_to_with_pool`) so correctness is visible.\n\nInclude at least:\n\n- CJK wide chars: `漢字かなカナ`\n- single-codepoint emoji: `🎉👍😀`\n- multi-codepoint ZWJ emoji: `👨‍👩‍👧` / `👩‍💻` / `🧑‍🚀`\n- combining marks: `a\\u{0301}` (á) and `n\\u{0303}` (ñ)\n\nAlso include a fixed “width ruler” line under each string so a viewer can see alignment and width decisions.\n\n### 5) Hyperlink URLs (OSC 8)\n\nUse stable URLs that are obviously legitimate:\n\n- `https://github.com/anomalyco/opentui`\n- `https://github.com/anomalyco/opentui/tree/main/src`\n- `https://unicode.org/reports/tr11/`\n\nThe exact URLs are less important than:\n\n- they’re real\n- they’re visually recognizable\n- at least one is rendered in a log row and in a “docs”/help context\n\n## Why This Matters\n\nA demo’s credibility lives or dies on its content. If the strings are artificial or the logs look fake, the viewer won’t trust the engine.","acceptance_criteria":"Checklist:\n- [ ] Provide realistic sample Rust code (highlights look great)\n- [ ] Provide deterministic synthetic log stream\n- [ ] Provide deterministic metric generators for charts\n- [ ] Provide unicode strings that prove width + grapheme pool\n- [ ] Provide a few real URLs for OSC 8 hyperlink demo","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:07:05.501955219Z","created_by":"ubuntu","updated_at":"2026-01-27T22:22:45.039431122Z","compaction_level":0,"original_size":0,"labels":["content","demo_showcase","design"],"dependencies":[{"issue_id":"bd-1ei","depends_on_id":"bd-2jc","type":"parent-child","created_at":"2026-01-27T22:07:05.532952574Z","created_by":"ubuntu"},{"issue_id":"bd-1ei","depends_on_id":"bd-2mu","type":"blocks","created_at":"2026-01-27T22:08:00.588621535Z","created_by":"ubuntu"}]}
{"id":"bd-1fu","title":"demo_showcase UI: sidebar nav (scrollable list + scissor + mouse selection)","description":"# demo_showcase UI — Sidebar Navigation\n\n## Purpose\n\nImplement a scrollable sidebar that proves:\n\n- nested scissor clipping\n- scroll offsets\n- mouse wheel scrolling\n- click hit testing per row\n\n## Content\n\nSidebar items (example):\n\n- Overview\n- Editor\n- Preview\n- Logs\n- Unicode\n- Performance\n- Settings\n\n## Behavior\n\n- Up/Down selects item (when focused)\n- Mouse wheel scrolls list (when hovered)\n- Click selects item and focuses sidebar\n\n## Rendering\n\n- Panel border (focused highlights)\n- Header “NAV”\n- Scrollbar indicator\n- Selected row uses selection background (alpha overlay)\n\n## HitGrid\n\n- Register a hit area per visible row.\n- ID encoding scheme: `HIT_SIDEBAR_BASE + row_index`.","acceptance_criteria":"Checklist:\n- [ ] Sidebar list renders and scrolls inside clip rect\n- [ ] Selected row is styled clearly\n- [ ] Mouse wheel scroll works\n- [ ] Click selects row via HitGrid\n- [ ] Keyboard navigation works when focused","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:13:19.214890317Z","created_by":"ubuntu","updated_at":"2026-01-27T22:33:25.354721082Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","ui"],"dependencies":[{"issue_id":"bd-1fu","depends_on_id":"bd-1pd","type":"blocks","created_at":"2026-01-27T22:31:51.731520632Z","created_by":"ubuntu"},{"issue_id":"bd-1fu","depends_on_id":"bd-35g","type":"blocks","created_at":"2026-01-27T22:31:52.274517829Z","created_by":"ubuntu"},{"issue_id":"bd-1fu","depends_on_id":"bd-3ii","type":"blocks","created_at":"2026-01-27T22:31:52.841934125Z","created_by":"ubuntu"},{"issue_id":"bd-1fu","depends_on_id":"bd-c75","type":"parent-child","created_at":"2026-01-27T22:13:19.248313963Z","created_by":"ubuntu"},{"issue_id":"bd-1fu","depends_on_id":"bd-hc0","type":"blocks","created_at":"2026-01-27T22:33:21.185238691Z","created_by":"ubuntu"},{"issue_id":"bd-1fu","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:33:25.354690846Z","created_by":"ubuntu"}]}
{"id":"bd-1gp","title":"Add clear_history() method to EditBuffer","description":"Spec section 8.5 requires clearHistory() method. Currently history is cleared via set_text() but no standalone method exists. Add EditBuffer::clear_history() that delegates to history.clear().","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-27T18:14:31.817034545Z","created_by":"ubuntu","updated_at":"2026-01-27T18:20:02.288153430Z","closed_at":"2026-01-27T18:20:02.288090753Z","close_reason":"Added clear_history() method to EditBuffer at src/text/edit.rs:159-165","compaction_level":0,"original_size":0}
{"id":"bd-1gy","title":"demo_showcase spec: deterministic tour script (auto-demo steps)","description":"# demo_showcase Spec — Deterministic Tour Script\n\n## Why Tour Mode Exists\n\nThe showcase must be *demoable without a human driver*.\n\nTour mode provides:\n\n- a deterministic sequence for recording videos\n- a “guided explanation” overlay for first-time users\n- an automatic prove-out of advanced features\n\n## Tour Model\n\n- Tour is a sequence of steps: `Step { title, description, duration_ms, action }`\n- Each step can:\n  - mutate app state (select panel, scroll, open overlay, type text)\n  - trigger an animation or highlight effect\n  - pop a toast describing what’s happening\n- Determinism:\n  - fixed durations\n  - seeded animation parameters (no randomness; if “random”, derive from step index)\n\n## Proposed Steps (Feature-Proving Sequence)\n\n1. **Welcome + No Flicker**\n   - Show title + smooth animated accent bar.\n   - Toast: “Diff rendering + synchronized output (if supported).”\n\n2. **Scissor-Clipped Sidebar Scroll**\n   - Auto-scroll sidebar list inside clip rect.\n   - Visual: scroll indicator.\n\n3. **Focus + Hit Testing**\n   - Simulate “clicking” top bar buttons (help/palette) and switching panel focus.\n   - Visual: border glow moves.\n\n4. **Command Palette (Glass Overlay)**\n   - Open palette overlay.\n   - Demonstrate opacity stack + blended background.\n\n5. **Editor: Typing + Undo/Redo**\n   - Insert a few lines.\n   - Undo/redo quickly.\n   - Toast: “Rope + undo groups.”\n\n6. **Editor: Highlighting + Theme Switch**\n   - Turn on syntax highlighting.\n   - Switch theme (Dark → Light → High contrast).\n\n7. **Bracketed Paste Proof**\n   - Inject a synthetic Paste event into editor.\n   - Toast: “Bracketed paste parsed and inserted.”\n\n8. **Unicode + Width + Grapheme Pool**\n   - Render a line containing:\n     - CJK wide chars\n     - single-codepoint emoji\n     - multi-codepoint ZWJ emoji (must require pool)\n   - Show a small “width ruler” under it.\n\n9. **Preview: PixelBuffer + Supersampling**\n   - Animate a small pixel-art + sparkline chart.\n\n10. **Alpha Blending / Opacity**\n   - Draw a translucent “modal” over preview with a drop-shadow-ish effect.\n\n11. **Hyperlinks (OSC 8)**\n   - Render clickable links (docs/GitHub) in the logs panel.\n   - Visual: link styling + hover/pressed feedback.\n\n12. **Finale: Performance Overlay**\n   - Show render stats (fps, changed cells, bytes estimate).\n   - End with a “you can build this” message.\n\n## User Controls\n\n- Start/stop: `Ctrl+T`\n- Next: `Enter` / `Space`\n- Prev: `Backspace`\n- Exit tour: `Esc`\n\nUnattended runs:\n\n- When started with `--exit-after-tour`, the final tour step completion triggers a clean process exit (useful for recordings and PTY E2E).\n\n## Acceptance Style\n\nTour steps should include micro-copy that explains *why* each feature matters.","acceptance_criteria":"Checklist:\n- [ ] Step list covers all advanced features (no gaps)\n- [ ] Each step has a deterministic duration + action\n- [ ] Tour can run unattended start-to-finish\n- [ ] Tour UI explains what’s being demonstrated","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:06:37.649964906Z","created_by":"ubuntu","updated_at":"2026-01-27T23:13:45.823817738Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","design","tour"],"dependencies":[{"issue_id":"bd-1gy","depends_on_id":"bd-1ei","type":"blocks","created_at":"2026-01-27T22:08:07.758580540Z","created_by":"ubuntu"},{"issue_id":"bd-1gy","depends_on_id":"bd-1ok","type":"blocks","created_at":"2026-01-27T22:08:09.880209710Z","created_by":"ubuntu"},{"issue_id":"bd-1gy","depends_on_id":"bd-2jc","type":"parent-child","created_at":"2026-01-27T22:06:37.672251398Z","created_by":"ubuntu"},{"issue_id":"bd-1gy","depends_on_id":"bd-2mu","type":"blocks","created_at":"2026-01-27T22:08:03.007134873Z","created_by":"ubuntu"},{"issue_id":"bd-1gy","depends_on_id":"bd-3l0","type":"blocks","created_at":"2026-01-27T22:08:05.596193414Z","created_by":"ubuntu"}]}
{"id":"bd-1hd","title":"Integration Example","description":"## Overview\nCreate a working example demonstrating the full rendering loop with input handling.\n\n## Scope\nSimple text editor example showing:\n- Terminal setup/cleanup\n- Input event loop\n- Rendering pipeline\n- Proper error handling\n- Debug logging capability\n\n## Implementation\n```rust\n// examples/simple_editor.rs\nuse opentui::prelude::*;\nuse std::io::{stdin, stdout, Read, Write};\nuse std::env;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Check for debug mode\n    let debug = env::var(\"OPENTUI_DEBUG\").is_ok();\n    \n    // Setup logging\n    if debug {\n        eprintln!(\"[DEBUG] OpenTUI Simple Editor starting\");\n    }\n    \n    // Get terminal size\n    let (width, height) = terminal_size()?;\n    if debug {\n        eprintln!(\"[DEBUG] Terminal size: {}x{}\", width, height);\n    }\n    \n    // Setup\n    let _guard = enable_raw_mode()?;\n    let mut renderer = Renderer::new(width as u32, height as u32)?;\n    let mut buffer = EditBuffer::with_text(\"Hello, OpenTUI!\\n\\nPress Ctrl+Q to quit.\");\n    let mut view = EditorView::new(buffer);\n    view.set_line_numbers(true);\n    view.set_wrap_mode(WrapMode::Word);\n    \n    if debug {\n        eprintln!(\"[DEBUG] Editor initialized\");\n    }\n    \n    // Event loop\n    let mut parser = InputParser::new();\n    let mut input_buf = [0u8; 64];\n    let mut frame_count = 0u64;\n\n    loop {\n        frame_count += 1;\n        \n        // Render\n        renderer.clear();\n        view.render_to(renderer.buffer_mut(), 0, 0, width as u32, height as u32);\n        renderer.present(&mut stdout())?;\n        \n        if debug && frame_count % 60 == 0 {\n            let cursor = view.edit_buffer().cursor();\n            eprintln!(\"[DEBUG] Frame {} - cursor: row={} col={} offset={}\",\n                frame_count, cursor.row, cursor.col, cursor.offset);\n        }\n\n        // Handle input\n        let n = stdin().read(&mut input_buf)?;\n        \n        if debug {\n            eprintln!(\"[DEBUG] Input: {} bytes, hex: {}\",\n                n, input_buf[..n].iter().map(|b| format!(\"{:02x}\", b)).collect::<Vec<_>>().join(\" \"));\n        }\n\n        for event in parser.parse(&input_buf[..n]) {\n            if debug {\n                eprintln!(\"[DEBUG] Event: {:?}\", event);\n            }\n            \n            match event {\n                InputEvent::Key(KeyEvent { code: KeyCode::Char('q'), modifiers })\n                    if modifiers.contains(Modifiers::CTRL) => {\n                    if debug {\n                        eprintln!(\"[DEBUG] Ctrl+Q detected, exiting\");\n                    }\n                    return Ok(());\n                }\n                InputEvent::Key(key) => {\n                    view.handle_key(key);\n                    view.scroll_to_cursor(width as u32, height as u32);\n                }\n                InputEvent::Mouse(mouse) => {\n                    view.handle_mouse(mouse);\n                }\n                InputEvent::Resize { width: w, height: h } => {\n                    if debug {\n                        eprintln!(\"[DEBUG] Resize to {}x{}\", w, h);\n                    }\n                    renderer.resize(w as u32, h as u32);\n                    view.set_viewport(0, 0, w as u32, h as u32);\n                }\n                _ => {}\n            }\n        }\n    }\n}\n```\n\n## Files to Create\n- examples/simple_editor.rs - basic editor example (~100 lines)\n- examples/README.md - example documentation\n\n### README.md Content\n```markdown\n# OpenTUI Examples\n\n## Simple Editor\n\nA minimal text editor demonstrating the OpenTUI rendering loop.\n\n### Running\n\n```bash\ncargo run --example simple_editor\n```\n\n### Debug Mode\n\nEnable verbose logging:\n\n```bash\nOPENTUI_DEBUG=1 cargo run --example simple_editor 2>debug.log\n```\n\n### Controls\n\n- Arrow keys: Move cursor\n- Ctrl+Q: Quit\n- Ctrl+S: Save (if implemented)\n- Page Up/Down: Scroll\n- Home/End: Line start/end\n\n### What This Demonstrates\n\n1. **Terminal Setup**: Raw mode, alternate screen\n2. **Input Handling**: Parsing ANSI sequences into events\n3. **Rendering Loop**: Double-buffered, diff-based updates\n4. **Resource Cleanup**: RAII guard restores terminal state\n```\n\n## Testing Requirements\n\n### Manual Test Checklist (with logging verification)\nRun with OPENTUI_DEBUG=1 and verify:\n- [ ] Terminal size logged on startup\n- [ ] Input bytes logged for each keypress\n- [ ] Events logged (Key, Mouse, Resize)\n- [ ] Cursor position logged periodically\n- [ ] Ctrl+Q exit logged\n- [ ] No panic on resize\n- [ ] Terminal restored on exit (even after panic)\n\n### Automated Smoke Test (tests/e2e/example_smoke.rs)\n```rust\n#[test]\nfn test_example_compiles() {\n    // Just verify the example compiles\n    use std::process::Command;\n    \n    let output = Command::new(\"cargo\")\n        .args([\"build\", \"--example\", \"simple_editor\"])\n        .output()\n        .expect(\"Failed to run cargo\");\n    \n    eprintln!(\"[TEST] Build stdout: {}\", String::from_utf8_lossy(&output.stdout));\n    eprintln!(\"[TEST] Build stderr: {}\", String::from_utf8_lossy(&output.stderr));\n    \n    assert!(output.status.success(), \"Example should compile\");\n    \n    eprintln!(\"[TEST] PASS: Example compiles successfully\");\n}\n```\n\n## Acceptance Criteria\n- [ ] Example compiles and runs\n- [ ] Demonstrates full input/output loop\n- [ ] Handles Ctrl+Q to quit\n- [ ] Properly cleans up terminal on exit\n- [ ] Debug mode available via OPENTUI_DEBUG env var\n- [ ] Debug logs show input bytes, events, and cursor state\n- [ ] README explains how to run and debug\n- [ ] No panic on common terminal operations\n\nDependencies:\n  -> bd-219 (blocks) - ANSI Input Sequence Parser\n  -> bd-vde (blocks) - Mouse Input Parser\n  -> bd-25w (blocks) - Event System","acceptance_criteria":"- [ ] Example compiles and runs\n- [ ] Demonstrates full input/output loop\n- [ ] Handles Ctrl+Q to quit\n- [ ] Properly cleans up terminal on exit\n- [ ] README explains how to run","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:26:13.871371306Z","closed_at":"2026-01-19T22:26:13.871281176Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1hd","depends_on_id":"bd-219","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-1hd","depends_on_id":"bd-vde","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1i7","title":"demo_showcase spec: resilience + degradation rules (small terminal, no truecolor, no mouse)","description":"# demo_showcase Spec — Resilience + Degradation Rules\n\n## Goal\n\nThe demo should be impressive in ideal terminals, but also **never embarrassing** in constrained environments.\n\n## Constraints to Handle\n\n- Very small terminal sizes (e.g., 50×15)\n- No truecolor (16/256-color fallback)\n- No mouse reporting (or mouse disabled)\n- No synchronized output support\n- TTY missing (demo should refuse gracefully or run headless mode)\n\n## Layout Degradation\n\n- Below minimum width/height, switch to a “compact layout”:\n  - collapse preview or logs\n  - show a single focused panel full-screen with a minimal top/bottom bar\n- Always keep a visible help hint: “F1 Help / Ctrl+Q Quit”.\n\n## Rendering Degradation\n\n- If colors are limited, keep contrast high:\n  - prefer fewer accent colors\n  - use bold/dim to provide hierarchy\n- Avoid relying on italic/strikethrough.\n\n## Input Degradation\n\n- If mouse is disabled:\n  - ensure keyboard navigation can do everything (Tab cycles focus, Enter activates).\n\n## Failure Modes\n\n- If `terminal_size()` fails or stdout isn’t a TTY:\n  - print a clear message and exit non-zero\n  - or offer `--headless-smoke` that runs deterministic render steps to a buffer and exits 0","acceptance_criteria":"Checklist:\n- [ ] Compact layout rules defined\n- [ ] Color fallback rules defined\n- [ ] Mouse-disabled fallback rules defined\n- [ ] Non-TTY behavior defined (clear and safe)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:07:34.249061949Z","created_by":"ubuntu","updated_at":"2026-01-27T22:08:14.327904899Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","design","resilience"],"dependencies":[{"issue_id":"bd-1i7","depends_on_id":"bd-1ok","type":"blocks","created_at":"2026-01-27T22:08:14.327880173Z","created_by":"ubuntu"},{"issue_id":"bd-1i7","depends_on_id":"bd-2jc","type":"parent-child","created_at":"2026-01-27T22:07:34.268002141Z","created_by":"ubuntu"},{"issue_id":"bd-1i7","depends_on_id":"bd-2mu","type":"blocks","created_at":"2026-01-27T22:08:11.950905059Z","created_by":"ubuntu"}]}
{"id":"bd-1j0","title":"[EPIC] Comprehensive Benchmark Suite","description":"# Epic: Comprehensive Benchmark Suite\n\n## Background & Motivation\n\nOpenTUI claims to be a \"high-performance terminal UI rendering engine.\" This claim must be backed by rigorous benchmarks. Currently, the project has only a single `buffer.rs` benchmark file with basic operations. We need:\n\n1. **Performance baselines** - Know current performance for regression detection\n2. **Optimization guidance** - Identify bottlenecks and hot paths\n3. **Comparative data** - How does OpenTUI compare to alternatives?\n4. **Documentation** - Performance characteristics for users making decisions\n\n## Current State\n\nThe existing `benches/buffer.rs` covers:\n- `buffer_clear` - Clearing the entire buffer\n- `buffer_draw_text` - Drawing text strings\n- `buffer_blend` - Alpha blending operations\n\nThis is a good start but doesn't cover many critical operations.\n\n## Goals\n\n1. Benchmark all major subsystems (buffer, text, renderer, color, unicode)\n2. Establish performance baselines for CI regression detection\n3. Provide realistic workload benchmarks (not just micro-benchmarks)\n4. Document expected performance characteristics\n\n## Benchmark Categories\n\n### 1. Buffer Operations (expand existing)\n- Clear operations at various sizes\n- Cell set/get operations\n- fill_rect at various sizes\n- draw_text with different string lengths\n- draw_box with various box styles\n- Scissor stack operations\n- Opacity stack operations\n\n### 2. Color Operations\n- Rgba creation methods\n- Porter-Duff blending\n- Color conversions (HSV, hex, u8)\n- Lerp operations\n\n### 3. Text/Rope Operations\n- TextBuffer creation and population\n- Rope insertions (beginning, middle, end)\n- Rope deletions\n- Line iteration\n- EditBuffer operations with undo/redo\n\n### 4. Renderer Operations\n- Buffer diff calculation\n- ANSI sequence generation\n- Full render cycle\n\n### 5. Unicode Operations\n- Grapheme iteration\n- Display width calculation\n- Mixed ASCII/emoji/CJK text\n\n### 6. Input Parsing\n- Key event parsing\n- Mouse event parsing\n- Escape sequence parsing\n\n### 7. Realistic Workloads\n- \"Editor frame\" - Scroll + render 1000 lines\n- \"Animation frame\" - Update 100 moving elements\n- \"Dashboard refresh\" - Update 5 panels with data\n\n## Design Principles\n\n- **Criterion framework** - Already in use, provides statistical analysis\n- **Realistic sizes** - Test at 80x24, 120x40, 200x60 terminal sizes\n- **Parameterized benchmarks** - Same test at multiple scales\n- **Comparison groups** - Group related benchmarks for comparison\n\n## Success Criteria\n\n- [ ] All major subsystems have benchmarks\n- [ ] CI runs benchmarks on main branch\n- [ ] Performance regression >10% triggers alert\n- [ ] Benchmark results documented\n- [ ] Realistic workload benchmarks included\n\n## Non-Goals\n\n- Comparison with other TUI libraries (complex, politically sensitive)\n- Optimization work (that's separate tasks based on benchmark findings)\n- Platform-specific benchmarks\n\n## Dependencies\n\nNone - benchmarks can be written against existing code.\n\n## Estimated Scope\n\n~1000-1500 LOC across benchmark files.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:13:11.909043295Z","created_by":"ubuntu","updated_at":"2026-01-25T17:54:45.216276374Z","closed_at":"2026-01-25T17:54:45.216209799Z","close_reason":"done","compaction_level":0,"original_size":0,"labels":["benchmark","epic"]}
{"id":"bd-1j0.1","title":"Benchmark: Expand buffer operation coverage","description":"# Benchmark: Expand Buffer Operation Coverage\n\n## Context\n\nThe existing `benches/buffer.rs` has only 3 benchmarks. Buffer operations are the core of OpenTUI's rendering, so comprehensive benchmarks are essential.\n\n## Benchmarks to Add\n\n### Cell Operations\n```rust\nfn bench_cell_set(c: &mut Criterion) {\n    let mut buffer = OptimizedBuffer::new(80, 24);\n    let cell = Cell::new('X', Style::default());\n    \n    c.bench_function(\"cell_set_80x24\", |b| {\n        b.iter(|| {\n            for y in 0..24 {\n                for x in 0..80 {\n                    buffer.set(x, y, cell.clone());\n                }\n            }\n        })\n    });\n}\n\nfn bench_cell_get(c: &mut Criterion) {\n    let buffer = OptimizedBuffer::new(80, 24);\n    \n    c.bench_function(\"cell_get_80x24\", |b| {\n        b.iter(|| {\n            for y in 0..24 {\n                for x in 0..80 {\n                    black_box(buffer.get(x, y));\n                }\n            }\n        })\n    });\n}\n```\n\n### fill_rect Operations\n```rust\nfn bench_fill_rect(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"fill_rect\");\n    \n    for (w, h) in [(10, 5), (40, 20), (80, 24), (200, 60)] {\n        let mut buffer = OptimizedBuffer::new(w, h);\n        group.bench_with_input(\n            BenchmarkId::from_parameter(format!(\"{w}x{h}\")),\n            &(w, h),\n            |b, _| {\n                b.iter(|| buffer.fill_rect(0, 0, w, h, Rgba::BLUE))\n            },\n        );\n    }\n    group.finish();\n}\n```\n\n### Scissor Stack\n```rust\nfn bench_scissor_push_pop(c: &mut Criterion) {\n    let mut buffer = OptimizedBuffer::new(80, 24);\n    \n    c.bench_function(\"scissor_push_pop_10\", |b| {\n        b.iter(|| {\n            for _ in 0..10 {\n                buffer.push_scissor(ClipRect::new(10, 10, 60, 14));\n            }\n            for _ in 0..10 {\n                buffer.pop_scissor();\n            }\n        })\n    });\n}\n\nfn bench_scissor_drawing(c: &mut Criterion) {\n    let mut buffer = OptimizedBuffer::new(80, 24);\n    buffer.push_scissor(ClipRect::new(10, 5, 60, 14));\n    \n    c.bench_function(\"draw_with_scissor\", |b| {\n        b.iter(|| {\n            buffer.draw_text(0, 10, \"This text is clipped by scissor\", Style::default())\n        })\n    });\n}\n```\n\n### Box Drawing\n```rust\nfn bench_draw_box(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"draw_box\");\n    let mut buffer = OptimizedBuffer::new(80, 24);\n    \n    for style_name in [\"single\", \"double\", \"rounded\", \"heavy\"] {\n        let box_style = match style_name {\n            \"single\" => BoxStyle::single(),\n            \"double\" => BoxStyle::double(),\n            \"rounded\" => BoxStyle::rounded(),\n            \"heavy\" => BoxStyle::heavy(),\n            _ => unreachable!(),\n        };\n        \n        group.bench_function(style_name, |b| {\n            b.iter(|| buffer.draw_box(5, 5, 70, 14, box_style))\n        });\n    }\n    group.finish();\n}\n```\n\n### Blending Operations\n```rust\nfn bench_set_blended(c: &mut Criterion) {\n    let mut buffer = OptimizedBuffer::new(80, 24);\n    buffer.set_respect_alpha(true);\n    let cell = Cell::new('█', Style::fg(Rgba::RED.with_alpha(0.5)));\n    \n    c.bench_function(\"set_blended_80x24\", |b| {\n        b.iter(|| {\n            for y in 0..24 {\n                for x in 0..80 {\n                    buffer.set_blended(x, y, cell.clone());\n                }\n            }\n        })\n    });\n}\n```\n\n## Parameterized Size Benchmarks\n\nTest key operations at multiple terminal sizes:\n- Small: 80x24 (standard terminal)\n- Medium: 120x40 (larger window)\n- Large: 200x60 (full-screen IDE terminal)\n\n## File to Modify\n\n- `benches/buffer.rs`\n\n## Acceptance Criteria\n\n- [ ] Cell set/get benchmarks added\n- [ ] fill_rect at multiple sizes\n- [ ] Scissor operations benchmarked\n- [ ] Box drawing benchmarked\n- [ ] Blending operations benchmarked\n- [ ] All benchmarks run successfully\n- [ ] Results documented in comments","notes":"## Testing Requirements\n\nPer bd-1j0.7 (Benchmark Validation and Regression Testing):\n- All benchmarks must compile: `cargo build --benches`\n- Run quick validation: `cargo bench -- --test`\n- Generate baseline: `./scripts/benchmark_baseline.sh`\n- Check for regressions on each commit\n\n## Performance Expectations\n\nDocument expected performance ranges in benchmark comments:\n- cell_set_80x24: <100μs\n- fill_rect_80x24: <50μs\n- draw_box: <20μs\n\nFlag any results significantly outside these ranges.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:13:38.693333026Z","created_by":"ubuntu","updated_at":"2026-01-25T11:42:52.347233733Z","closed_at":"2026-01-25T11:42:52.347213695Z","close_reason":"Expanded buffer benchmarks (cell set/get, fill_rect sizes, scissor, box, blended)","compaction_level":0,"original_size":0,"labels":["benchmark"],"dependencies":[{"issue_id":"bd-1j0.1","depends_on_id":"bd-1j0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1j0.2","title":"Benchmark: Color operations","description":"# Benchmark: Color Operations\n\n## Context\n\nColor operations are used constantly during rendering. The Rgba type includes blending, conversion, and manipulation methods that need to be fast.\n\n## Benchmarks to Add\n\n### Color Creation\n```rust\nfn bench_color_creation(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"color_creation\");\n    \n    group.bench_function(\"new_f32\", |b| {\n        b.iter(|| Rgba::new(0.5, 0.7, 0.3, 1.0))\n    });\n    \n    group.bench_function(\"from_rgb_u8\", |b| {\n        b.iter(|| Rgba::from_rgb_u8(128, 179, 77))\n    });\n    \n    group.bench_function(\"from_hex\", |b| {\n        b.iter(|| Rgba::from_hex(\"#80B34D\"))\n    });\n    \n    group.bench_function(\"from_hsv\", |b| {\n        b.iter(|| Rgba::from_hsv(90.0, 0.57, 0.70))\n    });\n    \n    group.finish();\n}\n```\n\n### Porter-Duff Blending\n```rust\nfn bench_blend_over(c: &mut Criterion) {\n    let src = Rgba::new(1.0, 0.0, 0.0, 0.5);  // 50% red\n    let dst = Rgba::new(0.0, 0.0, 1.0, 1.0);  // opaque blue\n    \n    c.bench_function(\"blend_over_single\", |b| {\n        b.iter(|| black_box(src).blend_over(black_box(dst)))\n    });\n}\n\nfn bench_blend_over_batch(c: &mut Criterion) {\n    let src = Rgba::new(1.0, 0.0, 0.0, 0.5);\n    let dst = Rgba::new(0.0, 0.0, 1.0, 1.0);\n    \n    c.bench_function(\"blend_over_1000\", |b| {\n        b.iter(|| {\n            let mut result = dst;\n            for _ in 0..1000 {\n                result = src.blend_over(result);\n            }\n            result\n        })\n    });\n}\n```\n\n### Color Conversion\n```rust\nfn bench_color_conversion(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"color_conversion\");\n    let color = Rgba::new(0.5, 0.7, 0.3, 1.0);\n    \n    group.bench_function(\"to_rgb_u8\", |b| {\n        b.iter(|| black_box(color).to_rgb_u8())\n    });\n    \n    group.bench_function(\"to_hex\", |b| {\n        b.iter(|| black_box(color).to_hex())\n    });\n    \n    group.bench_function(\"to_hsv\", |b| {\n        b.iter(|| black_box(color).to_hsv())\n    });\n    \n    group.finish();\n}\n```\n\n### Color Manipulation\n```rust\nfn bench_color_manipulation(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"color_manipulation\");\n    let color1 = Rgba::RED;\n    let color2 = Rgba::BLUE;\n    \n    group.bench_function(\"with_alpha\", |b| {\n        b.iter(|| black_box(color1).with_alpha(0.5))\n    });\n    \n    group.bench_function(\"multiply_alpha\", |b| {\n        b.iter(|| black_box(color1).multiply_alpha(0.5))\n    });\n    \n    group.bench_function(\"lerp\", |b| {\n        b.iter(|| black_box(color1).lerp(black_box(color2), 0.5))\n    });\n    \n    group.finish();\n}\n```\n\n### Gradient Generation\n```rust\nfn bench_gradient(c: &mut Criterion) {\n    let start = Rgba::RED;\n    let end = Rgba::BLUE;\n    \n    c.bench_function(\"gradient_256_steps\", |b| {\n        b.iter(|| {\n            for i in 0..256 {\n                let t = i as f32 / 255.0;\n                black_box(start.lerp(end, t));\n            }\n        })\n    });\n}\n```\n\n## File to Create\n\n- `benches/color.rs`\n\n## Cargo.toml Addition\n\n```toml\n[[bench]]\nname = \"color\"\nharness = false\n```\n\n## Acceptance Criteria\n\n- [ ] All color creation methods benchmarked\n- [ ] Porter-Duff blending benchmarked\n- [ ] Conversion methods benchmarked\n- [ ] Manipulation methods benchmarked\n- [ ] Results show <100ns for simple operations","notes":"## AGENTS.md Alignment\n\nPer AGENTS.md Performance Requirements:\n- **Blending is hot path** - Must have no branching on happy path\n- **Zero allocation** - All color ops should be allocation-free\n\n## Expected Performance Targets\n\n| Operation | Target | Notes |\n|-----------|--------|-------|\n| new_f32 | <5ns | Just struct init |\n| from_hex | <50ns | String parsing overhead |\n| blend_over | <10ns | Critical hot path |\n| lerp | <10ns | Used in gradients |\n| to_rgb_u8 | <5ns | Just f32 to u8 conversion |\n\n## Coverage Requirement\n\nAGENTS.md requires src/color.rs ≥90% coverage. These benchmarks indirectly test correctness - ensure unit tests exist for all benchmarked operations.\n\n## CI Integration\n\nPer bd-1j0.7, >10% regression in color ops should trigger warning since blending is critical path for every render.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T01:13:56.933419818Z","created_by":"ubuntu","updated_at":"2026-01-25T17:19:51.789290626Z","closed_at":"2026-01-25T17:19:51.789153858Z","close_reason":"done","compaction_level":0,"original_size":0,"labels":["benchmark"],"dependencies":[{"issue_id":"bd-1j0.2","depends_on_id":"bd-1j0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1j0.3","title":"Benchmark: Text/Rope operations","description":"# Benchmark: Text/Rope Operations\n\n## Context\n\nText operations are critical for editor applications. The rope-based TextBuffer and EditBuffer need to perform well for:\n- Large documents (10K+ lines)\n- Frequent insertions (typing)\n- Cursor movement\n- Undo/redo operations\n\n## Benchmarks to Add\n\n### Rope Basic Operations\n```rust\nfn bench_rope_insert(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"rope_insert\");\n    \n    // Insert at beginning\n    group.bench_function(\"insert_beginning\", |b| {\n        let mut buffer = TextBuffer::with_text(&\"x\".repeat(10000));\n        b.iter(|| {\n            buffer.insert(0, \"abc\");\n        })\n    });\n    \n    // Insert at middle\n    group.bench_function(\"insert_middle\", |b| {\n        let mut buffer = TextBuffer::with_text(&\"x\".repeat(10000));\n        b.iter(|| {\n            buffer.insert(5000, \"abc\");\n        })\n    });\n    \n    // Insert at end\n    group.bench_function(\"insert_end\", |b| {\n        let mut buffer = TextBuffer::with_text(&\"x\".repeat(10000));\n        b.iter(|| {\n            buffer.insert(10000, \"abc\");\n        })\n    });\n    \n    group.finish();\n}\n\nfn bench_rope_delete(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"rope_delete\");\n    \n    group.bench_function(\"delete_beginning_10\", |b| {\n        let text = \"x\".repeat(10000);\n        b.iter_batched(\n            || TextBuffer::with_text(&text),\n            |mut buffer| buffer.delete(0..10),\n            BatchSize::SmallInput,\n        )\n    });\n    \n    group.bench_function(\"delete_middle_10\", |b| {\n        let text = \"x\".repeat(10000);\n        b.iter_batched(\n            || TextBuffer::with_text(&text),\n            |mut buffer| buffer.delete(5000..5010),\n            BatchSize::SmallInput,\n        )\n    });\n    \n    group.finish();\n}\n```\n\n### Line Operations\n```rust\nfn bench_line_iteration(c: &mut Criterion) {\n    let text = (0..1000).map(|i| format!(\"Line {i}\\n\")).collect::<String>();\n    let buffer = TextBuffer::with_text(&text);\n    \n    c.bench_function(\"iterate_1000_lines\", |b| {\n        b.iter(|| {\n            for line in buffer.lines() {\n                black_box(line);\n            }\n        })\n    });\n}\n\nfn bench_line_access(c: &mut Criterion) {\n    let text = (0..1000).map(|i| format!(\"Line {i}\\n\")).collect::<String>();\n    let buffer = TextBuffer::with_text(&text);\n    \n    c.bench_function(\"random_line_access_100\", |b| {\n        b.iter(|| {\n            for i in [0, 500, 999, 250, 750, 100, 900, 50, 950, 333] {\n                black_box(buffer.line(i));\n            }\n        })\n    });\n}\n```\n\n### EditBuffer Operations\n```rust\nfn bench_editbuffer_typing(c: &mut Criterion) {\n    // Simulate typing a sentence\n    let sentence = \"The quick brown fox jumps over the lazy dog. \";\n    \n    c.bench_function(\"type_sentence\", |b| {\n        b.iter_batched(\n            || EditBuffer::new(),\n            |mut eb| {\n                for ch in sentence.chars() {\n                    eb.insert(&ch.to_string());\n                }\n            },\n            BatchSize::SmallInput,\n        )\n    });\n}\n\nfn bench_editbuffer_undo_redo(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"undo_redo\");\n    \n    group.bench_function(\"undo_10_operations\", |b| {\n        b.iter_batched(\n            || {\n                let mut eb = EditBuffer::new();\n                for i in 0..10 {\n                    eb.insert(&format!(\"text{i}\"));\n                    eb.commit();\n                }\n                eb\n            },\n            |mut eb| {\n                for _ in 0..10 {\n                    eb.undo();\n                }\n            },\n            BatchSize::SmallInput,\n        )\n    });\n    \n    group.bench_function(\"redo_10_operations\", |b| {\n        b.iter_batched(\n            || {\n                let mut eb = EditBuffer::new();\n                for i in 0..10 {\n                    eb.insert(&format!(\"text{i}\"));\n                    eb.commit();\n                }\n                for _ in 0..10 {\n                    eb.undo();\n                }\n                eb\n            },\n            |mut eb| {\n                for _ in 0..10 {\n                    eb.redo();\n                }\n            },\n            BatchSize::SmallInput,\n        )\n    });\n    \n    group.finish();\n}\n```\n\n### Cursor Movement\n```rust\nfn bench_cursor_movement(c: &mut Criterion) {\n    let text = (0..100).map(|i| format!(\"Line {i} with some content\\n\")).collect::<String>();\n    let mut eb = EditBuffer::with_text(&text);\n    \n    let mut group = c.benchmark_group(\"cursor_movement\");\n    \n    group.bench_function(\"move_right_1000\", |b| {\n        b.iter(|| {\n            eb.goto_line(0);\n            for _ in 0..1000 {\n                eb.move_right();\n            }\n        })\n    });\n    \n    group.bench_function(\"move_down_100\", |b| {\n        b.iter(|| {\n            eb.goto_line(0);\n            for _ in 0..100 {\n                eb.move_down();\n            }\n        })\n    });\n    \n    group.finish();\n}\n```\n\n## File to Create\n\n- `benches/text.rs`\n\n## Cargo.toml Addition\n\n```toml\n[[bench]]\nname = \"text\"\nharness = false\n```\n\n## Acceptance Criteria\n\n- [ ] Rope insert/delete at various positions\n- [ ] Line iteration and access\n- [ ] EditBuffer typing simulation\n- [ ] Undo/redo performance\n- [ ] Cursor movement benchmarks\n- [ ] Large document (10K lines) handling","notes":"AGENTS.md alignment: Rope operations are hot path for editor use cases. Benchmark baseline targets: insert <10μs, delete <10μs, line access O(log n). Use tracing (info!, debug!) in test setup for debugging.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:14:20.605605616Z","created_by":"ubuntu","updated_at":"2026-01-25T11:45:43.031856767Z","closed_at":"2026-01-25T11:45:43.031836238Z","close_reason":"Expanded text/rope benchmarks (rope insert/delete, line iter/access, typing, cursor move, undo/redo)","compaction_level":0,"original_size":0,"labels":["benchmark"],"dependencies":[{"issue_id":"bd-1j0.3","depends_on_id":"bd-1j0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1j0.4","title":"Benchmark: Renderer and diff operations","description":"# Benchmark: Renderer and Diff Operations\n\n## Context\n\nThe renderer's diff-based update system is a core performance feature. Benchmarking ensures:\n- Diff calculation is fast\n- Full redraws are efficient when needed\n- ANSI generation doesn't bottleneck\n\n## Benchmarks to Add\n\n### Buffer Diff Calculation\n```rust\nfn bench_diff_calculation(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"diff_calculation\");\n    \n    // No changes\n    group.bench_function(\"diff_no_changes_80x24\", |b| {\n        let old = OptimizedBuffer::new(80, 24);\n        let new = old.clone();\n        \n        b.iter(|| BufferDiff::compute(&old, &new))\n    });\n    \n    // Single cell change\n    group.bench_function(\"diff_single_change_80x24\", |b| {\n        let old = OptimizedBuffer::new(80, 24);\n        let mut new = old.clone();\n        new.set(40, 12, Cell::new('X', Style::default()));\n        \n        b.iter(|| BufferDiff::compute(&old, &new))\n    });\n    \n    // 10% changes (scattered)\n    group.bench_function(\"diff_10pct_changes_80x24\", |b| {\n        let old = OptimizedBuffer::new(80, 24);\n        let mut new = old.clone();\n        for i in 0..(80 * 24 / 10) {\n            let x = (i * 7) % 80;\n            let y = (i * 13) % 24;\n            new.set(x as u32, y as u32, Cell::new('X', Style::default()));\n        }\n        \n        b.iter(|| BufferDiff::compute(&old, &new))\n    });\n    \n    // 100% changes (full redraw)\n    group.bench_function(\"diff_100pct_changes_80x24\", |b| {\n        let old = OptimizedBuffer::new(80, 24);\n        let mut new = OptimizedBuffer::new(80, 24);\n        new.clear(Rgba::BLUE);  // Different from default\n        \n        b.iter(|| BufferDiff::compute(&old, &new))\n    });\n    \n    group.finish();\n}\n```\n\n### Diff at Various Sizes\n```rust\nfn bench_diff_sizes(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"diff_sizes\");\n    \n    for (w, h) in [(80, 24), (120, 40), (200, 60)] {\n        let old = OptimizedBuffer::new(w, h);\n        let mut new = old.clone();\n        // 5% random changes\n        for i in 0..(w * h / 20) as usize {\n            let x = ((i * 7) % w as usize) as u32;\n            let y = ((i * 13) % h as usize) as u32;\n            new.set(x, y, Cell::new('X', Style::default()));\n        }\n        \n        group.bench_function(format!(\"{w}x{h}\"), |b| {\n            b.iter(|| BufferDiff::compute(&old, &new))\n        });\n    }\n    \n    group.finish();\n}\n```\n\n### ANSI Output Generation\n```rust\nfn bench_ansi_generation(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"ansi_generation\");\n    \n    // Simple text\n    group.bench_function(\"ansi_simple_text\", |b| {\n        let mut output = AnsiOutput::new();\n        b.iter(|| {\n            output.clear();\n            output.move_to(10, 5);\n            output.set_fg(Rgba::RED);\n            output.write_str(\"Hello, World!\");\n            output.reset_style();\n            black_box(output.as_bytes());\n        })\n    });\n    \n    // Complex styled text\n    group.bench_function(\"ansi_styled_text\", |b| {\n        let mut output = AnsiOutput::new();\n        b.iter(|| {\n            output.clear();\n            for i in 0..10 {\n                output.move_to(0, i);\n                output.set_fg(Rgba::from_rgb_u8(i as u8 * 25, 100, 200));\n                output.set_bg(Rgba::from_rgb_u8(50, i as u8 * 25, 100));\n                output.set_bold(i % 2 == 0);\n                output.write_str(\"Styled line of text here\");\n            }\n            black_box(output.as_bytes());\n        })\n    });\n    \n    group.finish();\n}\n```\n\n### Full Render Cycle\n```rust\nfn bench_render_cycle(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"render_cycle\");\n    \n    // Note: Can't benchmark actual terminal output, but can benchmark\n    // everything up to that point\n    \n    group.bench_function(\"prepare_frame_80x24\", |b| {\n        let mut front = OptimizedBuffer::new(80, 24);\n        let mut back = OptimizedBuffer::new(80, 24);\n        \n        b.iter(|| {\n            // Simulate drawing\n            back.clear(Rgba::from_rgb_u8(20, 20, 30));\n            back.draw_text(10, 5, \"Hello, World!\", Style::default());\n            back.draw_box(5, 3, 70, 18, BoxStyle::double());\n            \n            // Calculate diff\n            let diff = BufferDiff::compute(&front, &back);\n            \n            // Swap buffers\n            std::mem::swap(&mut front, &mut back);\n            \n            black_box(diff);\n        })\n    });\n    \n    group.finish();\n}\n```\n\n## File to Create\n\n- `benches/renderer.rs`\n\n## Cargo.toml Addition\n\n```toml\n[[bench]]\nname = \"renderer\"\nharness = false\n```\n\n## Acceptance Criteria\n\n- [ ] Diff calculation at various change percentages\n- [ ] Diff at multiple terminal sizes\n- [ ] ANSI output generation\n- [ ] Full render cycle simulation\n- [ ] Results show diff is O(n) where n = changed cells","notes":"AGENTS.md alignment: Diff is O(n) where n=changed cells per AGENTS.md requirements. Renderer hot path must avoid allocations. Benchmark targets: diff <1ms for 80x24, ANSI generation <100μs. Use tracing for logging.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:14:47.077141771Z","created_by":"ubuntu","updated_at":"2026-01-25T17:09:38.724146465Z","closed_at":"2026-01-25T17:09:38.724026199Z","close_reason":"done","compaction_level":0,"original_size":0,"labels":["benchmark"],"dependencies":[{"issue_id":"bd-1j0.4","depends_on_id":"bd-1j0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1j0.5","title":"Benchmark: Unicode operations","description":"# Benchmark: Unicode Operations\n\n## Context\n\nUnicode handling is essential for international text, emoji, and CJK characters. The unicode module's performance affects all text rendering.\n\n## Benchmarks to Add\n\n### Grapheme Iteration\n```rust\nfn bench_grapheme_iteration(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"grapheme_iteration\");\n    \n    // ASCII only\n    let ascii = \"The quick brown fox jumps over the lazy dog. \".repeat(100);\n    group.bench_function(\"ascii_5000_chars\", |b| {\n        b.iter(|| {\n            for grapheme in ascii.graphemes(true) {\n                black_box(grapheme);\n            }\n        })\n    });\n    \n    // Mixed with emoji\n    let emoji_text = \"Hello 👋 World 🌍! How are you? 😊 \".repeat(100);\n    group.bench_function(\"emoji_mixed_3000_chars\", |b| {\n        b.iter(|| {\n            for grapheme in emoji_text.graphemes(true) {\n                black_box(grapheme);\n            }\n        })\n    });\n    \n    // CJK characters\n    let cjk = \"日本語テキスト中文文本한국어텍스트\".repeat(100);\n    group.bench_function(\"cjk_3600_chars\", |b| {\n        b.iter(|| {\n            for grapheme in cjk.graphemes(true) {\n                black_box(grapheme);\n            }\n        })\n    });\n    \n    // Complex emoji (ZWJ sequences)\n    let complex_emoji = \"👨‍👩‍👧‍👦🏳️‍🌈👩‍💻\".repeat(100);\n    group.bench_function(\"complex_emoji_300\", |b| {\n        b.iter(|| {\n            for grapheme in complex_emoji.graphemes(true) {\n                black_box(grapheme);\n            }\n        })\n    });\n    \n    group.finish();\n}\n```\n\n### Display Width Calculation\n```rust\nfn bench_display_width(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"display_width\");\n    \n    // ASCII (all width 1)\n    let ascii = \"Hello, World!\";\n    group.bench_function(\"ascii_string\", |b| {\n        b.iter(|| display_width(black_box(ascii)))\n    });\n    \n    // CJK (width 2 each)\n    let cjk = \"日本語中文한국어\";\n    group.bench_function(\"cjk_string\", |b| {\n        b.iter(|| display_width(black_box(cjk)))\n    });\n    \n    // Mixed content\n    let mixed = \"Hello 日本語 World 中文!\";\n    group.bench_function(\"mixed_string\", |b| {\n        b.iter(|| display_width(black_box(mixed)))\n    });\n    \n    // Long mixed string\n    let long_mixed = \"ASCII 日本語 emoji 👋 more text 中文 end. \".repeat(50);\n    group.bench_function(\"long_mixed_2000_chars\", |b| {\n        b.iter(|| display_width(black_box(&long_mixed)))\n    });\n    \n    group.finish();\n}\n```\n\n### Cell Content Creation\n```rust\nfn bench_cell_content(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"cell_content\");\n    \n    // ASCII char\n    group.bench_function(\"from_char_ascii\", |b| {\n        b.iter(|| CellContent::Char(black_box('A')))\n    });\n    \n    // Simple emoji (might be grapheme)\n    group.bench_function(\"from_grapheme_emoji\", |b| {\n        let emoji = \"👋\";\n        b.iter(|| CellContent::from_grapheme(black_box(emoji)))\n    });\n    \n    // Complex grapheme (ZWJ family)\n    group.bench_function(\"from_grapheme_complex\", |b| {\n        let family = \"👨‍👩‍👧‍👦\";\n        b.iter(|| CellContent::from_grapheme(black_box(family)))\n    });\n    \n    group.finish();\n}\n```\n\n### Text Drawing with Unicode\n```rust\nfn bench_draw_unicode_text(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"draw_unicode_text\");\n    let mut buffer = OptimizedBuffer::new(80, 24);\n    \n    // ASCII\n    group.bench_function(\"draw_ascii_80chars\", |b| {\n        let text = \"x\".repeat(80);\n        b.iter(|| buffer.draw_text(0, 0, &text, Style::default()))\n    });\n    \n    // CJK (40 chars = 80 cells)\n    group.bench_function(\"draw_cjk_40chars\", |b| {\n        let text = \"日\".repeat(40);\n        b.iter(|| buffer.draw_text(0, 0, &text, Style::default()))\n    });\n    \n    // Mixed\n    group.bench_function(\"draw_mixed\", |b| {\n        let text = \"Hello 日本語 World 👋!\";\n        b.iter(|| buffer.draw_text(0, 0, &text, Style::default()))\n    });\n    \n    group.finish();\n}\n```\n\n## File to Create\n\n- `benches/unicode.rs`\n\n## Cargo.toml Addition\n\n```toml\n[[bench]]\nname = \"unicode\"\nharness = false\n```\n\n## Acceptance Criteria\n\n- [ ] Grapheme iteration benchmarked\n- [ ] Display width calculation benchmarked\n- [ ] CJK, emoji, and complex graphemes tested\n- [ ] Text drawing with unicode benchmarked\n- [ ] Results show no major slowdown for non-ASCII","notes":"AGENTS.md alignment: Unicode operations use unicode-width and unicode-segmentation crates. Benchmark targets: grapheme iteration should not significantly slow down ASCII-only paths. Use tracing for test logging.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T01:15:12.363283648Z","created_by":"ubuntu","updated_at":"2026-01-25T17:53:39.373339075Z","closed_at":"2026-01-25T17:53:39.373290594Z","close_reason":"done","compaction_level":0,"original_size":0,"labels":["benchmark"],"dependencies":[{"issue_id":"bd-1j0.5","depends_on_id":"bd-1j0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1j0.6","title":"Benchmark: Realistic application workloads","description":"# Benchmark: Realistic Application Workloads\n\n## Context\n\nMicro-benchmarks are useful but don't tell the full story. Realistic workload benchmarks simulate actual application behavior and help users understand expected performance.\n\n## Benchmarks to Add\n\n### Editor Frame Rendering\n```rust\nfn bench_editor_frame(c: &mut Criterion) {\n    // Simulate rendering a code editor frame\n    // - Draw line numbers\n    // - Draw code lines with basic highlighting\n    // - Draw status bar\n    // - Calculate diff and present\n    \n    let code = include_str!(\"../src/lib.rs\");  // Real code\n    let lines: Vec<&str> = code.lines().collect();\n    \n    let mut group = c.benchmark_group(\"editor_frame\");\n    \n    group.bench_function(\"render_80x24_50_lines\", |b| {\n        let mut front = OptimizedBuffer::new(80, 24);\n        let mut back = OptimizedBuffer::new(80, 24);\n        let mut scroll = 0;\n        \n        b.iter(|| {\n            back.clear(Rgba::from_rgb_u8(30, 30, 40));\n            \n            // Line numbers\n            for y in 0..22 {\n                let line_num = scroll + y;\n                if line_num < lines.len() {\n                    let num_str = format!(\"{:4} \", line_num + 1);\n                    back.draw_text(0, y as u32, &num_str, Style::dim());\n                }\n            }\n            \n            // Code lines\n            for y in 0..22 {\n                let line_num = scroll + y;\n                if line_num < lines.len() {\n                    let line = lines[line_num];\n                    let display: String = line.chars().take(74).collect();\n                    back.draw_text(5, y as u32, &display, Style::default());\n                }\n            }\n            \n            // Status bar\n            back.fill_rect(0, 23, 80, 1, Rgba::from_rgb_u8(60, 60, 80));\n            back.draw_text(1, 23, \" src/lib.rs | Ln 1, Col 1 \", Style::default());\n            \n            // Diff\n            let diff = BufferDiff::compute(&front, &back);\n            std::mem::swap(&mut front, &mut back);\n            scroll = (scroll + 1) % lines.len().saturating_sub(22);\n            \n            black_box(diff);\n        })\n    });\n    \n    group.finish();\n}\n```\n\n### Animation Frame\n```rust\nfn bench_animation_frame(c: &mut Criterion) {\n    // Simulate an animation with multiple moving elements\n    // - Background\n    // - 50 animated particles\n    // - Progress bar\n    // - FPS counter\n    \n    struct Particle { x: f32, y: f32, vx: f32, vy: f32, color: Rgba }\n    \n    let mut particles: Vec<Particle> = (0..50).map(|i| {\n        Particle {\n            x: (i * 17 % 80) as f32,\n            y: (i * 13 % 24) as f32,\n            vx: ((i % 5) as f32 - 2.0) * 0.5,\n            vy: ((i % 7) as f32 - 3.0) * 0.3,\n            color: Rgba::from_hsv((i * 15 % 360) as f32, 0.8, 1.0),\n        }\n    }).collect();\n    \n    let mut group = c.benchmark_group(\"animation_frame\");\n    \n    group.bench_function(\"render_50_particles\", |b| {\n        let mut buffer = OptimizedBuffer::new(80, 24);\n        let mut frame = 0;\n        \n        b.iter(|| {\n            buffer.clear(Rgba::from_rgb_u8(20, 20, 30));\n            \n            // Update and draw particles\n            for p in &mut particles {\n                p.x = (p.x + p.vx).rem_euclid(80.0);\n                p.y = (p.y + p.vy).rem_euclid(24.0);\n                buffer.set_blended(\n                    p.x as u32,\n                    p.y as u32,\n                    Cell::new('●', Style::fg(p.color)),\n                );\n            }\n            \n            // Progress bar\n            let progress = (frame % 100) as f32 / 100.0;\n            let filled = (progress * 60.0) as u32;\n            buffer.draw_text(10, 22, \"[\", Style::default());\n            for i in 0..60 {\n                let ch = if i < filled { '█' } else { '░' };\n                buffer.set(11 + i, 22, Cell::new(ch, Style::default()));\n            }\n            buffer.draw_text(71, 22, \"]\", Style::default());\n            \n            frame += 1;\n            black_box(&buffer);\n        })\n    });\n    \n    group.finish();\n}\n```\n\n### Dashboard Refresh\n```rust\nfn bench_dashboard_refresh(c: &mut Criterion) {\n    // Simulate a dashboard with 5 panels updating\n    // - Header\n    // - 4 data panels with charts/numbers\n    // - Footer\n    \n    let mut group = c.benchmark_group(\"dashboard_refresh\");\n    \n    group.bench_function(\"render_5_panels\", |b| {\n        let mut buffer = OptimizedBuffer::new(120, 40);\n        let mut tick = 0;\n        \n        b.iter(|| {\n            buffer.clear(Rgba::from_rgb_u8(25, 25, 35));\n            \n            // Header\n            buffer.draw_box(0, 0, 120, 3, BoxStyle::double());\n            buffer.draw_text(3, 1, \"System Dashboard\", Style::bold());\n            \n            // Panel 1: CPU (left top)\n            buffer.draw_box(0, 3, 60, 18, BoxStyle::single());\n            buffer.draw_text(2, 4, \"CPU Usage\", Style::dim());\n            let cpu = (tick * 7 % 100) as u32;\n            for i in 0..50 {\n                let ch = if i < cpu / 2 { '█' } else { '░' };\n                buffer.set(5 + i, 6, Cell::new(ch, Style::fg(Rgba::GREEN)));\n            }\n            buffer.draw_text(5, 8, &format!(\"{}%\", cpu), Style::default());\n            \n            // Panel 2: Memory (right top)\n            buffer.draw_box(60, 3, 60, 18, BoxStyle::single());\n            buffer.draw_text(62, 4, \"Memory\", Style::dim());\n            \n            // Panel 3: Network (left bottom)\n            buffer.draw_box(0, 21, 60, 16, BoxStyle::single());\n            buffer.draw_text(2, 22, \"Network I/O\", Style::dim());\n            \n            // Panel 4: Disk (right bottom)\n            buffer.draw_box(60, 21, 60, 16, BoxStyle::single());\n            buffer.draw_text(62, 22, \"Disk I/O\", Style::dim());\n            \n            // Footer\n            buffer.draw_box(0, 37, 120, 3, BoxStyle::double());\n            buffer.draw_text(3, 38, &format!(\"Last update: tick {}\", tick), Style::dim());\n            \n            tick += 1;\n            black_box(&buffer);\n        })\n    });\n    \n    group.finish();\n}\n```\n\n### Large Document Scroll\n```rust\nfn bench_large_document_scroll(c: &mut Criterion) {\n    // Simulate scrolling through a 10K line document\n    \n    let document: String = (0..10000)\n        .map(|i| format!(\"Line {:5}: This is content for testing scroll performance\\n\", i))\n        .collect();\n    let lines: Vec<&str> = document.lines().collect();\n    \n    let mut group = c.benchmark_group(\"large_document\");\n    \n    group.bench_function(\"scroll_10k_lines\", |b| {\n        let mut buffer = OptimizedBuffer::new(80, 24);\n        let mut scroll = 0;\n        \n        b.iter(|| {\n            buffer.clear(Rgba::BLACK);\n            \n            for y in 0..24 {\n                let line_idx = scroll + y;\n                if line_idx < lines.len() {\n                    buffer.draw_text(0, y as u32, lines[line_idx], Style::default());\n                }\n            }\n            \n            scroll = (scroll + 1) % (lines.len() - 24);\n            black_box(&buffer);\n        })\n    });\n    \n    group.finish();\n}\n```\n\n## File to Create\n\n- `benches/workloads.rs`\n\n## Cargo.toml Addition\n\n```toml\n[[bench]]\nname = \"workloads\"\nharness = false\n```\n\n## Acceptance Criteria\n\n- [ ] Editor frame simulation benchmarked\n- [ ] Animation frame benchmarked\n- [ ] Dashboard refresh benchmarked\n- [ ] Large document scroll benchmarked\n- [ ] All should complete <1ms for smooth 60 FPS\n- [ ] Results documented with performance expectations","notes":"AGENTS.md alignment: Realistic workloads must complete <16ms for 60 FPS. Per AGENTS.md, cell operations must be zero-allocation. Dashboard and editor frames are key use cases. Use tracing for detailed timing logs.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:15:46.123101392Z","created_by":"ubuntu","updated_at":"2026-01-25T16:41:29.596514224Z","closed_at":"2026-01-25T16:41:29.596365334Z","close_reason":"done","compaction_level":0,"original_size":0,"labels":["benchmark"],"dependencies":[{"issue_id":"bd-1j0.6","depends_on_id":"bd-1j0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1j0.7","title":"Benchmark Validation and Regression Testing","description":"# Benchmark Validation and Regression Testing\n\n## Purpose\n\nAutomated validation that benchmarks run correctly and performance regression detection system with detailed logging for tracking performance over time.\n\n## Test Architecture\n\n### 1. Benchmark Smoke Tests\n\nCreate `tests/benchmarks_validate.rs`:\n\n```rust\n//\\! Validates benchmarks compile and produce reasonable output\n//\\! Run with: cargo test --test benchmarks_validate\n\nuse std::process::Command;\nuse std::time::Duration;\nuse tracing::{info, warn, error, debug};\n\nfn init_logging() {\n    let _ = tracing_subscriber::fmt()\n        .with_max_level(tracing::Level::DEBUG)\n        .try_init();\n}\n\n#[test]\nfn benchmarks_compile() {\n    init_logging();\n    info\\!(\"Validating benchmark compilation\");\n    \n    let output = Command::new(\"cargo\")\n        .args([\"build\", \"--benches\"])\n        .output()\n        .expect(\"Failed to run cargo\");\n    \n    if \\!output.status.success() {\n        let stderr = String::from_utf8_lossy(&output.stderr);\n        error\\!(stderr = stderr.as_ref(), \"Benchmark compilation failed\");\n        panic\\!(\"Benchmarks failed to compile\");\n    }\n    \n    info\\!(\"All benchmarks compile successfully\");\n}\n\n#[test]\nfn benchmark_quick_run() {\n    init_logging();\n    info\\!(\"Running benchmarks in quick mode\");\n    \n    // Run each benchmark for minimal iterations\n    let output = Command::new(\"cargo\")\n        .args([\n            \"bench\", \n            \"--\", \n            \"--test\",  // Run each benchmark once\n            \"--warm-up-time\", \"1\",\n            \"--measurement-time\", \"1\",\n        ])\n        .timeout(Duration::from_secs(60))\n        .output()\n        .expect(\"Failed to run benchmarks\");\n    \n    let stdout = String::from_utf8_lossy(&output.stdout);\n    let stderr = String::from_utf8_lossy(&output.stderr);\n    \n    debug\\!(stdout = stdout.as_ref(), \"Benchmark stdout\");\n    debug\\!(stderr = stderr.as_ref(), \"Benchmark stderr\");\n    \n    // Check for panics or errors\n    assert\\!(\n        \\!stderr.contains(\"panicked\") && \\!stderr.contains(\"error[E\"),\n        \"Benchmarks should not panic or error\"\n    );\n    \n    info\\!(\"Benchmark quick run completed successfully\");\n}\n```\n\n### 2. Performance Baseline Script\n\nCreate `scripts/benchmark_baseline.sh`:\n\n```bash\n#\\!/bin/bash\n# Generate and store performance baselines\n# Usage: ./scripts/benchmark_baseline.sh [baseline_name]\n\nset -euo pipefail\n\nBASELINE_NAME=\"${1:-$(git rev-parse --short HEAD)}\"\nBASELINE_DIR=\"target/criterion/baselines\"\nLOG_FILE=\"target/benchmark_${BASELINE_NAME}.log\"\n\nmkdir -p \"$BASELINE_DIR\"\n\necho \"=== Generating Performance Baseline: $BASELINE_NAME ===\" | tee \"$LOG_FILE\"\necho \"Started at: $(date)\" | tee -a \"$LOG_FILE\"\necho \"Git commit: $(git rev-parse HEAD)\" | tee -a \"$LOG_FILE\"\necho \"\" | tee -a \"$LOG_FILE\"\n\n# Run full benchmark suite\necho \"Running benchmarks...\" | tee -a \"$LOG_FILE\"\ncargo bench --message-format=json 2>&1 | tee -a \"$LOG_FILE\" | while read line; do\n    if echo \"$line\" | jq -e \".reason == \\\"benchmark-complete\\\"\" > /dev/null 2>&1; then\n        name=$(echo \"$line\" | jq -r \".id\")\n        mean=$(echo \"$line\" | jq -r \".mean.estimate\")\n        echo \"  $name: ${mean}ns\" | tee -a \"$LOG_FILE\"\n    fi\ndone\n\n# Save baseline\ncp -r target/criterion \"$BASELINE_DIR/$BASELINE_NAME\"\n\necho \"\" | tee -a \"$LOG_FILE\"\necho \"=== Baseline saved to: $BASELINE_DIR/$BASELINE_NAME ===\" | tee -a \"$LOG_FILE\"\necho \"Completed at: $(date)\" | tee -a \"$LOG_FILE\"\n```\n\n### 3. Regression Detection Script\n\nCreate `scripts/benchmark_regression.sh`:\n\n```bash\n#\\!/bin/bash\n# Compare current performance against baseline\n# Usage: ./scripts/benchmark_regression.sh [baseline_name] [threshold_percent]\n\nset -euo pipefail\n\nBASELINE=\"${1:-main}\"\nTHRESHOLD=\"${2:-10}\"\nLOG_FILE=\"target/benchmark_regression.log\"\n\necho \"=== Performance Regression Check ===\" | tee \"$LOG_FILE\"\necho \"Comparing against baseline: $BASELINE\" | tee -a \"$LOG_FILE\"\necho \"Regression threshold: ${THRESHOLD}%\" | tee -a \"$LOG_FILE\"\necho \"\" | tee -a \"$LOG_FILE\"\n\n# Run benchmarks with comparison\ncargo bench -- --baseline \"$BASELINE\" 2>&1 | tee -a \"$LOG_FILE\" | while read line; do\n    # Look for regression warnings\n    if echo \"$line\" | grep -q \"regressed\"; then\n        echo \"⚠️  REGRESSION DETECTED: $line\" | tee -a \"$LOG_FILE\"\n    elif echo \"$line\" | grep -q \"improved\"; then\n        echo \"✅ Improvement: $line\" | tee -a \"$LOG_FILE\"\n    fi\ndone\n\n# Check for regressions above threshold\nREGRESSIONS=$(grep -c \"regressed\" \"$LOG_FILE\" 2>/dev/null || echo \"0\")\n\nif [ \"$REGRESSIONS\" -gt 0 ]; then\n    echo \"\" | tee -a \"$LOG_FILE\"\n    echo \"=== FAILED: $REGRESSIONS regressions detected ===\" | tee -a \"$LOG_FILE\"\n    exit 1\nfi\n\necho \"\" | tee -a \"$LOG_FILE\"\necho \"=== PASSED: No significant regressions ===\" | tee -a \"$LOG_FILE\"\n```\n\n### 4. CI Integration\n\nCreate `.github/workflows/benchmark.yml`:\n\n```yaml\nname: Benchmarks\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  benchmark:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Install Rust\n        uses: dtolnay/rust-action@stable\n        \n      - name: Cache criterion results\n        uses: actions/cache@v4\n        with:\n          path: target/criterion\n          key: criterion-${{ runner.os }}-${{ hashFiles(\"**/Cargo.lock\") }}\n          \n      - name: Run benchmarks\n        run: |\n          cargo bench --message-format=json 2>&1 | tee benchmark_output.log\n          \n      - name: Check for regressions\n        run: |\n          if grep -q \"regressed\" benchmark_output.log; then\n            echo \"::warning::Performance regression detected\"\n            grep \"regressed\" benchmark_output.log\n          fi\n          \n      - name: Upload benchmark results\n        uses: actions/upload-artifact@v4\n        with:\n          name: benchmark-results\n          path: target/criterion/\n```\n\n### 5. Detailed Logging in Benchmarks\n\nUpdate benchmark files to include logging:\n\n```rust\n// In benches/buffer.rs\nuse tracing::{info, debug, span, Level};\n\nfn bench_buffer_clear(c: &mut Criterion) {\n    let _ = tracing_subscriber::fmt()\n        .with_max_level(Level::INFO)\n        .try_init();\n    \n    let span = span\\!(Level::INFO, \"bench_buffer_clear\");\n    let _enter = span.enter();\n    \n    let mut buffer = OptimizedBuffer::new(80, 24);\n    info\\!(width = 80, height = 24, \"Starting buffer clear benchmark\");\n    \n    c.bench_function(\"buffer_clear_80x24\", |b| {\n        b.iter(|| {\n            buffer.clear(Rgba::BLACK);\n        })\n    });\n    \n    info\\!(\"Benchmark complete\");\n}\n```\n\n## Files to Create\n\n- tests/benchmarks_validate.rs\n- scripts/benchmark_baseline.sh\n- scripts/benchmark_regression.sh\n- .github/workflows/benchmark.yml\n\n## Acceptance Criteria\n\n- [ ] All benchmarks compile and run\n- [ ] Baseline generation script works\n- [ ] Regression detection script works\n- [ ] CI integration configured\n- [ ] >10% regression triggers warning\n- [ ] Detailed logs produced\n- [ ] Benchmark results archived\n- [ ] Performance history tracked\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T01:59:50.053871225Z","created_by":"ubuntu","updated_at":"2026-01-25T17:46:32.593672748Z","closed_at":"2026-01-25T17:46:32.593446542Z","close_reason":"done","compaction_level":0,"original_size":0,"labels":["benchmark","testing"],"dependencies":[{"issue_id":"bd-1j0.7","depends_on_id":"bd-1j0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-1j0.7","depends_on_id":"bd-1j0.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-1j0.7","depends_on_id":"bd-1j0.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-1j0.7","depends_on_id":"bd-1j0.3","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-1j0.7","depends_on_id":"bd-1j0.4","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-1j0.7","depends_on_id":"bd-1j0.8","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-1j0.7","depends_on_id":"bd-1j0.9","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1j0.8","title":"Benchmark: Input parsing operations","description":"# Benchmark: Input Parsing Operations\n\n## Purpose\n\nBenchmark the input event parsing subsystem. Fast input parsing is critical for responsive terminal applications.\n\n## Benchmarks to Implement\n\n### Key Event Parsing\n\n```rust\nfn bench_key_event_parsing(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"input_parsing\");\n    \n    // Common key sequences\n    let key_sequences = [\n        (b\"a\".to_vec(), \"single_char\"),\n        (b\"\\x1b[A\".to_vec(), \"arrow_up\"),\n        (b\"\\x1b[1;5C\".to_vec(), \"ctrl_right\"),\n        (b\"\\x1bOP\".to_vec(), \"f1\"),\n        (b\"\\x1b[15~\".to_vec(), \"f5\"),\n        (b\"\\x1b[200~\".to_vec(), \"bracketed_paste_start\"),\n    ];\n    \n    for (seq, name) in key_sequences {\n        group.bench_function(name, |b| {\n            b.iter(|| {\n                parse_key_event(black_box(&seq))\n            })\n        });\n    }\n    group.finish();\n}\n```\n\n### Mouse Event Parsing\n\n```rust\nfn bench_mouse_event_parsing(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"mouse_parsing\");\n    \n    // SGR mouse sequences\n    let mouse_sequences = [\n        (b\"\\x1b[<0;10;20M\".to_vec(), \"button_press\"),\n        (b\"\\x1b[<0;10;20m\".to_vec(), \"button_release\"),\n        (b\"\\x1b[<32;10;20M\".to_vec(), \"mouse_move\"),\n        (b\"\\x1b[<64;10;20M\".to_vec(), \"scroll_up\"),\n    ];\n    \n    for (seq, name) in mouse_sequences {\n        group.bench_function(name, |b| {\n            b.iter(|| {\n                parse_mouse_event(black_box(&seq))\n            })\n        });\n    }\n    group.finish();\n}\n```\n\n### Escape Sequence Classification\n\n```rust\nfn bench_escape_classification(c: &mut Criterion) {\n    // Benchmark the initial escape sequence classifier\n    c.bench_function(\"classify_escape_sequence\", |b| {\n        let sequences = [\n            b\"\\x1b[A\".to_vec(),\n            b\"\\x1bOP\".to_vec(),\n            b\"\\x1b[<0;1;1M\".to_vec(),\n            b\"\\x1b]0;title\\x07\".to_vec(),\n        ];\n        \n        b.iter(|| {\n            for seq in &sequences {\n                black_box(classify_escape_sequence(seq));\n            }\n        })\n    });\n}\n```\n\n### Throughput Benchmark\n\n```rust\nfn bench_input_throughput(c: &mut Criterion) {\n    // Simulate rapid typing/mouse movement\n    let mut input_stream = Vec::new();\n    for _ in 0..1000 {\n        input_stream.extend_from_slice(b\"a\");\n        input_stream.extend_from_slice(b\"\\x1b[<32;10;20M\");\n    }\n    \n    c.bench_function(\"input_throughput_1000_events\", |b| {\n        b.iter(|| {\n            let mut events = Vec::new();\n            let mut parser = InputParser::new();\n            parser.parse_all(black_box(&input_stream), &mut events)\n        })\n    });\n}\n```\n\n## Files to Create/Modify\n\n- CREATE: `benches/input.rs`\n- MODIFY: `benches/mod.rs` (if exists)\n\n## Expected Performance\n\nDocument expected ranges:\n- Single key parse: <500ns\n- Mouse event parse: <1μs\n- 1000 events: <1ms\n\n## Acceptance Criteria\n\n- [ ] All input parsing benchmarks implemented\n- [ ] Performance documented\n- [ ] No panics on malformed input\n- [ ] Throughput benchmark included\n- [ ] Results added to performance docs\n","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T02:02:46.125129534Z","created_by":"ubuntu","updated_at":"2026-01-25T17:30:51.036984915Z","closed_at":"2026-01-25T17:30:51.036904844Z","close_reason":"done","compaction_level":0,"original_size":0,"labels":["benchmark"],"dependencies":[{"issue_id":"bd-1j0.8","depends_on_id":"bd-1j0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1j0.9","title":"Benchmark: Syntax highlighting operations","description":"# Benchmark: Syntax Highlighting Operations\n\n## Purpose\n\nBenchmark the syntax highlighting system to ensure it meets AGENTS.md performance requirements. This is CRITICAL because highlighting runs on every text change.\n\n## Performance Targets (from AGENTS.md principles)\n\n| Operation | Target | Rationale |\n|-----------|--------|-----------|\n| Single line tokenize | <1μs | Zero perceived latency |\n| Incremental update (1 line change) | <1ms | Smooth typing |\n| Full highlight (1000 lines) | <50ms | Acceptable file open time |\n| Full highlight (10000 lines) | <500ms | Large file tolerance |\n| Theme switch | <100μs | Instant visual feedback |\n\n## Benchmarks to Implement\n\n### 1. Tokenizer Benchmarks\n\n```rust\nfn bench_tokenize_single_line(c: &mut Criterion) {\n    let tokenizer = RustTokenizer::new();\n    let lines = [\n        \"fn main() { println!(\\\"hello\\\"); }\",\n        \"let x: HashMap<String, Vec<u32>> = HashMap::new();\",\n        \"/// This is a doc comment with `code`\",\n        \"#[derive(Debug, Clone, Serialize)]\",\n    ];\n    \n    let mut group = c.benchmark_group(\"tokenize_line\");\n    for (i, line) in lines.iter().enumerate() {\n        group.bench_function(format!(\"line_{i}\"), |b| {\n            b.iter(|| tokenizer.tokenize_line(black_box(line), LineState::Normal))\n        });\n    }\n    group.finish();\n}\n\nfn bench_tokenize_file(c: &mut Criterion) {\n    let tokenizer = RustTokenizer::new();\n    let source = include_str!(\"../src/lib.rs\");  // Real Rust file\n    \n    c.bench_function(\"tokenize_full_file\", |b| {\n        b.iter(|| {\n            let mut state = LineState::Normal;\n            for line in source.lines() {\n                let (_, new_state) = tokenizer.tokenize_line(line, state);\n                state = new_state;\n            }\n        })\n    });\n}\n```\n\n### 2. Incremental Highlighting Benchmarks\n\n```rust\nfn bench_incremental_single_line(c: &mut Criterion) {\n    let source = include_str!(\"../src/lib.rs\");\n    let buffer = TextBuffer::from_str(source);\n    let mut highlighted = HighlightedBuffer::new(buffer)\n        .with_tokenizer(Box::new(RustTokenizer::new()))\n        .with_theme(Theme::dark());\n    highlighted.update_highlighting();  // Initial full highlight\n    \n    c.bench_function(\"incremental_single_line\", |b| {\n        b.iter(|| {\n            highlighted.mark_dirty(100);  // Mark line 100 dirty\n            highlighted.update_highlighting();\n        })\n    });\n}\n\nfn bench_incremental_multiline(c: &mut Criterion) {\n    // Similar but dirty multiple lines\n}\n```\n\n### 3. Theme Operations\n\n```rust\nfn bench_theme_switch(c: &mut Criterion) {\n    let mut highlighted = /* setup */;\n    \n    c.bench_function(\"theme_switch\", |b| {\n        let mut is_dark = true;\n        b.iter(|| {\n            if is_dark {\n                highlighted.set_theme(Theme::light());\n            } else {\n                highlighted.set_theme(Theme::dark());\n            }\n            is_dark = !is_dark;\n        })\n    });\n}\n\nfn bench_styled_line_generation(c: &mut Criterion) {\n    // Benchmark converting tokens to styled segments\n    c.bench_function(\"styled_line\", |b| {\n        b.iter(|| highlighted.styled_line(black_box(50)))\n    });\n}\n```\n\n### 4. Memory Benchmarks\n\n```rust\nfn bench_memory_usage(c: &mut Criterion) {\n    // Track allocations during highlighting\n    // Use dhat or similar allocation profiler\n}\n```\n\n## Files to Create\n\n- CREATE: `benches/highlight.rs`\n- MODIFY: `Cargo.toml` (add [[bench]] entry)\n\n## Acceptance Criteria\n\n- [ ] All benchmark groups implemented\n- [ ] Performance targets documented in benchmark output\n- [ ] CI runs highlight benchmarks on main\n- [ ] >10% regression triggers warning\n- [ ] Results added to performance documentation\n- [ ] Benchmark covers all tokenizers (Rust, Python, JS, etc.)\n- [ ] Memory allocation tracking included\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T02:09:39.111930918Z","created_by":"ubuntu","updated_at":"2026-01-25T11:34:44.749562330Z","closed_at":"2026-01-25T11:34:44.749544166Z","close_reason":"Add highlight Criterion bench + bench entry + target docs; memory estimate proxy","compaction_level":0,"original_size":0,"labels":["benchmark","highlight"],"dependencies":[{"issue_id":"bd-1j0.9","depends_on_id":"bd-1j0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-1j0.9","depends_on_id":"bd-2x0.10","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1j8w","title":"demo_showcase features: grapheme pool showpiece (unicode panel + width ruler)","description":"# demo_showcase Features — Grapheme Pool Showpiece (Unicode Panel + Width Ruler)\n\n## Purpose\n\nOpenTUI’s grapheme pool is one of its most “engine-y” differentiators: multi-codepoint graphemes render correctly and can be diffed efficiently.\n\nThis bead ensures the demo has a dedicated, unmistakable panel where a viewer can see:\n\n- multi-codepoint ZWJ emoji rendered correctly\n- combining marks rendered correctly\n- wide character alignment working\n\n…and that it uses the **pool-aware drawing path**.\n\n## Implementation Requirements\n\n- Add a “Unicode” or “Text/Unicode” section reachable via sidebar.\n- Render strings from the content pack (`bd-1ei`) using:\n  - `let (buf, pool) = renderer.buffer_with_pool();`\n  - `buf.draw_text_with_pool(pool, x, y, text, style)`\n\n- Under each string, render a fixed “width ruler” line so alignment is obvious.\n\nOptional (nice): show a small table of `WidthMethod` options and indicate the current method.\n\n## Anti-Requirement\n\nDo not rely on `draw_text` placeholder IDs for multi-codepoint graphemes.\nThis bead exists specifically to prove `draw_text_with_pool` and pool rendering.\n\n## Acceptance Notes\n\n- ZWJ emoji (family, astronaut, etc.) display as a single glyph (as allowed by the terminal font).\n- Alignment/rulers make it obvious that width accounting is correct.","acceptance_criteria":"Done when:\n- The sidebar can navigate to a Unicode section where pool-rendered strings are visible.\n- The Unicode strings are rendered via the pool-aware path (`buffer_with_pool` + `draw_text_with_pool` or equivalent).\n- Under each string, a width ruler makes alignment/width decisions visually obvious.\n- The strings include at least: CJK wide chars, single-codepoint emoji, ZWJ emoji, and combining marks.\n- Headless JSON output contains sentinel markers proving the Unicode panel rendered and includes at least one ZWJ sequence.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:27:24.291324990Z","created_by":"ubuntu","updated_at":"2026-01-27T23:16:49.333950136Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","features","unicode"],"dependencies":[{"issue_id":"bd-1j8w","depends_on_id":"bd-37p","type":"parent-child","created_at":"2026-01-27T22:27:24.309681471Z","created_by":"ubuntu"},{"issue_id":"bd-1j8w","depends_on_id":"bd-3ii","type":"blocks","created_at":"2026-01-27T22:33:29.371320120Z","created_by":"ubuntu"},{"issue_id":"bd-1j8w","depends_on_id":"bd-hc0","type":"blocks","created_at":"2026-01-27T22:32:21.078046566Z","created_by":"ubuntu"},{"issue_id":"bd-1j8w","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:32:20.508470085Z","created_by":"ubuntu"}]}
{"id":"bd-1ju","title":"Verify OpenTUI port parity vs Zig spec and update FEATURE_PARITY","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-26T03:19:06.260247082Z","created_by":"ubuntu","updated_at":"2026-01-26T03:25:27.666287335Z","closed_at":"2026-01-26T03:25:27.666065898Z","close_reason":"Verified parity vs spec, updated FEATURE_PARITY.md","compaction_level":0,"original_size":0}
{"id":"bd-1m9","title":"demo_showcase runtime: non-blocking input pump (stdin read + InputParser + event queue)","description":"# demo_showcase Runtime — Non-Blocking Input Pump\n\n## Purpose\n\nBuild a robust input pipeline:\n\n- Read bytes from stdin without blocking the render loop\n- Parse using `opentui::InputParser`\n- Queue structured `Event`s for dispatch\n- Support both “real input” and synthetic events (tour mode)\n\n## Recommended Approach\n\nReuse the known-good pattern from `examples/editor.rs`:\n\n- Use `libc::select` (or `poll`) to read with a timeout\n- Maintain an `input_accumulator: Vec<u8>`\n- Repeatedly call `parser.parse(&input_accumulator[offset..])` until:\n  - `ParseError::Incomplete` (need more bytes)\n  - `ParseError::Empty`\n\n## Edge Cases\n\n- Partial escape sequences spanning reads\n- Bracketed paste payloads (large) → ensure accumulator is bounded\n- Unknown bytes → skip 1 byte and continue\n\n## Output of This Bead\n\nA function/struct something like:\n\n```rust\nstruct InputPump {\n    parser: InputParser,\n    buf: Vec<u8>,\n    scratch: [u8; 1024],\n}\n\nimpl InputPump {\n    fn poll(&mut self, timeout: Duration) -> io::Result<Vec<Event>> { ... }\n}\n```\n\nAnd a path to inject synthetic events for tour mode:\n\n```rust\nenum InputSource { Real, Synthetic }\n```\n\n## Safety\n\nIf we use `libc::select`/`poll`, keep the unsafe minimal and well-documented (demo binary may allow unsafe for this).","acceptance_criteria":"Checklist:\n- [ ] Render loop stays responsive (no blocking on stdin)\n- [ ] Partial sequences are handled correctly\n- [ ] Bracketed paste produces a Paste event and reaches the editor\n- [ ] Mouse and focus events are parsed and queued\n- [ ] Unknown bytes do not break the parser loop\n- [ ] Tour mode can inject synthetic events cleanly","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:09:10.155424839Z","created_by":"ubuntu","updated_at":"2026-01-27T22:11:48.866494178Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","input","runtime"],"dependencies":[{"issue_id":"bd-1m9","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:09:10.172125566Z","created_by":"ubuntu"},{"issue_id":"bd-1m9","depends_on_id":"bd-2iv","type":"blocks","created_at":"2026-01-27T22:11:48.866469823Z","created_by":"ubuntu"},{"issue_id":"bd-1m9","depends_on_id":"bd-z1b","type":"blocks","created_at":"2026-01-27T22:11:46.085685889Z","created_by":"ubuntu"}]}
{"id":"bd-1ms","title":"Add Word Movement and Deletion Methods","description":"## Overview\nAdd cursor movement and deletion methods that use existing word boundary detection.\n\n## Already Implemented (NO WORK NEEDED)\nThe following methods already exist in `src/text/edit.rs`:\n- `get_next_word_boundary()` at line 397 ✓\n- `get_prev_word_boundary()` at line 418 ✓\n\n## Scope (Methods to Add)\n```rust\nimpl EditBuffer {\n    /// Move cursor to next word (Ctrl+Right behavior).\n    pub fn move_word_right(&mut self) {\n        let boundary = self.get_next_word_boundary();\n        self.move_to_offset(boundary);\n    }\n\n    /// Move cursor to previous word (Ctrl+Left behavior).\n    pub fn move_word_left(&mut self) {\n        let boundary = self.get_prev_word_boundary();\n        self.move_to_offset(boundary);\n    }\n\n    /// Delete from cursor to next word boundary (Ctrl+Delete behavior).\n    pub fn delete_word_forward(&mut self) {\n        let end = self.get_next_word_boundary();\n        if end > self.cursor.offset {\n            self.delete_range_offsets(self.cursor.offset, end);\n        }\n    }\n\n    /// Delete from previous word boundary to cursor (Ctrl+Backspace behavior).\n    pub fn delete_word_backward(&mut self) {\n        let start = self.get_prev_word_boundary();\n        if start < self.cursor.offset {\n            self.delete_range_offsets(start, self.cursor.offset);\n        }\n    }\n}\n```\n\n## Files to Modify\n- src/text/edit.rs - Add the 4 new methods\n\n## Testing Requirements\n\n### Unit Tests (add to existing tests in src/text/edit.rs)\n```rust\n#[test]\nfn test_move_word_right() {\n    let mut buffer = EditBuffer::with_text(\"hello world test\");\n    \n    eprintln!(\"[TEST] Text: {:?}\", buffer.text());\n    eprintln!(\"[TEST] Initial cursor: offset={}\", buffer.cursor().offset);\n    \n    buffer.move_word_right();\n    eprintln!(\"[TEST] After move_word_right: offset={}\", buffer.cursor().offset);\n    assert_eq!(buffer.cursor().offset, 5, \"Should be at end of 'hello'\");\n    \n    buffer.move_word_right();\n    eprintln!(\"[TEST] After second move_word_right: offset={}\", buffer.cursor().offset);\n    assert_eq!(buffer.cursor().offset, 11, \"Should be at end of 'world'\");\n    \n    eprintln!(\"[TEST] PASS: move_word_right works\");\n}\n\n#[test]\nfn test_move_word_left() {\n    let mut buffer = EditBuffer::with_text(\"hello world test\");\n    buffer.move_to_end();  // Move to end\n    \n    eprintln!(\"[TEST] Text: {:?}\", buffer.text());\n    eprintln!(\"[TEST] Cursor at end: offset={}\", buffer.cursor().offset);\n    \n    buffer.move_word_left();\n    eprintln!(\"[TEST] After move_word_left: offset={}\", buffer.cursor().offset);\n    assert_eq!(buffer.cursor().offset, 12, \"Should be at start of 'test'\");\n    \n    buffer.move_word_left();\n    eprintln!(\"[TEST] After second move_word_left: offset={}\", buffer.cursor().offset);\n    assert_eq!(buffer.cursor().offset, 6, \"Should be at start of 'world'\");\n    \n    eprintln!(\"[TEST] PASS: move_word_left works\");\n}\n\n#[test]\nfn test_delete_word_forward() {\n    let mut buffer = EditBuffer::with_text(\"hello world test\");\n    buffer.move_to_offset(6);  // Start of \"world\"\n    \n    eprintln!(\"[TEST] Text: {:?}\", buffer.text());\n    eprintln!(\"[TEST] Cursor at offset 6 (start of 'world')\");\n    \n    buffer.delete_word_forward();\n    \n    eprintln!(\"[TEST] After delete_word_forward:\");\n    eprintln!(\"[TEST]   Text: {:?}\", buffer.text());\n    eprintln!(\"[TEST]   Cursor: offset={}\", buffer.cursor().offset);\n    \n    assert_eq!(buffer.text(), \"hello  test\", \"Should delete 'world'\");\n    assert_eq!(buffer.cursor().offset, 6, \"Cursor should stay at delete point\");\n    \n    // Test undo\n    buffer.undo();\n    eprintln!(\"[TEST] After undo: {:?}\", buffer.text());\n    assert_eq!(buffer.text(), \"hello world test\");\n    \n    eprintln!(\"[TEST] PASS: delete_word_forward works with undo\");\n}\n\n#[test]\nfn test_delete_word_backward() {\n    let mut buffer = EditBuffer::with_text(\"hello world test\");\n    buffer.move_to_offset(11);  // End of \"world\"\n    \n    eprintln!(\"[TEST] Text: {:?}\", buffer.text());\n    eprintln!(\"[TEST] Cursor at offset 11 (end of 'world')\");\n    \n    buffer.delete_word_backward();\n    \n    eprintln!(\"[TEST] After delete_word_backward:\");\n    eprintln!(\"[TEST]   Text: {:?}\", buffer.text());\n    eprintln!(\"[TEST]   Cursor: offset={}\", buffer.cursor().offset);\n    \n    assert_eq!(buffer.text(), \"hello  test\", \"Should delete 'world'\");\n    \n    // Test undo\n    buffer.undo();\n    eprintln!(\"[TEST] After undo: {:?}\", buffer.text());\n    assert_eq!(buffer.text(), \"hello world test\");\n    \n    eprintln!(\"[TEST] PASS: delete_word_backward works with undo\");\n}\n\n#[test]\nfn test_word_operations_across_lines() {\n    let mut buffer = EditBuffer::with_text(\"line one\\nline two\");\n    buffer.move_to_offset(9);  // Start of \"line two\"\n    \n    eprintln!(\"[TEST] Text with newline: {:?}\", buffer.text());\n    eprintln!(\"[TEST] Cursor at offset 9\");\n    \n    buffer.move_word_left();\n    let cursor = buffer.cursor();\n    eprintln!(\"[TEST] After move_word_left: offset={} row={} col={}\", \n        cursor.offset, cursor.row, cursor.col);\n    \n    assert!(cursor.offset < 9, \"Should move to previous line\");\n    \n    eprintln!(\"[TEST] PASS: Word operations cross line boundaries\");\n}\n\n#[test]\nfn test_word_operations_at_boundaries() {\n    let mut buffer = EditBuffer::with_text(\"hello\");\n    \n    // At start - move left should stay at 0\n    buffer.move_word_left();\n    assert_eq!(buffer.cursor().offset, 0);\n    eprintln!(\"[TEST] move_word_left at start stays at 0\");\n    \n    // At end - move right should stay at end\n    buffer.move_to_end();\n    let end = buffer.cursor().offset;\n    buffer.move_word_right();\n    assert_eq!(buffer.cursor().offset, end);\n    eprintln!(\"[TEST] move_word_right at end stays at end\");\n    \n    // Delete at boundaries - should be no-op\n    buffer.move_to_end();\n    buffer.delete_word_forward();\n    assert_eq!(buffer.text(), \"hello\", \"delete_word_forward at end is no-op\");\n    \n    buffer.move_to_offset(0);\n    buffer.delete_word_backward();\n    assert_eq!(buffer.text(), \"hello\", \"delete_word_backward at start is no-op\");\n    \n    eprintln!(\"[TEST] PASS: Word operations handle boundaries gracefully\");\n}\n```\n\n## Acceptance Criteria\n- [ ] `move_word_right()` moves cursor to next word boundary\n- [ ] `move_word_left()` moves cursor to previous word boundary\n- [ ] `delete_word_forward()` deletes from cursor to next word boundary\n- [ ] `delete_word_backward()` deletes from previous word boundary to cursor\n- [ ] Delete operations integrate with undo/redo\n- [ ] Operations handle buffer start/end gracefully\n- [ ] Operations work across line boundaries\n- [ ] All 6 new unit tests pass with detailed logging\n- [ ] Existing EditBuffer tests still pass (no regression)\n\nDependencies:\n  (none - uses existing boundary methods)\n\nDependents:\n  <- bd-1tl (blocks) - EditorView Visual Navigation","acceptance_criteria":"- [ ] next_word_boundary finds correct position\n- [ ] prev_word_boundary finds correct position\n- [ ] Handles punctuation as word separators\n- [ ] Handles start/end of buffer\n- [ ] delete_word integrates with undo\n- [ ] All 10+ unit tests pass\n\n---","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:02:05.592939988Z","closed_at":"2026-01-19T22:02:05.592896737Z","close_reason":"done","compaction_level":0,"original_size":0}
{"id":"bd-1n67","title":"demo_showcase tests: headless smoke run (cargo run -- --headless-smoke)","description":"# demo_showcase Tests — Headless Smoke Run\n\n## Purpose\n\nCompile coverage is not enough: we want a minimal runtime check that the demo can:\n\n- initialize state\n- execute update + render\n- exercise diff computation\n\n…without a real terminal.\n\n## Implementation\n\nAdd a test that runs the binary in headless mode:\n\n- cargo run --all-features --bin demo_showcase -- --headless-smoke --max-frames 10\n\nOptionally force a fixed size for stability:\n\n- --headless-size 80x24\n\n## Output / Assertions\n\n- Assert process exits 0.\n- Assert stdout contains the stable success marker:\n  - HEADLESS_SMOKE_OK\n\nOptional (recommended for deeper regression coverage):\n\n- run with --headless-dump-json and parse the JSON\n- assert expected “sentinel markers” exist (top bar title, panel headers, etc.)\n\n## Logging\n\n- On failure, print the full stderr and stdout to aid debugging.\n- If HARNESS_ARTIFACTS=1 is set, store stdout/stderr under target/test-artifacts.\n\n## Acceptance Notes\n\n- cargo test runs this and it works in CI (no TTY).\n- Failures surface actionable logs.","acceptance_criteria":"Done when:\n- An integration test runs `demo_showcase` with `--headless-smoke` (and a bounded frame count) in a non-TTY environment.\n- The test asserts: exit code 0 and stdout contains `HEADLESS_SMOKE_OK`.\n- On failure, the test prints full stdout/stderr and includes a reproduction command.\n- When `HARNESS_ARTIFACTS=1`, stdout/stderr (and any JSON dump) are written under `target/test-artifacts`.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:29:21.419793344Z","created_by":"ubuntu","updated_at":"2026-01-27T23:16:22.201566515Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","testing"],"dependencies":[{"issue_id":"bd-1n67","depends_on_id":"bd-10de","type":"blocks","created_at":"2026-01-27T22:32:35.001604133Z","created_by":"ubuntu"},{"issue_id":"bd-1n67","depends_on_id":"bd-2el","type":"blocks","created_at":"2026-01-27T22:32:33.960719500Z","created_by":"ubuntu"},{"issue_id":"bd-1n67","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-01-27T22:29:21.439221571Z","created_by":"ubuntu"}]}
{"id":"bd-1nx","title":"Optimize buffer.clear() to use fill() instead of per-cell allocation","description":"Current implementation creates a new Cell::clear(bg) for each cell in the loop. Could use fill() or single clone pattern for better performance. Benchmark showed ~76us for 200x50 buffer.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T16:54:35.610074425Z","created_by":"ubuntu","updated_at":"2026-01-21T17:34:13.619116109Z","closed_at":"2026-01-21T17:34:13.618776179Z","close_reason":"Verified OptimizedBuffer::clear uses single Cell::clear(bg) + cells.fill()","compaction_level":0,"original_size":0}
{"id":"bd-1ob","title":"demo_showcase runtime: resilience + capability gating implementation","description":"# demo_showcase Runtime — Resilience + Capability Gating Implementation\n\n## Purpose\n\nThe demo must look great on ideal terminals, but it must also be robust when:\n\n- terminal is too small\n- true color is not supported\n- hyperlinks are unsupported\n- mouse events aren’t available\n- stdout/stderr aren’t TTYs\n\nThis bead implements the degradation rules defined in `bd-1i7`.\n\n## Behaviors\n\n### Small Terminal\n\n- Define a minimum supported size (from spec).\n- Below that:\n  - switch to a compact layout (single column or stacked panels)\n  - reduce visual density (fewer borders, smaller headers)\n  - ensure no panics / out-of-bounds due to rect math\n\n### Missing Capabilities\n\n- If no truecolor: use a reduced palette (256-color-safe or basic).\n- If no hyperlinks: render link text without OSC 8 and add a `(copy)` hint.\n- If no mouse: hide click hints, ensure keyboard-only navigation covers everything.\n- If focus events not available: don’t depend on them for pause behavior.\n\n### Non‑TTY\n\n- Provide a safe fallback:\n  - `--headless-smoke` should work without a TTY.\n  - If run interactively without TTY and not headless, print a one-line guidance message and exit with non-zero.\n\n## Capability Override (Testability)\n\nTo make resilience testable and debuggable, the demo supports an optional capability preset override:\n\n- `--cap-preset <name>` (see `bd-2iv`)\n\nRules:\n\n- Interactive (TTY): presets can only DISABLE capabilities (effective = detected ∩ preset).\n- Headless: presets define the effective caps directly.\n\nThe UI should surface effective capabilities (inspector + status hints) so the viewer understands why a feature is disabled.\n\nThis is exercised by the degradation matrix suite (`bd-2bnv`).\n\n## Acceptance Notes\n\n- The demo never panics due to resize or missing terminal features.\n- UI clearly indicates when features are disabled (subtle warning in status/inspector).\n- Degradation behavior is consistent and snapshottable in headless mode.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:25:49.434807357Z","created_by":"ubuntu","updated_at":"2026-01-27T23:11:54.916262337Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","runtime"],"dependencies":[{"issue_id":"bd-1ob","depends_on_id":"bd-1i7","type":"blocks","created_at":"2026-01-27T22:32:10.635614919Z","created_by":"ubuntu"},{"issue_id":"bd-1ob","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:25:49.450381440Z","created_by":"ubuntu"},{"issue_id":"bd-1ob","depends_on_id":"bd-2iv","type":"blocks","created_at":"2026-01-27T22:32:11.169561512Z","created_by":"ubuntu"},{"issue_id":"bd-1ob","depends_on_id":"bd-3ii","type":"blocks","created_at":"2026-01-27T22:32:11.747840355Z","created_by":"ubuntu"},{"issue_id":"bd-1ob","depends_on_id":"bd-ix0","type":"blocks","created_at":"2026-01-27T22:32:12.288427025Z","created_by":"ubuntu"},{"issue_id":"bd-1ob","depends_on_id":"bd-pnln","type":"blocks","created_at":"2026-01-27T22:55:18.077506237Z","created_by":"ubuntu"}]}
{"id":"bd-1ok","title":"demo_showcase spec: visual design system (palette, typography, spacing, components)","description":"# demo_showcase Spec — Visual Design System\n\n## Goal\n\nA consistent, modern visual language that makes OpenTUI feel premium:\n\n- strong spacing rhythm\n- crisp borders\n- tasteful gradients\n- glassy overlays\n- clear focus/selection\n\nThis spec defines **multiple themes** because the demo explicitly showcases theme switching (UI + highlighting) as a real app capability.\n\n## Theme Set\n\n### Theme A: “Synthwave Professional” (Default, Dark)\n\nBase background:\n- BG0 = #0f1220 (app background)\n- BG1 = #151a2e (panel background)\n- BG2 = #1d2440 (raised surfaces / cards)\n\nText:\n- FG0 = #e6e6e6 (primary)\n- FG1 = #aeb6d6 (secondary)\n- FG2 = #6c7396 (dim)\n\nAccents:\n- Aqua   = #4dd6ff\n- Pink   = #ff4fd8\n- Green  = #2bff88\n- Orange = #ffb020\n- Red    = #ff4455\n\nSelection + Focus:\n- selection bg: #2a335c (typically applied as a low-alpha overlay)\n- focus border: Aqua (and bold)\n\n### Theme B: “Light (Paper)”\n\nBase background:\n- BG0 = #f7f7fb\n- BG1 = #ffffff\n- BG2 = #eef0f7\n\nText:\n- FG0 = #1a1b26\n- FG1 = #3a3f5a\n- FG2 = #6a6f8a\n\nAccents:\n- Blue   = #2a6fff\n- Purple = #7b61ff\n- Green  = #00a86b\n- Orange = #ff8a00\n- Red    = #e53935\n\nSelection + Focus:\n- selection bg: #dbe6ff (low alpha)\n- focus border: Blue\n\n### Theme C: “Solarized-ish” (Low Eye Strain)\n\nBase background:\n- BG0 = #002b36\n- BG1 = #073642\n- BG2 = #0b4452\n\nText:\n- FG0 = #eee8d5\n- FG1 = #93a1a1\n- FG2 = #657b83\n\nAccents:\n- Cyan   = #2aa198\n- Yellow = #b58900\n- Orange = #cb4b16\n- Red    = #dc322f\n- Blue   = #268bd2\n\nSelection + Focus:\n- selection bg: #0d5161 (low alpha)\n- focus border: Cyan\n\n### Theme D: “High Contrast” (Accessibility / Worst-Case Terminals)\n\nBase background:\n- BG0 = #000000\n- BG1 = #000000\n- BG2 = #111111\n\nText:\n- FG0 = #ffffff\n- FG1 = #e0e0e0\n- FG2 = #a0a0a0\n\nAccents:\n- Cyan   = #00ffff\n- Yellow = #ffff00\n- Magenta= #ff00ff\n- Green  = #00ff00\n- Red    = #ff0000\n\nSelection + Focus:\n- selection bg: #333333\n- focus border: Yellow\n\n## Component Styling Tokens (Theme-Relative)\n\n- Panel border: dim FG2\n- Focused panel border: focus accent + bold + optional 1px “glow line”\n- Headers: gradient bar + bold title\n- Status bar: BG2 with muted text; hotkeys in FG0 bold\n- Toasts: rounded box + opacity stack (glass)\n\n## Typography / Characters\n\n- Prefer Unicode box drawing (rounded/heavy where appropriate).\n- Use subtle separators: │, ─, ·.\n- Keep iconography mostly to single-codepoint symbols for stable width.\n\n## Gradient Rules\n\n- Gradients should be subtle: 5–10% perceived change across width.\n- Use Rgba::lerp between two close hues.\n\n## Theme Switching Rules\n\n- Theme switching changes BOTH:\n  1) UI palette/token set\n  2) syntax highlighting theme (Theme::dark/light/…)\n\nThe demo should present theme switching as a real workflow feature:\n\n- via command palette\n- optionally via number keys when help is open (discoverable)\n\n## Degradation Rules (Terminal Capability Variance)\n\n- If no truecolor, map theme colors to the closest 256-color approximation.\n- Avoid relying on italics/strikethrough; treat as “bonus” if supported.\n\n## What This Bead Produces\n\n- Canonical theme token sets used everywhere in the demo.\n- A single “current theme” selection mechanism shared by chrome, panels, overlays, toasts, and highlighting.","acceptance_criteria":"Checklist:\n- [ ] Palette tokens defined (BG/FG/Accents)\n- [ ] Focus/selection styling rules defined\n- [ ] Component styling rules defined (borders, headers, status, toasts)\n- [ ] Gradient rules defined\n- [ ] Degradation rules defined","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:06:10.420443553Z","created_by":"ubuntu","updated_at":"2026-01-27T22:45:16.313342466Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","design","ui"],"dependencies":[{"issue_id":"bd-1ok","depends_on_id":"bd-2jc","type":"parent-child","created_at":"2026-01-27T22:06:10.450428345Z","created_by":"ubuntu"},{"issue_id":"bd-1ok","depends_on_id":"bd-2mu","type":"blocks","created_at":"2026-01-27T22:07:58.107964883Z","created_by":"ubuntu"}]}
{"id":"bd-1pd","title":"demo_showcase UI: implement design system (palette + style helpers + gradients)","description":"# demo_showcase UI — Implement Design System\n\n## Purpose\n\nTurn the design system spec (`bd-1ok`) into code inside the demo binary:\n\n- theme token sets (multiple themes)\n- color tokens (`Rgba` constants)\n- style builders (header style, border style, focus style, selection style)\n- gradient helpers using `Rgba::lerp`\n\n## Implementation Pattern\n\nKeep it self-contained inside `src/bin/demo_showcase.rs`:\n\n- `enum UiTheme { SynthwaveDark, PaperLight, Solarized, HighContrast }`\n- `struct Tokens { bg0, bg1, bg2, fg0, fg1, fg2, accent_primary, ... }`\n- `impl UiTheme { fn tokens(self, caps: &Capabilities) -> Tokens }`\n\nNo file proliferation unless truly necessary.\n\n## Highlight Theme Mapping\n\nTheme switching should update BOTH:\n\n1) UI palette tokens\n2) syntax highlighting theme used by the editor panel\n\nCurrent highlight themes available in the library are:\n\n- Theme::dark()\n- Theme::light()\n- Theme::high_contrast()\n\nSo the mapping should be:\n\n- UiTheme::SynthwaveDark -> Theme::dark()\n- UiTheme::PaperLight -> Theme::light()\n- UiTheme::Solarized -> Theme::dark() (closest available unless we add a Solarized highlight theme later)\n- UiTheme::HighContrast -> Theme::high_contrast()\n\n## Must Demonstrate\n\n- Truecolor gradients when available (still okay if approximated)\n- cohesive spacing and hierarchy\n- strong focus/selection affordances that remain readable in reduced-color terminals\n\nDependencies:\n- This bead is blocked on the design system spec.","acceptance_criteria":"Checklist:\n- [ ] Palette constants exist and match spec\n- [ ] Style helpers exist (borders, focus, headers, status, toasts)\n- [ ] Gradient helper(s) exist and are used in top bar or background","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:12:42.059622696Z","created_by":"ubuntu","updated_at":"2026-01-27T22:53:43.069096073Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","ui"],"dependencies":[{"issue_id":"bd-1pd","depends_on_id":"bd-1ok","type":"blocks","created_at":"2026-01-27T22:31:49.547954895Z","created_by":"ubuntu"},{"issue_id":"bd-1pd","depends_on_id":"bd-c75","type":"parent-child","created_at":"2026-01-27T22:12:42.071894164Z","created_by":"ubuntu"}]}
{"id":"bd-1qe","title":"Add Terminal Cursor Save/Restore Methods","description":"## Overview\nAdd Terminal methods for cursor save/restore. The ANSI sequences already exist.\n\n## Already Implemented (NO WORK NEEDED)\nIn `src/ansi/sequences.rs`:\n- `CURSOR_SAVE: &str = \"\\x1b7\"` ✓\n- `CURSOR_RESTORE: &str = \"\\x1b8\"` ✓\n\n## Scope (Methods to Add)\n```rust\n// In src/terminal/mod.rs\nimpl Terminal<W> {\n    /// Save cursor position using DEC sequence.\n    pub fn save_cursor(&mut self) -> io::Result<()> {\n        self.write_all(CURSOR_SAVE.as_bytes())\n    }\n\n    /// Restore cursor position using DEC sequence.\n    pub fn restore_cursor(&mut self) -> io::Result<()> {\n        self.write_all(CURSOR_RESTORE.as_bytes())\n    }\n}\n```\n\n## Files to Modify\n- src/terminal/mod.rs - Add the 2 methods\n\n## Testing Requirements\n\n### Unit Tests\n```rust\n#[test]\nfn test_save_cursor_sequence() {\n    let mut output = Vec::new();\n    let mut terminal = Terminal::new(&mut output);\n    \n    terminal.save_cursor().unwrap();\n    \n    eprintln!(\"[TEST] Output bytes: {:?}\", output);\n    assert_eq!(output, b\"\\x1b7\");\n    \n    eprintln!(\"[TEST] PASS: save_cursor writes correct sequence\");\n}\n\n#[test]\nfn test_restore_cursor_sequence() {\n    let mut output = Vec::new();\n    let mut terminal = Terminal::new(&mut output);\n    \n    terminal.restore_cursor().unwrap();\n    \n    eprintln!(\"[TEST] Output bytes: {:?}\", output);\n    assert_eq!(output, b\"\\x1b8\");\n    \n    eprintln!(\"[TEST] PASS: restore_cursor writes correct sequence\");\n}\n\n#[test]\nfn test_save_restore_round_trip() {\n    let mut output = Vec::new();\n    let mut terminal = Terminal::new(&mut output);\n    \n    // Save, move, restore pattern\n    terminal.save_cursor().unwrap();\n    terminal.move_to(10, 5).unwrap();\n    terminal.restore_cursor().unwrap();\n    \n    eprintln!(\"[TEST] Full sequence: {:?}\", String::from_utf8_lossy(&output));\n    \n    // Should contain save, move, restore in order\n    let s = String::from_utf8_lossy(&output);\n    assert!(s.contains(\"\\x1b7\"));\n    assert!(s.contains(\"\\x1b8\"));\n    \n    eprintln!(\"[TEST] PASS: save/restore round trip works\");\n}\n```\n\n## Acceptance Criteria\n- [ ] `save_cursor()` writes correct DEC sequence (\\x1b7)\n- [ ] `restore_cursor()` writes correct DEC sequence (\\x1b8)\n- [ ] Methods return io::Result for error handling\n- [ ] All 3 unit tests pass with logging\n- [ ] Existing Terminal tests still pass (no regression)","acceptance_criteria":"- [ ] Sequences are correct\n- [ ] Terminal methods work\n- [ ] Unit tests pass\n\n---","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:39:53.968901162Z","closed_at":"2026-01-19T22:39:53.968855296Z","close_reason":"done","compaction_level":0,"original_size":0}
{"id":"bd-1t2","title":"demo_showcase UI: inspector/perf panel (RenderStats + capabilities)","description":"# demo_showcase UI — Inspector / Perf Panel (RenderStats + Capabilities)\n\n## Purpose\n\nA flagship demo should make performance and terminal capability behavior visible. This panel (or overlay) should show:\n\n- `Renderer::stats()` (FPS, frame time, cells updated, buffer bytes)\n- terminal capabilities (truecolor, sync output, hyperlinks, mouse, paste, focus)\n- current demo mode flags (tour on/off, threaded on/off, fps cap)\n\nThis turns the demo into a credible engineering tool instead of a flashy animation.\n\n## Minimum Data to Display\n\n- FPS + frame time (ms)\n- cells updated last frame\n- estimated total memory (buffers + hitgrid)\n- “sync output” active/inactive\n- “true color” active/inactive\n- hyperlink support yes/no\n- mouse tracking yes/no\n- bracketed paste yes/no\n\n## Rendering Notes\n\n- Must be legible at small sizes: show a compact mode (2–3 lines) when narrow.\n- Use a clear visual hierarchy (labels dim, values bright, warnings colored).\n- Optionally show a tiny live sparkline chart using `GrayscaleBuffer`.\n\n## Integration\n\n- Panel should update every frame and reflect real numbers.\n- Clicking toggles (if implemented) should use HitGrid.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:24:39.373078160Z","created_by":"ubuntu","updated_at":"2026-01-27T22:55:17.396200366Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","features","ui"],"dependencies":[{"issue_id":"bd-1t2","depends_on_id":"bd-1ob","type":"blocks","created_at":"2026-01-27T22:32:07.313409545Z","created_by":"ubuntu"},{"issue_id":"bd-1t2","depends_on_id":"bd-1pd","type":"blocks","created_at":"2026-01-27T22:32:06.747300687Z","created_by":"ubuntu"},{"issue_id":"bd-1t2","depends_on_id":"bd-c75","type":"parent-child","created_at":"2026-01-27T22:24:39.402043390Z","created_by":"ubuntu"},{"issue_id":"bd-1t2","depends_on_id":"bd-pnln","type":"blocks","created_at":"2026-01-27T22:55:17.396173375Z","created_by":"ubuntu"},{"issue_id":"bd-1t2","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:32:06.214292493Z","created_by":"ubuntu"}]}
{"id":"bd-1tl","title":"EditorView Visual Navigation","description":"## Overview\nImplement visual cursor navigation that respects text wrapping.\n\n## Scope\n```rust\nimpl EditorView {\n    /// Move cursor up in the visual (wrapped) view.\n    pub fn move_up_visual(&mut self);\n\n    /// Move cursor down in the visual (wrapped) view.\n    pub fn move_down_visual(&mut self);\n\n    /// Get the start of the current visual line.\n    pub fn visual_line_start(&self) -> usize;\n\n    /// Get the end of the current visual line.\n    pub fn visual_line_end(&self) -> usize;\n\n    /// Move to visual line start.\n    pub fn move_to_visual_line_start(&mut self);\n\n    /// Move to visual line end.\n    pub fn move_to_visual_line_end(&mut self);\n}\n```\n\n## Implementation Details\nVisual navigation requires:\n1. Getting current cursor position in visual coordinates\n2. Using line cache to map between logical and visual lines\n3. Moving within visual lines respecting column position\n\n## Files to Modify\n- src/text/editor.rs - add visual navigation methods\n\n## Testing Requirements\n\n### Unit Tests (minimum 12 tests with detailed logging)\n- test_visual_move_up_no_wrap\n- test_visual_move_up_with_wrap\n- test_visual_move_up_within_wrapped_line\n- test_visual_move_down_no_wrap\n- test_visual_move_down_with_wrap\n- test_visual_move_down_within_wrapped_line\n- test_visual_line_start\n- test_visual_line_end\n- test_visual_nav_preserves_column\n- test_visual_nav_at_buffer_start\n- test_visual_nav_at_buffer_end\n- test_visual_nav_wide_characters\n\n### Detailed Test Logging Framework\nEach test MUST log visual and logical coordinates:\n\n```rust\n#[test]\nfn test_visual_move_up_with_wrap() {\n    // Create text that wraps at width 10\n    let text = \"Short\\nThis is a very long line that will wrap multiple times\\nEnd\";\n    let buffer = EditBuffer::with_text(text);\n    let mut view = EditorView::new(buffer);\n    view.set_wrap_mode(WrapMode::Word);\n    view.set_viewport(0, 0, 10, 10);\n    \n    eprintln!(\"[TEST] Text: {:?}\", text);\n    eprintln!(\"[TEST] Viewport width: 10\");\n    eprintln!(\"[TEST] WrapMode: Word\");\n    \n    // Move to middle of the long line (which is wrapped)\n    view.edit_buffer_mut().move_to(1, 25);  // Logical line 1, col 25\n    \n    let cursor = view.edit_buffer().cursor();\n    let visual = view.visual_cursor(10, 10);\n    \n    eprintln!(\"[TEST] Initial position:\");\n    eprintln!(\"[TEST]   Logical: row={} col={} offset={}\", \n        cursor.row, cursor.col, cursor.offset);\n    eprintln!(\"[TEST]   Visual: row={} col={}\", \n        visual.visual_row, visual.visual_col);\n    \n    // Move up in visual view\n    view.move_up_visual();\n    \n    let cursor = view.edit_buffer().cursor();\n    let visual = view.visual_cursor(10, 10);\n    \n    eprintln!(\"[TEST] After move_up_visual:\");\n    eprintln!(\"[TEST]   Logical: row={} col={} offset={}\", \n        cursor.row, cursor.col, cursor.offset);\n    eprintln!(\"[TEST]   Visual: row={} col={}\", \n        visual.visual_row, visual.visual_col);\n    \n    // Visual row should decrease by 1, but logical row might stay same\n    // (if we're still within the wrapped line)\n    assert!(visual.visual_row < 3, \"Visual row should decrease\");\n    \n    eprintln!(\"[TEST] PASS: Visual up navigation works with wrapping\");\n}\n\n#[test]\nfn test_visual_nav_preserves_column() {\n    let text = \"Short\\nMedium line\\nAnother short\";\n    let buffer = EditBuffer::with_text(text);\n    let mut view = EditorView::new(buffer);\n    view.set_wrap_mode(WrapMode::None);\n    \n    eprintln!(\"[TEST] Text:\");\n    for (i, line) in text.lines().enumerate() {\n        eprintln!(\"[TEST]   Line {}: {:?} (len={})\", i, line, line.len());\n    }\n    \n    // Position at column 8 in middle line\n    view.edit_buffer_mut().move_to(1, 8);\n    \n    let cursor = view.edit_buffer().cursor();\n    eprintln!(\"[TEST] Initial: row={} col={}\", cursor.row, cursor.col);\n    \n    // Move up - \"Short\" only has 5 chars, so col should clamp\n    view.move_up_visual();\n    \n    let cursor = view.edit_buffer().cursor();\n    eprintln!(\"[TEST] After up: row={} col={}\", cursor.row, cursor.col);\n    assert_eq!(cursor.row, 0);\n    assert!(cursor.col <= 5, \"Column should clamp to line length\");\n    \n    // Move down twice - back to middle, then to \"Another short\"\n    view.move_down_visual();\n    view.move_down_visual();\n    \n    let cursor = view.edit_buffer().cursor();\n    eprintln!(\"[TEST] After 2x down: row={} col={}\", cursor.row, cursor.col);\n    assert_eq!(cursor.row, 2);\n    // Column should attempt to restore to 8 if line is long enough\n    \n    eprintln!(\"[TEST] PASS: Column position preserved/clamped correctly\");\n}\n\n#[test]\nfn test_visual_line_start_and_end() {\n    let text = \"This is a line that will definitely wrap when viewport is narrow\";\n    let buffer = EditBuffer::with_text(text);\n    let mut view = EditorView::new(buffer);\n    view.set_wrap_mode(WrapMode::Word);\n    view.set_viewport(0, 0, 15, 10);\n    \n    eprintln!(\"[TEST] Text: {:?}\", text);\n    eprintln!(\"[TEST] Text length: {} bytes\", text.len());\n    eprintln!(\"[TEST] Viewport width: 15\");\n    \n    // Move to middle of text\n    view.edit_buffer_mut().move_to_offset(30);\n    \n    let cursor = view.edit_buffer().cursor();\n    let visual = view.visual_cursor(15, 10);\n    eprintln!(\"[TEST] Position: offset={} visual_row={} visual_col={}\",\n        cursor.offset, visual.visual_row, visual.visual_col);\n    \n    let start = view.visual_line_start();\n    let end = view.visual_line_end();\n    \n    eprintln!(\"[TEST] Visual line boundaries:\");\n    eprintln!(\"[TEST]   start offset: {}\", start);\n    eprintln!(\"[TEST]   end offset: {}\", end);\n    eprintln!(\"[TEST]   visual line text: {:?}\", &text[start..end]);\n    \n    assert!(start <= cursor.offset);\n    assert!(end >= cursor.offset);\n    assert!(end - start <= 15, \"Visual line should fit in viewport\");\n    \n    eprintln!(\"[TEST] PASS: Visual line start/end computed correctly\");\n}\n\n#[test]\nfn test_visual_nav_wide_characters() {\n    // CJK characters are 2 columns wide\n    let text = \"ABC\\u{4e2d}\\u{6587}\\u{6d4b}\\u{8bd5}DEF\";  // \"ABC中文测试DEF\"\n    let buffer = EditBuffer::with_text(text);\n    let mut view = EditorView::new(buffer);\n    view.set_wrap_mode(WrapMode::Char);\n    view.set_viewport(0, 0, 8, 5);\n    \n    eprintln!(\"[TEST] Text: {:?}\", text);\n    eprintln!(\"[TEST] Expected widths:\");\n    eprintln!(\"[TEST]   'ABC' = 3 cols\");\n    eprintln!(\"[TEST]   '中文测试' = 8 cols (4 chars x 2)\");\n    eprintln!(\"[TEST]   'DEF' = 3 cols\");\n    eprintln!(\"[TEST]   Total = 14 cols, viewport = 8\");\n    \n    // Should wrap somewhere\n    view.edit_buffer_mut().move_to_offset(0);\n    \n    let visual = view.visual_cursor(8, 5);\n    eprintln!(\"[TEST] At offset 0: visual_row={}\", visual.visual_row);\n    \n    // Move to end\n    view.edit_buffer_mut().move_to_offset(text.len());\n    let visual = view.visual_cursor(8, 5);\n    eprintln!(\"[TEST] At end: visual_row={}\", visual.visual_row);\n    \n    // Navigate up/down and verify no crash on wide chars\n    view.move_up_visual();\n    let cursor = view.edit_buffer().cursor();\n    eprintln!(\"[TEST] After up: offset={}\", cursor.offset);\n    \n    // Should not be in middle of a CJK character\n    let text_bytes = text.as_bytes();\n    assert!(text.is_char_boundary(cursor.offset), \n        \"Cursor should be at valid char boundary\");\n    \n    eprintln!(\"[TEST] PASS: Wide character navigation works\");\n}\n\n#[test]\nfn test_visual_nav_at_buffer_boundaries() {\n    let text = \"Line 1\\nLine 2\";\n    let buffer = EditBuffer::with_text(text);\n    let mut view = EditorView::new(buffer);\n    view.set_wrap_mode(WrapMode::None);\n    \n    eprintln!(\"[TEST] Text: {:?}\", text);\n    \n    // At start, try to move up\n    view.edit_buffer_mut().move_to(0, 0);\n    eprintln!(\"[TEST] At buffer start, calling move_up_visual\");\n    view.move_up_visual();\n    \n    let cursor = view.edit_buffer().cursor();\n    eprintln!(\"[TEST] After up at start: row={} col={}\", cursor.row, cursor.col);\n    assert_eq!(cursor.row, 0, \"Should stay at start\");\n    \n    // At end, try to move down\n    view.edit_buffer_mut().move_to(1, 6);\n    eprintln!(\"[TEST] At buffer end, calling move_down_visual\");\n    view.move_down_visual();\n    \n    let cursor = view.edit_buffer().cursor();\n    eprintln!(\"[TEST] After down at end: row={} col={}\", cursor.row, cursor.col);\n    assert_eq!(cursor.row, 1, \"Should stay at end\");\n    \n    eprintln!(\"[TEST] PASS: Boundary conditions handled (no crash)\");\n}\n```\n\n## Acceptance Criteria\n- [ ] move_up_visual/move_down_visual navigate visual lines correctly\n- [ ] Navigation works within wrapped logical lines\n- [ ] Column position preserved when possible\n- [ ] Column clamped when target line is shorter\n- [ ] visual_line_start/end return correct byte offsets\n- [ ] Wide characters (CJK) handled correctly (no mid-char positioning)\n- [ ] Boundary conditions handled gracefully (no crash)\n- [ ] Works correctly with all wrap modes (None/Char/Word)\n- [ ] All 12+ unit tests pass with detailed logging\n- [ ] Each test logs both logical and visual coordinates\n- [ ] Tests log text content at cursor positions\n\nDependencies:\n  -> bd-2sk (blocks) - TextBufferView Line Info Cache\n  -> bd-1ms (blocks) - EditBuffer Word Boundary Navigation\n\nDependents:\n  <- bd-rqd (blocks) - EditorView Scroll Margins and Selection","acceptance_criteria":"- [ ] Up/down navigate visual lines correctly\n- [ ] Column position preserved when possible\n- [ ] Works correctly with wrapped text\n- [ ] All 8+ unit tests pass\n\n---","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:23:04.583269631Z","closed_at":"2026-01-19T22:23:04.583221700Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-1tl","depends_on_id":"bd-1ms","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-1tl","depends_on_id":"bd-2sk","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-1w9","title":"demo_showcase UI: command palette overlay (Ctrl+P)","description":"# demo_showcase UI — Command Palette Overlay (Ctrl+P)\n\n## Purpose\n\nA modern-feeling command palette is one of the most “real app” UI elements we can ship, and it’s a perfect vehicle to show:\n\n- scissor clipping (scrolling results list)\n- alpha blending (glass overlay)\n- hit testing (click commands)\n- text styling (match highlights)\n\n## Behaviors\n\n- Open/close: Ctrl+P toggles.\n- Typing edits the query buffer.\n- Up/Down selects a command.\n- Enter executes the selected command.\n- Esc closes.\n\nMouse support:\n- scroll wheel scrolls results\n- click selects + executes\n\n## Command Set (Minimum)\n\nCommands should map to real demo actions:\n\n- Toggle Help (F1)\n- Start Tour (Ctrl+T) / Stop Tour\n- Switch UI Theme: Synthwave Dark / Paper Light / Solarized / High Contrast\n- Switch Highlight Theme (mirrors UI theme mapping)\n- Toggle Debug Overlay\n- Force Full Redraw\n- Toggle Threaded Renderer (optional / gated)\n- Navigate: Overview / Editor / Preview / Logs / Unicode / Performance\n\nNo fuzzy matcher dependency; start with deterministic substring scoring.\n\n## Rendering Notes\n\n- Use the overlay system bead for backdrop + panel body.\n- Results list must be clipped to its viewport via scissor.\n- Selected row uses a strong accent + subtle alpha fill.\n- Query input row should show a blinking caret (time-driven) even if we don’t use the terminal cursor.\n\n## Integration\n\n- Executing a command produces:\n  - a toast (see toast bead)\n  - a log entry (logs panel)\n  - state changes (mode/theme/panel)\n\nDependencies:\n- This overlay depends on the overlay system and the keybinding spec.","acceptance_criteria":"Done when:\n- Ctrl+P toggles the palette; Esc closes it; Enter executes the selected command.\n- Typing edits the query buffer and updates result ordering deterministically (no extra deps).\n- Results list is scrollable and clipped via scissor (no bleed).\n- Mouse support works: scroll wheel scrolls results; click selects/executes.\n- Palette includes commands for: help, tour, theme switching, debug overlay toggle, full redraw, navigation, and (optionally) threaded mode.\n- Executing a command produces a toast and a log entry.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:23:40.180807026Z","created_by":"ubuntu","updated_at":"2026-01-27T23:17:03.759277090Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","ui"],"dependencies":[{"issue_id":"bd-1w9","depends_on_id":"bd-1al","type":"blocks","created_at":"2026-01-27T22:32:01.773828802Z","created_by":"ubuntu"},{"issue_id":"bd-1w9","depends_on_id":"bd-2c6","type":"blocks","created_at":"2026-01-27T22:32:03.437611993Z","created_by":"ubuntu"},{"issue_id":"bd-1w9","depends_on_id":"bd-35e","type":"blocks","created_at":"2026-01-27T22:32:02.884318644Z","created_by":"ubuntu"},{"issue_id":"bd-1w9","depends_on_id":"bd-35g","type":"blocks","created_at":"2026-01-27T22:32:02.324240949Z","created_by":"ubuntu"},{"issue_id":"bd-1w9","depends_on_id":"bd-3l0","type":"blocks","created_at":"2026-01-27T22:32:03.992196448Z","created_by":"ubuntu"},{"issue_id":"bd-1w9","depends_on_id":"bd-c75","type":"parent-child","created_at":"2026-01-27T22:23:40.192671164Z","created_by":"ubuntu"}]}
{"id":"bd-219","title":"Fix Bracketed Paste Mode Bug","description":"## Overview\nFix a bug in the existing input parser where bracketed paste mode (ESC[200~ ... ESC[201~) doesn't work correctly.\n\n## Current State\nThe parser already handles:\n- CSI sequences (cursor keys, function keys, modifiers) ✓\n- SS3 sequences (alternate cursor key format) ✓\n- Focus events (ESC[I, ESC[O) ✓\n- UTF-8 character sequences ✓\n- SGR and X11 mouse parsing ✓\n- Partial sequence handling ✓\n\n## Bug Description\nIn `src/input/parser.rs` at lines 254-256, when the parser encounters CSI 200~ (bracketed paste start sequence), it incorrectly returns `Err(ParseError::Incomplete)` instead of setting `self.in_paste = true` to enter paste mode.\n\n```rust\n// CURRENT (BROKEN):\n200 => {\n    // Bracketed paste start - handled elsewhere\n    return Err(ParseError::Incomplete);\n}\n\n// SHOULD BE:\n200 => {\n    self.in_paste = true;\n    return Err(ParseError::Incomplete); // Need more data for paste content\n}\n```\n\nThe `parse_paste()` method at line 368 correctly handles collecting paste content and detecting the end sequence (ESC[201~), but the paste mode is never entered because `in_paste` is never set to `true`.\n\n## Files to Modify\n- src/input/parser.rs - Fix the CSI 200~ handling to set `in_paste = true`\n\n## Testing Requirements\n\n### Unit Tests (add to existing tests in parser.rs)\n```rust\n#[test]\nfn test_parse_bracketed_paste_simple() {\n    let mut parser = InputParser::new();\n    // Start paste, content, end paste\n    let input = b\"\\x1b[200~Hello, World!\\x1b[201~\";\n    eprintln!(\"[TEST] Input: {:?}\", input);\n    eprintln!(\"[TEST] Hex: {}\", input.iter().map(|b| format!(\"{:02x}\", b)).collect::<Vec<_>>().join(\" \"));\n    \n    let (event, consumed) = parser.parse(input).unwrap();\n    \n    eprintln!(\"[TEST] Event: {:?}\", event);\n    eprintln!(\"[TEST] Consumed: {} bytes\", consumed);\n    \n    match event {\n        Event::Paste(paste) => {\n            eprintln!(\"[TEST] Paste content: {:?}\", paste.content());\n            assert_eq!(paste.content(), \"Hello, World!\");\n        }\n        other => panic!(\"Expected Paste event, got {:?}\", other),\n    }\n    \n    assert_eq!(consumed, input.len());\n    eprintln!(\"[TEST] PASS: Simple bracketed paste works\");\n}\n\n#[test]\nfn test_parse_bracketed_paste_with_newlines() {\n    let mut parser = InputParser::new();\n    let input = b\"\\x1b[200~Line 1\\nLine 2\\nLine 3\\x1b[201~\";\n    eprintln!(\"[TEST] Testing paste with newlines\");\n    \n    let (event, _) = parser.parse(input).unwrap();\n    \n    match event {\n        Event::Paste(paste) => {\n            let content = paste.content();\n            eprintln!(\"[TEST] Paste content: {:?}\", content);\n            assert!(content.contains('\\n'), \"Paste should preserve newlines\");\n            assert_eq!(content.lines().count(), 3);\n        }\n        _ => panic!(\"Expected Paste event\"),\n    }\n    eprintln!(\"[TEST] PASS: Newlines preserved in paste\");\n}\n\n#[test]\nfn test_parse_bracketed_paste_utf8() {\n    let mut parser = InputParser::new();\n    let input = \"Hello, 世界! 🎉\".as_bytes();\n    let mut full_input = vec![];\n    full_input.extend_from_slice(b\"\\x1b[200~\");\n    full_input.extend_from_slice(input);\n    full_input.extend_from_slice(b\"\\x1b[201~\");\n    \n    eprintln!(\"[TEST] Testing UTF-8 paste: {:?}\", std::str::from_utf8(input).unwrap());\n    \n    let (event, _) = parser.parse(&full_input).unwrap();\n    \n    match event {\n        Event::Paste(paste) => {\n            eprintln!(\"[TEST] Paste content: {:?}\", paste.content());\n            assert!(paste.content().contains(\"世界\"));\n            assert!(paste.content().contains(\"🎉\"));\n        }\n        _ => panic!(\"Expected Paste event\"),\n    }\n    eprintln!(\"[TEST] PASS: UTF-8 content preserved in paste\");\n}\n\n#[test]\nfn test_parse_bracketed_paste_incremental() {\n    let mut parser = InputParser::new();\n    \n    eprintln!(\"[TEST] Testing incremental paste parsing\");\n    \n    // Send start sequence\n    let result = parser.parse(b\"\\x1b[200~\");\n    eprintln!(\"[TEST] After start sequence: {:?}\", result);\n    assert!(result.is_err(), \"Should need more data\");\n    \n    // Send partial content (no end yet)\n    let result = parser.parse(b\"Hello\");\n    eprintln!(\"[TEST] After partial content: {:?}\", result);\n    assert!(result.is_err(), \"Should still need end sequence\");\n    \n    // Send end sequence\n    let result = parser.parse(b\"\\x1b[201~\");\n    eprintln!(\"[TEST] After end sequence: {:?}\", result);\n    // Note: actual behavior depends on implementation\n    \n    eprintln!(\"[TEST] PASS: Incremental paste handled\");\n}\n```\n\n## Acceptance Criteria\n- [ ] CSI 200~ (paste start) correctly sets `in_paste = true`\n- [ ] Paste content is collected until ESC[201~ is received\n- [ ] Paste(PasteEvent) is returned with correct content\n- [ ] UTF-8 content in paste is preserved correctly\n- [ ] Newlines in paste content are preserved\n- [ ] Incremental parsing works (partial paste buffers)\n- [ ] All 4 new unit tests pass with detailed logging\n- [ ] Existing parser tests still pass (no regression)","acceptance_criteria":"- [ ] Parser handles all xterm-compatible key sequences\n- [ ] UTF-8 characters parse correctly (including 4-byte emoji)\n- [ ] Partial sequences return NeedMoreData (not error)\n- [ ] Invalid sequences return Unknown (not panic)\n- [ ] Performance: parse 100K events/sec\n- [ ] All 18+ unit tests pass\n- [ ] E2E test with recorded sequences passes\n- [ ] No clippy warnings\n\n---","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:08:05.769498527Z","closed_at":"2026-01-19T22:08:05.769452290Z","close_reason":"Bug already fixed: CSI 200~ correctly sets in_paste=true (line 256). Comprehensive tests exist and pass (7 bracketed paste tests). Verified with cargo test --nocapture.","compaction_level":0,"original_size":0}
{"id":"bd-21g","title":"TextBufferView measureForDimensions","description":"## Overview\nImplement measureForDimensions() to calculate required viewport size for text content.\n\n## Scope\n```rust\nimpl TextBufferView {\n    /// Calculate the dimensions needed to display all content.\n    /// Returns (virtual_line_count, max_line_width)\n    pub fn measure_for_dimensions(&self, wrap_width: Option<u32>) -> (usize, usize) {\n        // Use line cache if available\n        // Otherwise compute on the fly\n    }\n}\n```\n\n## Implementation Details\n- Use LineCache when wrap_width is specified and cache is valid\n- For unwrapped mode, iterate lines and compute widths\n- Return tuple of (total_virtual_lines, maximum_line_width)\n\n## Files to Modify\n- src/text/view.rs - add measure_for_dimensions()\n\n## Testing Requirements\n\n### Unit Tests (minimum 8 tests with detailed logging)\n- test_measure_no_wrap\n- test_measure_with_char_wrap\n- test_measure_with_word_wrap\n- test_measure_empty_buffer\n- test_measure_single_long_line\n- test_measure_cjk_content\n- test_measure_updates_after_edit\n- test_measure_consistency_with_render\n\n### Detailed Test Logging Framework\nEach test MUST log dimensions and verify them:\n\n```rust\n#[test]\nfn test_measure_no_wrap() {\n    let mut buffer = TextBuffer::new();\n    buffer.set_text(\"Short\\nThis is a medium length line\\nTiny\");\n    \n    eprintln!(\"[TEST] Text lines:\");\n    for (i, line) in buffer.text().lines().enumerate() {\n        eprintln!(\"[TEST]   Line {}: {:?} (display_width={})\", \n            i, line, unicode_width::UnicodeWidthStr::width(line));\n    }\n    \n    let view = TextBufferView::new(&buffer);\n    let (lines, max_width) = view.measure_for_dimensions(None);\n    \n    eprintln!(\"[TEST] measure_for_dimensions(None):\");\n    eprintln!(\"[TEST]   virtual_line_count: {}\", lines);\n    eprintln!(\"[TEST]   max_line_width: {}\", max_width);\n    \n    assert_eq!(lines, 3, \"Should have 3 lines\");\n    assert_eq!(max_width, 29, \"Max width should be 'This is a medium length line' = 29\");\n    \n    eprintln!(\"[TEST] PASS: No-wrap dimensions correct\");\n}\n\n#[test]\nfn test_measure_with_word_wrap() {\n    let mut buffer = TextBuffer::new();\n    buffer.set_text(\"This is a line that will wrap when given a narrow width\");\n    \n    eprintln!(\"[TEST] Text: {:?}\", buffer.text());\n    eprintln!(\"[TEST] Text length: {} chars\", buffer.text().len());\n    \n    let view = TextBufferView::new(&buffer);\n    \n    // Measure with wrap width 20\n    let (lines, max_width) = view.measure_for_dimensions(Some(20));\n    \n    eprintln!(\"[TEST] measure_for_dimensions(Some(20)):\");\n    eprintln!(\"[TEST]   virtual_line_count: {}\", lines);\n    eprintln!(\"[TEST]   max_line_width: {}\", max_width);\n    \n    assert!(lines > 1, \"Should wrap into multiple lines\");\n    assert!(max_width <= 20, \"Max width should be <= wrap_width\");\n    \n    // Measure with narrower width\n    let (lines2, max_width2) = view.measure_for_dimensions(Some(10));\n    \n    eprintln!(\"[TEST] measure_for_dimensions(Some(10)):\");\n    eprintln!(\"[TEST]   virtual_line_count: {}\", lines2);\n    eprintln!(\"[TEST]   max_line_width: {}\", max_width2);\n    \n    assert!(lines2 > lines, \"Narrower width should produce more lines\");\n    \n    eprintln!(\"[TEST] PASS: Word wrap dimensions scale correctly\");\n}\n\n#[test]\nfn test_measure_cjk_content() {\n    let mut buffer = TextBuffer::new();\n    // Mix of ASCII and CJK (each CJK char is 2 columns)\n    buffer.set_text(\"Hello\\u{4e16}\\u{754c}World\");  // \"Hello世界World\"\n    \n    eprintln!(\"[TEST] Text: {:?}\", buffer.text());\n    eprintln!(\"[TEST] Expected width: 5 + 2 + 2 + 5 = 14 columns\");\n    \n    let view = TextBufferView::new(&buffer);\n    let (lines, max_width) = view.measure_for_dimensions(None);\n    \n    eprintln!(\"[TEST] Measured:\");\n    eprintln!(\"[TEST]   lines: {}\", lines);\n    eprintln!(\"[TEST]   max_width: {}\", max_width);\n    \n    assert_eq!(lines, 1);\n    assert_eq!(max_width, 14, \"Width should account for double-width CJK\");\n    \n    eprintln!(\"[TEST] PASS: CJK character widths measured correctly\");\n}\n\n#[test]\nfn test_measure_empty_buffer() {\n    let buffer = TextBuffer::new();\n    \n    eprintln!(\"[TEST] Empty buffer\");\n    \n    let view = TextBufferView::new(&buffer);\n    let (lines, max_width) = view.measure_for_dimensions(None);\n    \n    eprintln!(\"[TEST] Measured: lines={}, max_width={}\", lines, max_width);\n    \n    assert_eq!(lines, 1, \"Empty buffer should have 1 line\");\n    assert_eq!(max_width, 0, \"Empty buffer should have 0 width\");\n    \n    eprintln!(\"[TEST] PASS: Empty buffer handled correctly\");\n}\n\n#[test]\nfn test_measure_consistency_with_render() {\n    let mut buffer = TextBuffer::new();\n    buffer.set_text(\"Line one\\nLine two is longer\\nLine 3\");\n    \n    let view = TextBufferView::new(&buffer);\n    \n    // Measure\n    let (measured_lines, measured_width) = view.measure_for_dimensions(None);\n    \n    eprintln!(\"[TEST] Measured: lines={}, width={}\", measured_lines, measured_width);\n    \n    // Render to buffer and verify dimensions match\n    let mut output = OptimizedBuffer::new(measured_width as u32, measured_lines as u32);\n    view.render_to(&mut output, 0, 0);\n    \n    eprintln!(\"[TEST] Output buffer: {}x{}\", output.width(), output.height());\n    \n    // Find actual content bounds\n    let mut max_col = 0;\n    let mut max_row = 0;\n    for y in 0..output.height() {\n        for x in 0..output.width() {\n            if let Some(cell) = output.get(x, y) {\n                if cell.content.grapheme.is_some() {\n                    max_col = max_col.max(x + 1);\n                    max_row = max_row.max(y + 1);\n                }\n            }\n        }\n    }\n    \n    eprintln!(\"[TEST] Actual content bounds: {}x{}\", max_col, max_row);\n    \n    assert!(max_col <= measured_width as u32);\n    assert!(max_row <= measured_lines as u32);\n    \n    eprintln!(\"[TEST] PASS: Measure and render are consistent\");\n}\n```\n\n## Acceptance Criteria\n- [ ] Returns correct line count for unwrapped text\n- [ ] Returns correct line count for wrapped text\n- [ ] Returns correct max width for all cases\n- [ ] Handles empty buffer (returns 1, 0)\n- [ ] Handles CJK/wide characters correctly\n- [ ] Results are consistent with actual render output\n- [ ] All 8+ unit tests pass with detailed logging\n- [ ] Each test logs expected vs actual dimensions\n\nDependencies:\n  -> bd-2sk (blocks) - TextBufferView Line Info Cache","acceptance_criteria":"- [ ] Returns correct line count for wrapped/unwrapped\n- [ ] Returns correct max width\n- [ ] Works with empty buffer\n- [ ] All 4+ unit tests pass\n\n---","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:19:41.596771328Z","closed_at":"2026-01-19T22:19:41.596727766Z","close_reason":"Added 8 comprehensive tests for measure_for_dimensions: no_wrap, char_wrap, word_wrap, empty_buffer, single_long_line, cjk_content, updates_after_edit, consistency_with_render. All 9 tests pass.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-21g","depends_on_id":"bd-2sk","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-24f","title":"ANSI Cursor Color","description":"## Overview\nAdd OSC 12 cursor color sequence.\n\n## Scope\n```rust\n// In src/ansi/sequences.rs\npub fn cursor_color(r: u8, g: u8, b: u8) -> String {\n    format!(\"\\x1b]12;#{:02x}{:02x}{:02x}\\x07\", r, g, b)\n}\n\npub const CURSOR_COLOR_RESET: &str = \"\\x1b]112\\x07\";\n```\n\n```rust\nimpl Terminal {\n    pub fn set_cursor_color(&mut self, color: Rgba) -> io::Result<()>;\n    pub fn reset_cursor_color(&mut self) -> io::Result<()>;\n}\n```\n\n## Files to Modify\n- src/ansi/sequences.rs - add cursor color function\n- src/terminal/mod.rs - add methods\n\n## Testing Requirements\n\n### Unit Tests (minimum 2 tests)\n- test_cursor_color_sequence\n- test_cursor_color_reset\n\n## Acceptance Criteria\n- [ ] Sequence format is correct\n- [ ] Color conversion works\n- [ ] Unit tests pass","acceptance_criteria":"- [ ] Sequence format is correct\n- [ ] Color conversion works\n- [ ] Unit tests pass\n\n---","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:47:51.628744613Z","closed_at":"2026-01-19T22:47:51.628660424Z","close_reason":"done","compaction_level":0,"original_size":0}
{"id":"bd-25w","title":"Evaluate Event System Enhancement","description":"## Overview\nEvaluate whether the current event system needs enhancement or if it's sufficient as-is.\n\n## Already Implemented (NO WORK NEEDED)\nIn `src/event.rs`:\n- `LogLevel` enum (Debug, Info, Warn, Error) ✓\n- `set_event_callback()` - global event callback ✓\n- `emit_event()` - emit events to callback ✓\n- `set_log_callback()` - global log callback ✓\n- `emit_log()` - emit log messages ✓\n- Thread-safe via `Mutex<Option<...>>` ✓\n- Tests for both callbacks ✓\n\n## Current Design\nThe current implementation uses **global static callbacks** with:\n```rust\ntype EventCallback = Box<dyn Fn(&str, &str) + Send + Sync + 'static>;\ntype LogCallback = Box<dyn Fn(LogLevel, &str) + Send + Sync + 'static>;\n```\n\nThis is simple and sufficient for most use cases.\n\n## Potential Enhancements (EVALUATE NEED)\nThe original bead described an `EventBus` struct with:\n- Multiple handlers via `subscribe()`/`unsubscribe()`\n- `Trace` log level\n- Typed events with `Input`, `TerminalResponse`, `Resize`, `Custom` variants\n\n**Questions to Answer:**\n1. Do users need multiple event handlers?\n2. Is a `Trace` log level needed?\n3. Do we need typed events instead of string-based events?\n4. Is the current simple design causing any issues?\n\n## Recommendation\n**DEFER** this bead unless a specific use case requires the EventBus pattern. The current implementation:\n- Is simpler to use\n- Has lower overhead\n- Is thread-safe\n- Works for the common case (single callback)\n\nIf multiple handlers are needed, they can be implemented at the application level using the single callback.\n\n## If Enhancement is Needed\nOnly implement if there's a concrete use case. Minimal changes would be:\n\n```rust\n// Add Trace level if needed\npub enum LogLevel {\n    Trace,  // ADD\n    Debug,\n    Info,\n    Warn,\n    Error,\n}\n```\n\n## Files to Modify (if needed)\n- src/event.rs - Add Trace level (minimal change)\n\n## Testing Requirements (if implemented)\n```rust\n#[test]\nfn test_log_trace_level() {\n    use std::sync::{Arc, Mutex};\n    \n    let messages = Arc::new(Mutex::new(Vec::new()));\n    let msgs_clone = messages.clone();\n    \n    set_log_callback(move |level, msg| {\n        msgs_clone.lock().unwrap().push((level, msg.to_string()));\n    });\n    \n    emit_log(LogLevel::Trace, \"trace message\");\n    emit_log(LogLevel::Debug, \"debug message\");\n    \n    let msgs = messages.lock().unwrap();\n    eprintln!(\"[TEST] Logged messages: {:?}\", msgs);\n    \n    assert_eq!(msgs.len(), 2);\n    assert_eq!(msgs[0].0, LogLevel::Trace);\n    \n    eprintln!(\"[TEST] PASS: Trace level works\");\n}\n```\n\n## Acceptance Criteria\n- [ ] Evaluate if current implementation is sufficient\n- [ ] If enhancement needed: Add Trace log level\n- [ ] If enhancement needed: Tests pass with logging\n- [ ] Document decision in this bead\n\n## Status\n**Recommend: CLOSE or DEFER** - Current implementation is likely sufficient.","acceptance_criteria":"- [ ] Event handlers can be registered\n- [ ] Events dispatch to all registered handlers\n- [ ] Log callback works with all levels\n- [ ] Thread-safe (Send + Sync)\n- [ ] All 8+ unit tests pass\n\n---","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T21:57:42.198815800Z","closed_at":"2026-01-19T21:57:42.198772037Z","close_reason":"Bead itself recommends CLOSE/DEFER - current event system is sufficient, adding a separate EventSource trait adds complexity without clear benefit","compaction_level":0,"original_size":0}
{"id":"bd-2649","title":"demo_showcase tests: snapshot regression suite (headless JSON -> insta)","description":"# demo_showcase Tests — Snapshot Regression Suite (Headless JSON → insta)\n\n## Purpose\n\nWe want high-confidence regression coverage for the demo app without relying on real terminals.\n\nThis bead adds deterministic snapshot tests that:\n\n- run the demo in headless mode with JSON dump enabled\n- snapshot the JSON via insta\n- log structured context so failures are easy to debug\n\n## Strategy\n\n1) Extend headless mode to support `--headless-dump-json` (see `bd-2el`).\n\n2) Add integration tests that run:\n\n- cargo run --all-features --bin demo_showcase -- --headless-smoke --max-frames 10 --headless-dump-json\n\n3) Parse JSON and snapshot it with insta.\n\n## What To Snapshot\n\nAvoid huge full-frame dumps. Instead snapshot a compact structure such as:\n\n- config summary: theme, fps cap, seed, flags\n- effective capabilities used + headless size used (for debugging / resilience)\n- per-frame stats: dirty cell count, dt\n- sentinel markers:\n  - top bar title string\n  - panel header strings (SIDEBAR, EDITOR, PREVIEW, LOGS)\n  - current section\n  - a few log rows (including one linkified URL)\n  - unicode panel strings (including ZWJ emoji) when that section is rendered\n\nOptionally include a very small ASCII “preview” crop (e.g., top 3 lines) to aid human review.\n\n## Logging\n\n- Use the existing test harness artifact system (`tests/common/harness.rs`) patterns where possible.\n- On snapshot mismatch, print:\n  - reproduction command\n  - stdout/stderr\n  - parsed JSON path that differed (insta usually provides this)\n\n## Acceptance Notes\n\n- Snapshot tests are deterministic across runs.\n- Snapshot failures are actionable and include enough context to fix quickly.","acceptance_criteria":"Done when:\n- `cargo test` runs the insta snapshot suite for demo_showcase headless JSON.\n- The tests invoke `demo_showcase` with `--headless-smoke --headless-dump-json` (and a bounded frame count) and exit 0.\n- Snapshots are deterministic across runs on the same commit.\n- On mismatch, test output includes a reproduction command and captured stdout/stderr (and writes artifacts when `HARNESS_ARTIFACTS=1`).\n- Snapshotted JSON is compact and includes the agreed sentinel markers (panel headers, top bar title, selected section, a few log rows, etc.).","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:47:56.469676213Z","created_by":"ubuntu","updated_at":"2026-01-27T23:16:14.779854791Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","testing"],"dependencies":[{"issue_id":"bd-2649","depends_on_id":"bd-2el","type":"blocks","created_at":"2026-01-27T22:48:24.962574187Z","created_by":"ubuntu"},{"issue_id":"bd-2649","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-01-27T22:47:56.481074985Z","created_by":"ubuntu"}]}
{"id":"bd-26og","title":"demo_showcase features: scissor + opacity nesting showcase (scroll + glass + clip)","description":"# demo_showcase Features — Scissor + Opacity Nesting Showcase (Scroll + Glass + Clip)\n\n## Purpose\n\nScissor and opacity stacks are core OpenTUI primitives. The demo should show them in nested, realistic situations:\n\n- scrollable lists/logs clipped to panel\n- nested clip rects (e.g., list inside a modal)\n- subtree opacity (dim/pause states, glass overlays)\n\n## Requirements\n\n- Sidebar list uses scissor clipping + scroll.\n- Logs panel uses scissor clipping + scroll.\n- At least one overlay (palette/help/tour) contains an internal scroll region clipped by scissor.\n- When focus is lost (or demo is paused), dim the entire app using an opacity stack multiplier.\n\n## Acceptance Notes\n\n- No draw operations “bleed” outside their panels.\n- Nested scissor intersections behave correctly.\n- Opacity stacking produces obvious and attractive compositing.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:28:34.676482903Z","created_by":"ubuntu","updated_at":"2026-01-27T22:32:29.881463790Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","features"],"dependencies":[{"issue_id":"bd-26og","depends_on_id":"bd-1al","type":"blocks","created_at":"2026-01-27T22:32:29.881434565Z","created_by":"ubuntu"},{"issue_id":"bd-26og","depends_on_id":"bd-1fu","type":"blocks","created_at":"2026-01-27T22:32:27.885413903Z","created_by":"ubuntu"},{"issue_id":"bd-26og","depends_on_id":"bd-2c6","type":"blocks","created_at":"2026-01-27T22:32:28.812548353Z","created_by":"ubuntu"},{"issue_id":"bd-26og","depends_on_id":"bd-37p","type":"parent-child","created_at":"2026-01-27T22:28:34.691488706Z","created_by":"ubuntu"}]}
{"id":"bd-29z","title":"[EPIC] demo_showcase: runtime (input loop, resize, frame pacing, rendering)","description":"# Epic: demo_showcase — Runtime + Rendering Pipeline\n\n## Purpose\n\nImplement the reliable “application spine” for the demo:\n\n- Terminal setup / cleanup (alt screen, mouse, cursor)\n- Non-blocking input read + `InputParser`\n- Event dispatch (keyboard/mouse/paste/focus/resize)\n- Resize handling (`renderer.resize`)\n- Frame pacing / animations / time base\n- Render pass orchestration:\n  - background\n  - panel layout + scissoring\n  - overlays (modals, command palette)\n  - debug/perf overlays\n\n## Why This Needs Its Own Epic\n\nThe demo’s *wow factor* will collapse if the runtime stutters, flickers, or breaks on resize.\nThis epic ensures correctness and smoothness first, so later UI beads can focus on content.","acceptance_criteria":"Checklist:\n- [ ] Clean startup/shutdown every time (Drop-safe)\n- [ ] Input loop is non-blocking and robust to partial sequences\n- [ ] Resize updates layout + buffers without panics\n- [ ] Frame pacing is smooth (target 60 FPS, reasonable CPU)\n- [ ] Rendering is layered consistently (panels + overlays + debug)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:04:01.984593516Z","created_by":"ubuntu","updated_at":"2026-01-27T22:04:11.689153365Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","epic","runtime"],"dependencies":[{"issue_id":"bd-29z","depends_on_id":"bd-1co","type":"parent-child","created_at":"2026-01-27T22:04:02.001277094Z","created_by":"ubuntu"}]}
{"id":"bd-2b3","title":"Fix potential integer overflow in buffer size calculations","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-27T16:36:10.348376332Z","created_by":"ubuntu","updated_at":"2026-01-27T16:38:33.940342789Z","closed_at":"2026-01-27T16:38:33.940281014Z","close_reason":"Fixed integer overflow in renderer total_cells calculation using saturating_mul","compaction_level":0,"original_size":0}
{"id":"bd-2bnv","title":"demo_showcase tests: capability + size degradation matrix (headless snapshots)","description":"# demo_showcase Tests — Capability + Size Degradation Matrix (Headless Snapshots)\n\n## Purpose\n\n`bd-1ob` defines resilience rules and capability gating. We need regression coverage that proves:\n\n- the demo stays usable across constrained terminals\n- the *same* constraints continue to work as the demo evolves\n\nThis bead adds a matrix of deterministic headless runs that snapshot the demo’s JSON dump across:\n\n- multiple terminal sizes (including \"too small\" -> compact layout)\n- multiple capability presets (no truecolor / no hyperlinks / no mouse / minimal)\n\n## Prerequisites / Contract\n\nThis bead assumes headless mode supports:\n\n- `--headless-dump-json`\n- `--headless-size <WxH>` (or equivalent) to force a specific buffer size\n- `--cap-preset <name>` (or equivalent) to force effective capability flags used by gating\n\nThe JSON output must include (at minimum):\n\n- effective capabilities actually used by the demo (after overrides)\n- selected layout mode (full vs compact)\n- a small set of sentinel markers (panel headers, mode, warnings)\n\n## Matrix (Initial)\n\nRun and snapshot these scenarios (exact names can evolve, but keep the set stable):\n\n1) `ideal_120x40`\n   - size: 120x40\n   - cap preset: ideal/auto\n\n2) `no_truecolor_120x40`\n   - size: 120x40\n   - cap preset: no_truecolor\n\n3) `no_hyperlinks_120x40`\n   - size: 120x40\n   - cap preset: no_hyperlinks\n\n4) `no_mouse_120x40`\n   - size: 120x40\n   - cap preset: no_mouse\n\n5) `minimal_80x24`\n   - size: 80x24\n   - cap preset: minimal\n\n6) `tiny_50x15`\n   - size: 50x15\n   - cap preset: minimal\n   - expectation: compact layout triggers\n\n## Assertions (Beyond Snapshots)\n\nFor each scenario, assert simple invariants in addition to insta snapshots:\n\n- process exits 0\n- JSON includes `warnings` when capabilities are missing\n- `tiny_50x15` reports compact layout active\n- hyperlink markers are absent when cap preset disables hyperlinks\n\n## Logging / Artifacts\n\nOn failure:\n\n- print exact reproduction command\n- store JSON and stdout/stderr as artifacts when `HARNESS_ARTIFACTS=1`\n\n## Why This Matters\n\nCapability regressions are the most common way for demos to feel \"broken\" on someone else’s machine.\nThis matrix makes resilience an enforced property.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T23:10:28.188432073Z","created_by":"ubuntu","updated_at":"2026-01-27T23:10:28.217693805Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","resilience","testing"],"dependencies":[{"issue_id":"bd-2bnv","depends_on_id":"bd-1ob","type":"blocks","created_at":"2026-01-27T23:10:28.213975224Z","created_by":"ubuntu"},{"issue_id":"bd-2bnv","depends_on_id":"bd-2649","type":"blocks","created_at":"2026-01-27T23:10:28.217677885Z","created_by":"ubuntu"},{"issue_id":"bd-2bnv","depends_on_id":"bd-2el","type":"blocks","created_at":"2026-01-27T23:10:28.210212961Z","created_by":"ubuntu"},{"issue_id":"bd-2bnv","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-01-27T23:10:28.206280571Z","created_by":"ubuntu"}]}
{"id":"bd-2c6","title":"demo_showcase UI: logs panel (event stream + hyperlink styling + scroll)","description":"# demo_showcase UI — Logs Panel (Events + Hyperlinks)\n\n## Purpose\n\nLogs panel provides:\n\n- “real app” texture\n- proof of styled text + colors\n- proof of hyperlinks via OSC 8 (`LinkPool`)\n- proof of scroll + scissor clipping\n\n## Content\n\n- Deterministic log stream derived from time\n- Levels: INFO/WARN/ERROR with distinct styling\n- A few special rows that contain a URL and are rendered as a hyperlink\n\n## Hyperlink Strategy\n\n- Allocate URL ids from `renderer.link_pool()`\n- Apply `Style::fg(...).with_underline().with_link(link_id)` to the cell range\n\nNote: terminals handle click-to-open; we still render pressed/hover state visually.\n\n## Interaction\n\n- Scroll wheel scrolls logs when hovered\n- Click a row to select it\n- Selected row shows details in a small “inspector” area (or toast)","acceptance_criteria":"Checklist:\n- [ ] Logs render with level styling and timestamps\n- [ ] Panel scrolls and clips correctly\n- [ ] At least one OSC 8 hyperlink is rendered\n- [ ] Clicking a row selects it (HitGrid)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:14:21.206857206Z","created_by":"ubuntu","updated_at":"2026-01-27T22:33:28.336410055Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","ui"],"dependencies":[{"issue_id":"bd-2c6","depends_on_id":"bd-1pd","type":"blocks","created_at":"2026-01-27T22:31:56.725549700Z","created_by":"ubuntu"},{"issue_id":"bd-2c6","depends_on_id":"bd-35g","type":"blocks","created_at":"2026-01-27T22:31:57.283113630Z","created_by":"ubuntu"},{"issue_id":"bd-2c6","depends_on_id":"bd-3ii","type":"blocks","created_at":"2026-01-27T22:33:19.154424991Z","created_by":"ubuntu"},{"issue_id":"bd-2c6","depends_on_id":"bd-c75","type":"parent-child","created_at":"2026-01-27T22:14:21.233835087Z","created_by":"ubuntu"},{"issue_id":"bd-2c6","depends_on_id":"bd-hc0","type":"blocks","created_at":"2026-01-27T22:33:23.195606978Z","created_by":"ubuntu"},{"issue_id":"bd-2c6","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:33:28.336381372Z","created_by":"ubuntu"}]}
{"id":"bd-2el","title":"demo_showcase runtime: headless smoke mode (no TTY, render-to-memory, exit 0)","description":"# demo_showcase Runtime — Headless Smoke Mode (No TTY, Render-to-Memory, Exit 0)\n\n## Purpose\n\nWe want a CI-friendly way to validate that the demo binary:\n\n- compiles\n- can construct its app state\n- can execute its render pipeline\n\n…without requiring a real terminal.\n\nThis enables deterministic tests, fast iteration, and regression snapshots.\n\n## Behavior\n\nPrimary flag:\n\n- --headless-smoke\n\nWhen enabled:\n\n- do not enter alt screen\n- do not enable raw mode\n- do not attempt mouse tracking\n- build App + DemoContent\n- render into an in-memory OptimizedBuffer\n- exercise diff computation between frames (via BufferDiff::compute) to prove the diff path\n- exit 0 if all frames render without panic\n\n## Frame Count / Termination Rules\n\nThere are two headless execution modes:\n\n### A) Plain headless smoke (no tour)\n\n- default: run a small fixed N frames (fast in CI)\n- if `--max-frames <N>` is provided, use that as the frame count\n\n### B) Headless tour run (`--tour`)\n\n- default: run until the tour script completes, then exit 0\n  - (implementation can be \"fast\" by advancing time deterministically without sleeping)\n- if `--max-frames <N>` is provided, treat it as a hard safety bound:\n  - exit 0 only if tour completed within N frames\n  - otherwise exit non-zero with a clear error\n\nThis avoids forcing tests to guess the number of frames required to finish a tour.\n\n## Size + Capability Control (For Matrix Testing)\n\n- `--headless-size <WxH>` forces the headless buffer size (default 80x24)\n- `--cap-preset <name>` defines the effective capabilities used by gating and rendering decisions\n\n## Tour Integration\n\n- If --tour is set, headless mode executes the tour script deterministically.\n- Tour step markers must be included in the JSON dump.\n\n## Output Contract (For Tests)\n\nHeadless mode must print a stable, parseable summary line to stdout so integration tests can assert success without guessing:\n\n- HEADLESS_SMOKE_OK frames=<N> last_dirty_cells=<K>\n\nStructured dump (recommended for deeper tests):\n\n- --headless-dump-json\n\nWhen enabled, print JSON to stdout containing (minimum):\n\n- config summary (theme, fps cap, seed, flags)\n- effective capabilities used (after cap preset / gating)\n- headless size used (WxH)\n- selected layout mode (full vs compact)\n- warnings list (e.g., \"no_truecolor\", \"no_mouse\", \"no_hyperlinks\")\n- per-frame stats (dirty cell count, dt)\n- sentinel markers proving panels rendered (top bar title, panel headers, current section)\n- tour step markers (if tour enabled)\n\nAvoid dumping the full buffer unless explicitly requested (too large for CI logs).\n\n## Implementation Notes\n\nThis likely requires the demo’s render pipeline to be factored into a pure function:\n\n- fn render_frame(app, layout, buffer, pool, links, now)\n\nRenderer I/O should be a thin wrapper around that.\n\n## Acceptance Notes\n\n- `cargo run --bin demo_showcase -- --headless-smoke` works in non-TTY CI environments.\n- Results are deterministic across runs.\n- Output contains HEADLESS_SMOKE_OK on success.\n- JSON schema includes the fields required by `bd-2649` and `bd-2bnv`.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:26:05.942661331Z","created_by":"ubuntu","updated_at":"2026-01-27T23:14:15.190926432Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","runtime","testing"],"dependencies":[{"issue_id":"bd-2el","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:26:05.964184936Z","created_by":"ubuntu"},{"issue_id":"bd-2el","depends_on_id":"bd-2iv","type":"blocks","created_at":"2026-01-27T22:32:12.868058851Z","created_by":"ubuntu"},{"issue_id":"bd-2el","depends_on_id":"bd-35g","type":"blocks","created_at":"2026-01-27T22:32:14.567529855Z","created_by":"ubuntu"},{"issue_id":"bd-2el","depends_on_id":"bd-hc0","type":"blocks","created_at":"2026-01-27T22:32:14.001649143Z","created_by":"ubuntu"},{"issue_id":"bd-2el","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:32:13.424913256Z","created_by":"ubuntu"}]}
{"id":"bd-2ib","title":"Improve render_to/render_to_with_pool documentation","description":"The render_to() method creates placeholders for multi-codepoint graphemes when no pool is available. This behavior is intentional but not well documented. Tasks: (1) Add doc comments to render_to() warning about placeholder behavior, (2) Add doc comments to render_to_with_pool() explaining when to use it, (3) Consider adding example usage in README. See test test_render_emoji_produces_placeholder and test_render_emoji_with_pool.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-27T17:40:47.761765989Z","created_by":"ubuntu","updated_at":"2026-01-27T17:41:45.133867508Z","closed_at":"2026-01-27T17:41:45.133807647Z","close_reason":"Documentation already in place - render_to() and render_to_with_pool() both have comprehensive doc comments explaining grapheme handling behavior, when to use each method, and includes a code example.","compaction_level":0,"original_size":0}
{"id":"bd-2iv","title":"demo_showcase runtime: CLI args + Config (modes, toggles, fps cap)","description":"# demo_showcase Runtime — CLI Args + Config\n\n## Purpose\n\nProvide a minimal, dependency-free CLI surface so the demo is easy to run in different modes (interactive, tour, headless testing) while staying deterministic.\n\n## Constraints\n\n- No new deps for CLI parsing.\n- Keep parsing strict and predictable.\n- Default behavior must be deterministic (no time-based randomness).\n\n## Proposed Flags\n\nCore interactive flags:\n\n- --help: print usage\n- --tour: start tour mode immediately\n- --fps <N>: cap FPS (sleep to maintain)\n- --no-mouse: don’t enable mouse tracking\n- --no-alt-screen: don’t enter alt screen\n- --no-cap-queries: skip capability queries\n\nDeterministic termination controls (critical for E2E + recordings):\n\n- --max-frames <N>: hard frame budget; exit 0 after presenting N frames\n- --exit-after-tour: when tour reaches the last step, exit 0 automatically\n\nHeadless/testing flags:\n\n- --headless-smoke: run a deterministic headless render sequence and exit\n- --headless-dump-json: dump structured JSON (for snapshots/regressions)\n- --headless-check <name>: run a specific deterministic check and exit (layout/palette/hitgrid…)\n- --headless-size <WxH>: force the headless buffer size (default 80x24)\n\nCapability override (for matrix tests + debugging):\n\n- --cap-preset <name>\n  - allowed (initial): auto | ideal | no_truecolor | no_hyperlinks | no_mouse | minimal\n  - semantics:\n    - interactive (TTY): preset can only DISABLE capabilities (effective = detected ∩ preset)\n    - headless: preset defines the effective capabilities directly\n\nOptional/advanced:\n\n- --seed <N>: deterministic parameterization for animations (optional)\n- --threaded: use ThreadedRenderer backend (optional)\n\n## Determinism Rules\n\n- Default seed is a fixed constant (e.g., 0).\n- Never default to using time for seed.\n- Tour mode must be deterministic regardless of seed (either force seed=0, or make tour steps independent of seed).\n\n## Config Shape\n\nExample:\n\nstruct Config {\n    start_in_tour: bool,\n    fps_cap: Option<u32>,\n    enable_mouse: bool,\n    use_alt_screen: bool,\n    query_capabilities: bool,\n\n    // Deterministic termination\n    max_frames: Option<u64>,\n    exit_after_tour: bool,\n\n    // Headless/test\n    headless_smoke: bool,\n    headless_dump_json: bool,\n    headless_check: Option<String>,\n    headless_size: Option<(u16, u16)>,\n\n    // Capability override\n    cap_preset: Option<CapPreset>,\n\n    // Advanced\n    threaded: bool,\n    seed: u64,\n}\n\nimpl Config {\n    fn renderer_options(&self) -> RendererOptions { ... }\n}\n\n## Notes\n\n- Run-loop semantics for `--max-frames` and `--exit-after-tour` are tracked in `bd-3vjm`.\n- The primary consumer of `--cap-preset` + `--headless-size` is the degradation matrix suite in `bd-2bnv`.","acceptance_criteria":"Checklist:\n- [ ] `demo_showcase --help` prints usage\n- [ ] Flags parsed without external deps\n- [ ] `Config` cleanly maps into `RendererOptions`\n- [ ] `--headless-smoke` works without a TTY","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:08:45.760572467Z","created_by":"ubuntu","updated_at":"2026-01-27T23:11:19.726389729Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","runtime"],"dependencies":[{"issue_id":"bd-2iv","depends_on_id":"bd-1i7","type":"blocks","created_at":"2026-01-27T22:33:14.034409174Z","created_by":"ubuntu"},{"issue_id":"bd-2iv","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:08:45.773427812Z","created_by":"ubuntu"},{"issue_id":"bd-2iv","depends_on_id":"bd-z1b","type":"blocks","created_at":"2026-01-27T22:11:42.537129324Z","created_by":"ubuntu"}]}
{"id":"bd-2jc","title":"[EPIC] demo_showcase: product spec, UX, and tour script","description":"# Epic: demo_showcase — Product Spec, UX, and “Tour Mode” Script\n\n## Purpose\n\nBefore we write a large flagship demo, we lock a **cohesive product story** so implementation doesn’t devolve into a random pile of feature snippets.\n\nThis epic defines:\n\n- The *app concept* (what kind of “realistic app” this is pretending to be)\n- The information architecture (panels, navigation, overlays)\n- The interaction model (keyboard + mouse, focus rules)\n- The visual design system (palette, typography, spacing)\n- A deterministic **tour script** that can auto-drive the UI (for demos/videos)\n\n## Constraints (From Project Philosophy)\n\n- OpenTUI is a **rendering engine**, not a framework. This demo must not introduce a widget tree/layout system into the library.\n- The demo should rely on OpenTUI primitives: buffers, cells, styles, scissor/opacity, diff rendering.\n\n## Outputs\n\n- A detailed spec embedded directly into the child beads under this epic.\n- A stable keybinding map and “tour steps” list that other beads can reference.","acceptance_criteria":"Checklist:\n- [ ] The demo’s screens/panels are explicitly defined (what appears where)\n- [ ] Keybindings and mouse behaviors are explicitly defined\n- [ ] A deterministic tour script is specified (step-by-step)\n- [ ] A visual design system (colors/styles) is specified\n- [ ] Clear success criteria for “polish” are defined (what good looks like)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:03:43.707648876Z","created_by":"ubuntu","updated_at":"2026-01-27T22:03:55.305694849Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","design","epic"],"dependencies":[{"issue_id":"bd-2jc","depends_on_id":"bd-1co","type":"parent-child","created_at":"2026-01-27T22:03:43.727602281Z","created_by":"ubuntu"}]}
{"id":"bd-2kgg","title":"demo_showcase features: diff rendering + sync output prove-out (stats + invalidate)","description":"# demo_showcase Features — Diff Rendering + Sync Output Prove‑Out (Stats + Invalidate)\n\n## Purpose\n\nOpenTUI’s biggest performance claim is diff-based rendering (only changed cells output) and synchronized output to eliminate flicker.\n\nThis bead ensures the demo makes that visible.\n\n## Requirements\n\n- The inspector/perf panel must show:\n  - `cells updated` last frame\n  - an estimate of bytes written (if available)\n  - whether sync output is active\n\n- Provide a UI control or keybind to:\n  - force a full redraw (`Renderer::invalidate()` then `present()`)\n  - toggle the debug overlay\n\n- In tour mode, include a step that:\n  - triggers a full redraw\n  - then returns to normal diff mode\n\n## Acceptance Notes\n\n- Viewer can see “small updates” vs “full redraw” reflected in stats.\n- Sync output capability is reported accurately and is enabled when supported.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:28:51.600548455Z","created_by":"ubuntu","updated_at":"2026-01-27T22:55:19.205274066Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","features","perf"],"dependencies":[{"issue_id":"bd-2kgg","depends_on_id":"bd-1t2","type":"blocks","created_at":"2026-01-27T22:32:30.860276835Z","created_by":"ubuntu"},{"issue_id":"bd-2kgg","depends_on_id":"bd-37p","type":"parent-child","created_at":"2026-01-27T22:28:51.615070887Z","created_by":"ubuntu"},{"issue_id":"bd-2kgg","depends_on_id":"bd-pnln","type":"blocks","created_at":"2026-01-27T22:55:19.205239933Z","created_by":"ubuntu"},{"issue_id":"bd-2kgg","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:32:31.884378092Z","created_by":"ubuntu"}]}
{"id":"bd-2lx","title":"Add comprehensive doc comments to public API types","description":"The lib.rs has clippy::missing_errors_doc and clippy::missing_panics_doc allowed with 'Docs WIP' comments. Add documentation to core types (Rgba, Cell, Style), Buffer, Renderer, Text, Input, and Terminal modules. Focus on doc comments with examples.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T20:28:37.918848027Z","created_by":"ubuntu","updated_at":"2026-01-21T20:39:34.372249544Z","closed_at":"2026-01-21T20:39:34.372203978Z","close_reason":"Added comprehensive documentation to core public API types (Rgba, Cell, Style, OptimizedBuffer, Renderer) with module-level docs, struct-level docs, and 6 runnable doctest examples.","compaction_level":0,"original_size":0}
{"id":"bd-2mu","title":"demo_showcase spec: app concept + panel layout wireframe","description":"# demo_showcase Spec — App Concept + Panel Layout Wireframe\n\n## App Concept (The “Realistic” Story)\n\nThe demo app presents itself as a **Developer Workbench**:\n\n- You’re looking at a project\n- You’re editing a file\n- You have a live preview/inspector\n- You have logs/notifications and quick actions\n\nThis is believable, and it naturally uses all OpenTUI primitives.\n\n## Core Screen Layout (Baseline)\n\nSingle-screen layout with persistent chrome:\n\n- **Top bar**: brand, mode, time, quick actions (clickable)\n- **Sidebar** (left): navigation list (scrollable + clipped)\n- **Main editor** (center): `EditorView` (highlighting, selection)\n- **Preview** (right): pixel/charts + “compositing” demos\n- **Bottom status bar**: key hints + stats\n- **Toast area**: transient notifications\n\n### ASCII Wireframe\n\n```\n┌────────────────────────────────────────────────────────────────────────────┐\n│  OpenTUI Showcase      Project: opentui_rust      Mode: Normal     22:05   │\n├───────────────┬───────────────────────────────────────────┬───────────────┤\n│ Sidebar       │ Editor                                    │ Preview       │\n│ (scroll)      │ (rope + undo + highlight)                 │ (pixels)      │\n│               │                                           │ (charts)      │\n│  • Overview   │  fn main() {                              │   ███░░       │\n│  • Editor     │      println!(\"hello\");                   │   ▜▛▌▐        │\n│  • Preview    │  }                                        │               │\n│  • Logs       │                                           │  Alpha blend  │\n│  • Unicode    │                                           │  Scissor clip │\n│               │                                           │               │\n├───────────────┴───────────────────────────────────────────┴───────────────┤\n│  F1 Help  Ctrl+P Command  Ctrl+T Tour  Ctrl+Q Quit   FPS:60  Cells:123     │\n└────────────────────────────────────────────────────────────────────────────┘\n```\n\n## Overlay Screens\n\nOverlays (semi-transparent, “glass”):\n\n- **Command palette** (Ctrl+P): fuzzy-ish list + preview\n- **Help overlay** (F1): keybinds + feature legend\n- **Tour overlay** (Ctrl+T): step title + next action\n\nOverlays should use:\n- `push_opacity()` + blended background rectangles\n- scissor clipping for internal list scroll\n\n## Layout Rules\n\n- Everything is manual rectangles (OpenTUI is not a layout engine).\n- Each panel computes a `Rect { x,y,w,h }`.\n- Panels are clipped to their rect via scissor stack.\n- Borders/headers are drawn with box styles + subtle gradients.\n\n## What This Bead Produces\n\n- A stable “screen map” other beads can implement against.\n- A list of required panels and what each panel must demonstrate.","acceptance_criteria":"Checklist:\n- [ ] Baseline layout defined (top/sidebar/editor/preview/logs/status)\n- [ ] Overlays defined (help, command palette, tour)\n- [ ] Each region has explicit responsibilities + feature coverage\n- [ ] Layout rules for clipping/scrolling are specified","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:05:14.680066085Z","created_by":"ubuntu","updated_at":"2026-01-27T22:05:34.677537082Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","design"],"dependencies":[{"issue_id":"bd-2mu","depends_on_id":"bd-2jc","type":"parent-child","created_at":"2026-01-27T22:05:14.692986102Z","created_by":"ubuntu"}]}
{"id":"bd-2po","title":"Add doctest examples to key public types","description":"Add runnable doctest examples to demonstrate usage of: Rgba (creation, blending), OptimizedBuffer (drawing, scissoring), Style (building styled text), TextBuffer/EditBuffer (text editing with undo).","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T20:28:47.977865230Z","created_by":"ubuntu","updated_at":"2026-01-21T21:17:12.745449530Z","closed_at":"2026-01-21T21:17:12.745393465Z","close_reason":"Added doctest examples to TextBuffer and EditBuffer showing basic usage, cursor movement, and undo/redo functionality. Total 9 doctests now pass.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2po","depends_on_id":"bd-2lx","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg","title":"Port completion: close remaining spec gaps and verify parity","description":"Umbrella epic to drive OpenTUI Rust to full spec parity with the Zig core. This captures the remaining intentional deviations and missing features (grapheme pool, threaded renderer, attribute packing for link IDs) plus conformance verification, docs, and QA. Goal: remove all known deviations or explicitly re‑spec them, then prove with conformance fixtures + tests + benchmarks.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-25T00:01:49.281944996Z","created_by":"ubuntu","updated_at":"2026-01-25T11:39:38.082662420Z","closed_at":"2026-01-25T11:39:38.082644196Z","close_reason":"All parity tasks + docs/QA complete","compaction_level":0,"original_size":0,"comments":[{"id":1,"issue_id":"bd-2qg","author":"Dicklesworthstone","text":"This epic is the authoritative roadmap to reach full Zig-core parity.\n\nKnown gaps when created:\n- Grapheme pool encoding + refcounting (Zig uses 24-bit pool IDs + width bits; Rust uses Arc<str>).\n- Link IDs packed into TextAttributes (bits 8–31) vs separate link_id field in Rust.\n- Threaded renderer missing in Rust.\n- Conformance fixtures lack a reproducible legacy capture tool.\n\nSuccess criteria:\n- All spec-required features implemented (no deviations).\n- Fixtures regenerated from legacy tool and Rust passes all conformance + unit + e2e tests.\n- QA (fmt/clippy/tests/bench) is clean and docs updated to 100% parity.","created_at":"2026-01-25T00:41:51Z"}]}
{"id":"bd-2qg.1","title":"Parity decision record: confirm spec alignment for grapheme pool, link-id packing, threaded renderer","description":"Background: Current Rust port has documented deviations in FEATURE_PARITY.md (Arc<str> graphemes, no threaded renderer, link_id stored separately from TextAttributes). Before implementing, produce a concise decision record that confirms these MUST match Zig spec (not remain intentional deviations). Include: (1) target behavior per EXISTING_OPENTUI_STRUCTURE.md, (2) API impact on Rust (public types, breaking changes), (3) migration strategy for existing tests/fixtures, (4) accept/reject criteria for parity. This self-contained record should let future work proceed without re-reading plan docs.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:01:57.798833759Z","created_by":"ubuntu","updated_at":"2026-01-25T01:15:23.412140989Z","closed_at":"2026-01-25T01:15:23.412123647Z","close_reason":"Completed","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.1","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":2,"issue_id":"bd-2qg.1","author":"Dicklesworthstone","text":"Purpose: freeze parity decisions so downstream work is unblocked and consistent.\nThis bead owns the go/no-go on each deviation (grapheme pool, link-id packing, threaded renderer) and must explicitly state whether we are matching Zig spec or intentionally diverging.\nNo implementation should start until these decisions are recorded.","created_at":"2026-01-25T00:41:59Z"}]}
{"id":"bd-2qg.1.1","title":"Decision: Grapheme pool must match Zig encoding (high-bit + width bits + 24-bit ID)","description":"Background:\n- Current Rust uses Arc<str> for CellContent::Grapheme. Zig spec uses a refcounted grapheme pool with a 24-bit ID encoded into the cell char value; width is stored in bits 24–30, high bit marks grapheme.\n\nGoal:\n- Decide and record whether Rust MUST implement Zig-style grapheme pool encoding for parity or can remain Arc<str>.\n\nAcceptance criteria:\n- Decision recorded with explicit reasoning and impact: performance, memory, API changes, test/fixture implications.\n- If parity required, list precise encoding rules and invariants (bit layout, width constraints, ID range).\n\nNotes for future self:\n- This decision gates all grapheme pool implementation tasks; do not proceed with pool implementation until this is decided.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:36:52.519305855Z","created_by":"ubuntu","updated_at":"2026-01-25T05:05:04.269351394Z","closed_at":"2026-01-25T05:05:04.269331837Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.1.1","depends_on_id":"bd-2qg.1","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.1.2","title":"Decision: Link ID packing into TextAttributes (bits 8–31)","description":"Background:\n- Zig spec packs link ID into attributes (lower 8 bits flags, upper 24 bits link ID). Rust currently stores link_id separately on Cell/Style.\n\nGoal:\n- Decide required parity approach: packed attributes vs separate field + adapter.\n\nAcceptance criteria:\n- Decision recorded with precise bit layout and accessor API (get/set link id) if packing is required.\n- Document public API impact (Style builder, Cell structure, TextAttributes type width) and migration steps for tests/examples.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:37:00.474637179Z","created_by":"ubuntu","updated_at":"2026-01-25T05:05:24.578132522Z","closed_at":"2026-01-25T05:05:24.578113987Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.1.2","depends_on_id":"bd-2qg.1","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.1.3","title":"Decision: Threaded renderer parity requirement","description":"Background:\n- FEATURE_PARITY.md lists threaded renderer as missing; Zig has render thread support. Rust Renderer is single-threaded and !Send due to stdout ownership.\n\nGoal:\n- Decide whether threaded rendering is a required parity feature for this port.\n\nAcceptance criteria:\n- Decision recorded with desired API shape (if required), performance rationale, and constraints (Terminal cleanup on thread exit, sync-output correctness).\n- Explicit go/no-go so downstream implementation tasks are unblocked.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:37:07.521726565Z","created_by":"ubuntu","updated_at":"2026-01-25T05:05:35.834448268Z","closed_at":"2026-01-25T05:05:35.834429763Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.1.3","depends_on_id":"bd-2qg.1","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.10","title":"Build legacy reference capture harness for conformance fixtures","description":"Background:\n- Current conformance fixtures are static and not reproducibly generated.\n- We need a legacy capture tool to establish an authoritative source of truth.\n\nGoal:\n- Create a deterministic capture harness against legacy OpenTUI that writes the canonical fixtures JSON.\n- Record legacy version/commit and exact commands so future runs are reproducible.\n\nAcceptance criteria:\n- A capture tool exists, documented, and produces fixtures consumed by tests/conformance.rs without manual edits.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:03:07.744072415Z","created_by":"ubuntu","updated_at":"2026-01-25T09:53:03.036293967Z","closed_at":"2026-01-25T09:53:03.036275933Z","close_reason":"Capture CLI + docs complete; fixtures regenerated via legacy capture","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.10","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.10","depends_on_id":"bd-2qg.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":3,"issue_id":"bd-2qg.10","author":"Dicklesworthstone","text":"Purpose: make conformance fixtures reproducible by providing a legacy capture tool.\nWithout this, fixtures are opaque and parity claims are weaker.\nThis bead establishes the capture pipeline and documentation.","created_at":"2026-01-25T00:43:05Z"}]}
{"id":"bd-2qg.10.1","title":"Define fixture schema + categories for legacy capture","description":"Scope:\n- Specify JSON schema for fixtures (crate/version/captured_at + tests[]).\n- Enumerate required categories: color, buffer, text, input, ansi, unicode, plus new grapheme cases.\n\nAcceptance criteria:\n- Schema documented and aligns with tests/conformance.rs expectations.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:40:16.093856338Z","created_by":"ubuntu","updated_at":"2026-01-25T04:49:43.046677812Z","closed_at":"2026-01-25T04:49:43.046659548Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.10.1","depends_on_id":"bd-2qg.10","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.10.2","title":"Implement capture CLI in legacy_opentui (deterministic output)","description":"Scope:\n- Implement a minimal legacy capture program that runs the core API tests and writes fixtures.\n- Pin the legacy commit/hash used for capture; include the exact command.\n\nAcceptance criteria:\n- Capture CLI is reproducible, deterministic, and produces fixtures that the Rust conformance tests can consume.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:40:23.039805707Z","created_by":"ubuntu","updated_at":"2026-01-25T06:43:57.032410733Z","closed_at":"2026-01-25T06:43:57.032170781Z","close_reason":"Implemented legacy capture CLI, built zig lib with Zig 0.15.2, ran capture with --lib-path","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.10.2","depends_on_id":"bd-2qg.10","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.10.2","depends_on_id":"bd-2qg.10.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.10.3","title":"Doc: how to regenerate fixtures from legacy","description":"Scope:\n- Document the precise steps and commands to regenerate fixtures (including legacy version).\n\nAcceptance criteria:\n- A future maintainer can re-run the capture without reading any other docs.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:40:29.640437944Z","created_by":"ubuntu","updated_at":"2026-01-25T09:51:05.602482305Z","closed_at":"2026-01-25T09:51:05.602464451Z","close_reason":"Documented legacy fixture regeneration steps in docs/TEST_HARNESS.md","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.10.3","depends_on_id":"bd-2qg.10","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.10.3","depends_on_id":"bd-2qg.10.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.11","title":"Regenerate conformance fixtures from legacy and update expectations","description":"Use the new legacy capture harness to regenerate fixtures and verify that Rust outputs match. Add workflow notes (exact commands, legacy commit hash). If discrepancies appear, resolve by updating Rust implementation or documenting intentional divergence. Keep fixtures deterministic and stable across runs.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:03:19.520656435Z","created_by":"ubuntu","updated_at":"2026-01-25T09:55:12.731211370Z","closed_at":"2026-01-25T09:55:12.731194098Z","close_reason":"Legacy capture completed, fixtures diff clean, docs updated with commands + commit hash","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.11","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.11","depends_on_id":"bd-2qg.10","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.11","depends_on_id":"bd-2qg.4","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.11","depends_on_id":"bd-2qg.7","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":4,"issue_id":"bd-2qg.11","author":"Dicklesworthstone","text":"Purpose: regenerate fixtures from the legacy capture and reconcile differences.\nAny mismatches must be resolved via Rust fixes or explicit, documented divergence.\nEnd state: fixtures reflect authoritative legacy behavior and Rust matches.","created_at":"2026-01-25T00:43:11Z"}]}
{"id":"bd-2qg.11.1","title":"Run legacy capture and diff fixtures","description":"Scope:\n- Execute capture harness; diff generated fixtures vs current.\n- Record deltas and categorize (Rust bug vs fixture update).\n\nAcceptance criteria:\n- A diff report is recorded and used to drive fixes.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:40:38.790589247Z","created_by":"ubuntu","updated_at":"2026-01-25T09:54:10.564842947Z","closed_at":"2026-01-25T09:54:10.564824582Z","close_reason":"Legacy capture run; fixtures diff clean (no changes)","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.11.1","depends_on_id":"bd-2qg.11","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.11.2","title":"Resolve mismatches (code fixes or documented intentional differences)","description":"Scope:\n- For each diff, either fix Rust implementation or explicitly document intentional divergence.\n\nAcceptance criteria:\n- No unexplained diffs remain; fixtures match final expected behavior.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:40:47.154130485Z","created_by":"ubuntu","updated_at":"2026-01-25T15:23:10.422963892Z","closed_at":"2026-01-25T15:23:10.422946520Z","close_reason":"All 81 conformance fixtures now pass","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.11.2","depends_on_id":"bd-2qg.11","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.11.2","depends_on_id":"bd-2qg.11.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.12","title":"Full QA: fmt, clippy, tests, benchmarks, and regression check","description":"Scope: run required quality gates after all feature work AND E2E coverage.\nIncludes fmt, clippy (pedantic + nursery), unit tests, conformance tests, E2E tests, and benchmarks.\nHandle Cargo lock contention by waiting/retrying; record final outputs in bead comments.\n\nAcceptance criteria:\n- All checks pass with zero warnings.\n- E2E logs/artifacts are generated and, on failure, are sufficient for diagnosis.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:03:26.739563520Z","created_by":"ubuntu","updated_at":"2026-01-25T10:24:56.872452196Z","closed_at":"2026-01-25T10:22:10.832892208Z","close_reason":"QA complete: cargo check/clippy/fmt/test all passing; conformance + e2e tests pass; ran cargo bench --bench buffer","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.12","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.12","depends_on_id":"bd-2qg.11","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.12","depends_on_id":"bd-2qg.14","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.12","depends_on_id":"bd-2qg.6","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.12","depends_on_id":"bd-2qg.7","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.12","depends_on_id":"bd-2qg.9","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":5,"issue_id":"bd-2qg.12","author":"Dicklesworthstone","text":"Purpose: run the required quality gates after all feature work.\nIncludes fmt, clippy (pedantic + nursery), tests, and benchmarks.\nLock contention is expected in shared environments; record retries and final results.","created_at":"2026-01-25T00:43:19Z"},{"id":6,"issue_id":"bd-2qg.12","author":"Dicklesworthstone","text":"Bench (cargo bench --bench buffer): buffer_new_80x24 ~1.75 us, buffer_new_200x50 ~9.02 us, buffer_clear ~9.08 us, buffer_draw_text_short ~461 ns, buffer_draw_text_long ~3.52 us, buffer_set_cell ~4.55 ns, buffer_get_cell ~234 ps","created_at":"2026-01-25T10:24:56Z"}]}
{"id":"bd-2qg.12.1","title":"Run fmt + clippy + tests with lock handling","description":"Scope:\n- Run cargo fmt --check, cargo clippy --all-targets -- -D warnings, cargo test.\n- Handle Cargo lock contention (wait/retry) and record final results.\n\nAcceptance criteria:\n- All checks pass; outputs recorded in bead comments for future reference.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:40:57.160424104Z","created_by":"ubuntu","updated_at":"2026-01-25T10:22:00.559937081Z","closed_at":"2026-01-25T10:22:00.559908237Z","close_reason":"Ran cargo check --all-targets, cargo clippy --all-targets -- -D warnings, cargo fmt --check, and cargo test (all passing)","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.12.1","depends_on_id":"bd-2qg.12","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.12.2","title":"Benchmarks + regression notes","description":"Scope:\n- Run cargo bench (buffer + other benches) and compare to previous baseline if available.\n- Note any regressions introduced by grapheme pool or threaded renderer changes.\n\nAcceptance criteria:\n- Bench results recorded; regressions resolved or explicitly accepted with justification.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:41:05.631039562Z","created_by":"ubuntu","updated_at":"2026-01-25T10:22:05.433255967Z","closed_at":"2026-01-25T10:22:05.433238424Z","close_reason":"Ran cargo bench --bench buffer (all benchmarks completed)","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.12.2","depends_on_id":"bd-2qg.12","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.12.2","depends_on_id":"bd-2qg.12.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.13","title":"Documentation sweep: update FEATURE_PARITY and design docs to reflect final state","description":"Once gaps are closed, update FEATURE_PARITY.md to 100% and remove deviation notes. Update EXISTING_OPENTUI_STRUCTURE.md or PROPOSED_RUST_ARCHITECTURE.md only if implementation diverged. Add release notes in UPGRADE_LOG.md if API changes (e.g., link-id packing). Ensure README examples still compile.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T00:03:34.814233967Z","created_by":"ubuntu","updated_at":"2026-01-25T11:39:28.235388408Z","closed_at":"2026-01-25T11:39:28.235371446Z","close_reason":"Doc sweep complete (FEATURE_PARITY/README/UPGRADE_LOG + API ergonomics)","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.13","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.13","depends_on_id":"bd-2qg.12","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":7,"issue_id":"bd-2qg.13","author":"Dicklesworthstone","text":"Purpose: align documentation with final implementation.\nUpdate FEATURE_PARITY.md to 100%, refresh README/examples, and record any breaking changes in UPGRADE_LOG.md.\nDocs should be accurate without referring back to planning artifacts.","created_at":"2026-01-25T00:43:27Z"}]}
{"id":"bd-2qg.13.1","title":"Update FEATURE_PARITY + remove deviation notes","description":"Scope:\n- Mark all categories as complete and remove deviation list once features are implemented.\n\nAcceptance criteria:\n- FEATURE_PARITY.md reflects 100% parity and is consistent with actual code/tests.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T00:41:11.427650863Z","created_by":"ubuntu","updated_at":"2026-01-25T10:29:32.603870107Z","closed_at":"2026-01-25T10:29:32.603852825Z","close_reason":"Updated FEATURE_PARITY.md to reflect complete parity and removed deviation/decision notes","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.13.1","depends_on_id":"bd-2qg.13","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.13.2","title":"Update README/examples + UPGRADE_LOG for API changes","description":"Scope:\n- Ensure README examples compile under new APIs (grapheme pool + link-id packing + threaded renderer).\n- Add migration notes to UPGRADE_LOG.md if any breaking changes were introduced.\n\nAcceptance criteria:\n- Docs and examples compile and accurately describe the final API.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T00:41:19.632317412Z","created_by":"ubuntu","updated_at":"2026-01-25T10:35:07.264486033Z","closed_at":"2026-01-25T10:35:07.264469131Z","close_reason":"Updated README/examples/UPGRADE_LOG for API changes","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.13.2","depends_on_id":"bd-2qg.13","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.13.2","depends_on_id":"bd-2qg.13.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.13.3","title":"API ergonomics review for new grapheme/link/threaded APIs","description":"Scope:\n- Review the public API after changes for ergonomics and clarity.\n- Ensure builder patterns remain coherent and examples are simple for users.\n- Remove any awkward or redundant surfaces introduced by parity work.\n\nAcceptance criteria:\n- API surface is coherent and documented; README/examples updated if needed.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T00:51:02.092942869Z","created_by":"ubuntu","updated_at":"2026-01-25T11:39:09.637489190Z","closed_at":"2026-01-25T11:39:09.637471947Z","close_reason":"Reviewed API ergonomics; documented grapheme pool + link usage in README","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.13.3","depends_on_id":"bd-2qg.13","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.13.3","depends_on_id":"bd-2qg.13.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.14","title":"E2E tests + logging harness for parity-critical flows","description":"Goal:\n- Add end-to-end test scripts with rich, structured logging to validate grapheme pooling, link-id packing, and threaded rendering at runtime.\n\nWhy:\n- Unit tests verify logic, but E2E validates full rendering pipelines and terminal output behavior.\n- Detailed logs + artifacts are essential for diagnosing regressions quickly.\n\nAcceptance criteria:\n- E2E tests are deterministic, emit structured logs, and produce artifacts on failure (captured output snapshots).\n- Tests cover grapheme rendering, hyperlink output, and threaded rendering lifecycle.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:48:15.355395734Z","created_by":"ubuntu","updated_at":"2026-01-25T05:09:47.198170379Z","closed_at":"2026-01-25T05:09:47.198153337Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.14","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":8,"issue_id":"bd-2qg.14","author":"Dicklesworthstone","text":"Purpose: provide high-fidelity end-to-end validation with detailed logs and artifacts.\nThese tests are required for confidence in grapheme pooling, hyperlink packing, and threaded rendering across the full render pipeline.","created_at":"2026-01-25T00:49:49Z"}]}
{"id":"bd-2qg.14.1","title":"E2E logging harness upgrade (structured logs + artifacts)","description":"Scope:\n- Extend tests/common/harness (or new helper) to emit structured logs (JSON or line-oriented) with timestamps, test step IDs, and rendered output snapshots.\n- Capture stdout/ANSI payloads to artifact files on failure.\n\nAcceptance criteria:\n- E2E tests can write logs and artifacts without manual instrumentation; logs include enough context to debug mismatches quickly.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:48:23.159231179Z","created_by":"ubuntu","updated_at":"2026-01-25T04:38:31.464168377Z","closed_at":"2026-01-25T04:38:31.464150563Z","close_reason":"Implemented structured E2E logging harness with: (1) JSONL structured logs (step_id, timestamp, elapsed_ms, level, category, message, cursor, ansi_hex), (2) LogLevel filtering via HARNESS_LOG_LEVEL, (3) AnsiCapture for ANSI output snapshots with hex/readable artifact files, (4) cursor position tracking, (5) automatic artifact writing on failure. All 3 E2E tests pass. Artifacts verified at target/test-artifacts/.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.14.1","depends_on_id":"bd-2qg.14","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":9,"issue_id":"bd-2qg.14.1","author":"Dicklesworthstone","text":"Logging should include step ids, cursor positions, and the exact ANSI payload emitted.\nPrefer JSONL or line-oriented logs so diffs are easy to inspect.","created_at":"2026-01-25T00:51:15Z"}]}
{"id":"bd-2qg.14.2","title":"E2E: grapheme rendering + cursor navigation scenario","description":"Scope:\n- Build an E2E test that renders text with multi-codepoint graphemes (ZWJ emoji, combining marks), navigates cursor over them, and captures rendered output.\n- Validate width handling and continuation cells via output snapshot.\n\nAcceptance criteria:\n- Deterministic run; output snapshot matches expected legacy behavior; logs include step-by-step cursor positions.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:48:31.856561966Z","created_by":"ubuntu","updated_at":"2026-01-25T04:53:03.455603766Z","closed_at":"2026-01-25T04:53:03.455580743Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.14.2","depends_on_id":"bd-2qg.14","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.14.2","depends_on_id":"bd-2qg.14.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.14.2","depends_on_id":"bd-2qg.4","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.14.3","title":"E2E: hyperlink output + link-id packing scenario","description":"Scope:\n- Add an E2E test that renders hyperlinks (OSC 8) using the packed link-id attributes.\n- Capture ANSI output and verify correct hyperlink sequences and style flags.\n\nAcceptance criteria:\n- Output snapshot matches expected OSC 8 sequences; logs show link-id assignment and emission.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:48:40.645859522Z","created_by":"ubuntu","updated_at":"2026-01-25T04:55:51.146625760Z","closed_at":"2026-01-25T04:55:51.146607195Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.14.3","depends_on_id":"bd-2qg.14","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.14.3","depends_on_id":"bd-2qg.14.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.14.3","depends_on_id":"bd-2qg.7","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.14.4","title":"E2E: threaded renderer lifecycle + smoke render","description":"Scope:\n- E2E scenario that spawns threaded renderer, submits frames, and verifies clean shutdown and terminal state restoration.\n- Capture ANSI output and log thread events.\n\nAcceptance criteria:\n- No deadlocks; cleanup occurs; output snapshot present; logs show thread start/stop and frame submission.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:48:50.577529249Z","created_by":"ubuntu","updated_at":"2026-01-25T04:58:13.499872408Z","closed_at":"2026-01-25T04:58:13.499854113Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.14.4","depends_on_id":"bd-2qg.14","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.14.4","depends_on_id":"bd-2qg.14.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.14.4","depends_on_id":"bd-2qg.9","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.14.5","title":"E2E CI integration + failure artifact capture","description":"Scope:\n- Ensure E2E tests run in CI and that logs/artifacts are preserved on failure (e.g., in target/ artifacts folder).\n- Document where to find artifacts and how to interpret them.\n\nAcceptance criteria:\n- CI runs E2E tests; failure artifacts available without manual steps.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T00:48:57.755197338Z","created_by":"ubuntu","updated_at":"2026-01-25T17:59:40.815547756Z","closed_at":"2026-01-25T17:59:40.815529802Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.14.5","depends_on_id":"bd-2qg.14","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.14.5","depends_on_id":"bd-2qg.14.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.14.5","depends_on_id":"bd-2qg.14.3","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.14.5","depends_on_id":"bd-2qg.14.4","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.2","title":"Grapheme pool spec + API design (24-bit IDs, refcounting, width bits)","description":"Implement Zig-spec grapheme pool in Rust. This task produces a self-contained spec: slot layout, ID encoding, width storage (bits 24–30), high-bit marker, error cases, and lifetime rules. Define Rust API surface (alloc/incref/decref/get, maybe intern()) and how it integrates with Cell/Buffer/AnsiWriter. Include reasoning about memory/layout tradeoffs and expected perf characteristics (zero‑alloc in hot path, reuse slots, avoid locks if possible).","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:02:05.663061191Z","created_by":"ubuntu","updated_at":"2026-01-25T03:24:45.385514963Z","closed_at":"2026-01-25T03:24:45.385189240Z","close_reason":"Grapheme pool spec + Rust API design documented in FEATURE_PARITY","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.2","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":10,"issue_id":"bd-2qg.2","author":"Dicklesworthstone","text":"Purpose: lock down the grapheme pool spec and Rust API before touching code.\nDeliverable should be precise enough that implementation and tests are mechanical, and should include invariants (bit layout, width range, ID validity, refcount semantics).\nThis removes any need to consult legacy docs during implementation.","created_at":"2026-01-25T00:42:05Z"}]}
{"id":"bd-2qg.2.1","title":"Spec extraction: Grapheme pool encoding + lifecycle","description":"Goal:\n- Extract and restate the grapheme pool spec so no one needs to re-open the Zig code or plan docs.\n\nInclude explicitly:\n- Bit layout: high-bit marker, width bits (24–30), 24-bit ID, reserved/invalid values.\n- ID range, allocation strategy, free-list behavior, refcount semantics.\n- Error/edge cases: invalid ID, decref below zero, width 0/too large.\n\nAcceptance criteria:\n- A clear, Rust-ready spec section (can be in docs or a comment blob in code) that directly informs implementation and tests.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:37:20.690342570Z","created_by":"ubuntu","updated_at":"2026-01-25T03:24:25.766396157Z","closed_at":"2026-01-25T03:24:25.766181713Z","close_reason":"Documented grapheme pool encoding, ID validity, and refcount/error semantics in FEATURE_PARITY","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.2.1","depends_on_id":"bd-2qg.2","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.2.2","title":"Rust API design for GraphemePool (types + safety model)","description":"Goal:\n- Define the Rust API surface for the pool with safety guarantees and minimal hot-path overhead.\n\nMust cover:\n- Public type(s) and method signatures (alloc/incref/decref/get/encode/decode).\n- Ownership / borrowing model: how cells refer to pool entries without Arc.\n- Thread safety expectations (single-threaded vs Sync/Send).\n- Integration points: buffer draw_text, AnsiWriter cell emission.\n\nAcceptance criteria:\n- Rust API design is specific enough to implement without further decisions.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:37:27.649171535Z","created_by":"ubuntu","updated_at":"2026-01-25T03:24:31.518211861Z","closed_at":"2026-01-25T03:24:31.517724793Z","close_reason":"Defined GraphemePool Rust API surface, ownership model, and encode/decode helpers","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.2.2","depends_on_id":"bd-2qg.2","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.2.2","depends_on_id":"bd-2qg.2.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.2.3","title":"Module placement + integration map for GraphemePool","description":"Goal:\n- Decide where the pool lives (module path) and who owns it (buffer, renderer, or global).\n\nInclude:\n- Pros/cons of each placement.\n- Required data flow (how draw_text gets pool access, how AnsiWriter resolves IDs).\n- Any API changes needed to pass pool references without allocations.\n\nAcceptance criteria:\n- Clear module path and ownership model chosen, plus integration diagram.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:37:34.567570501Z","created_by":"ubuntu","updated_at":"2026-01-25T03:24:39.154707186Z","closed_at":"2026-01-25T03:24:39.154443099Z","close_reason":"Selected module placement and ownership/integration map for GraphemePool","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.2.3","depends_on_id":"bd-2qg.2","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.2.3","depends_on_id":"bd-2qg.2.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.3","title":"Implement GraphemePool module with refcounted slots","description":"Create Rust module (likely under src/unicode/ or new src/grapheme_pool.rs) that implements: alloc(bytes)->id, incref(id), decref(id)->free if 0, get(id)->&str/bytes. Must follow Zig encoding: high bit marks grapheme ref; low 24 bits hold ID; width stored in bits 24–30. Ensure: bounds checks, reuse freed slots, no unsafe unless justified, and constant‑time get. Provide unit tests for alloc/incref/decref reuse, width encoding/decoding, and invalid ID handling.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:02:14.137575460Z","created_by":"ubuntu","updated_at":"2026-01-25T04:01:59.192600220Z","closed_at":"2026-01-25T04:01:59.192440519Z","close_reason":"Created src/grapheme_pool.rs with ref-counted pool: alloc, intern, incref, decref, get. O(1) slot reuse via free-list. 15 unit tests. Exported GraphemePool and GraphemeId from crate root.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.3","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.3","depends_on_id":"bd-2qg.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.3","depends_on_id":"bd-2qg.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":11,"issue_id":"bd-2qg.3","author":"Dicklesworthstone","text":"Purpose: implement the grapheme pool faithfully to spec with tests proving correctness.\nKey constraints: zero allocations in hot paths, safe bounds checking, and slot reuse on decref-to-zero.\nThis module is foundational and must be stable before integration work begins.","created_at":"2026-01-25T00:42:13Z"}]}
{"id":"bd-2qg.3.1","title":"Implement pool core data structures + free-list","description":"Scope:\n- Implement storage for grapheme bytes and refcounts; include free-list reuse.\n\nRequirements:\n- O(1) alloc/get in steady state.\n- Safe bounds checks and no panics on invalid IDs (return None).\n- Unit tests for alloc/free/reuse and refcount behavior.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:37:44.670231782Z","created_by":"ubuntu","updated_at":"2026-01-25T04:00:50.784564837Z","closed_at":"2026-01-25T04:00:50.784447916Z","close_reason":"Implemented GraphemePool with slots Vec, free-list for O(1) reuse, refcounting. Safe bounds checks, no panics on invalid IDs.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.3.1","depends_on_id":"bd-2qg.3","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.3.2","title":"Implement encode/decode helpers for grapheme IDs + width bits","description":"Scope:\n- Add helpers to encode a grapheme reference into u32 with high-bit + width bits + 24-bit ID, and to decode back into (id, width).\n\nAcceptance criteria:\n- Tests for round-trip encode/decode and invalid widths/IDs; documented bit layout constants.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:37:52.201242563Z","created_by":"ubuntu","updated_at":"2026-01-25T04:01:11.060211964Z","closed_at":"2026-01-25T04:01:11.060105343Z","close_reason":"GraphemeId encode/decode already implemented in cell.rs. Pool uses GraphemeId::new(pool_id, width) for encoding.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.3.2","depends_on_id":"bd-2qg.3","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.3.2","depends_on_id":"bd-2qg.3.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.3.3","title":"Pool API surface + safety invariants (docs/tests)","description":"Scope:\n- Provide public API functions/methods and document invariants (id 0 invalid, refcount semantics, width range).\n- Add tests for invalid ID access and decref to zero (slot reuse).\n\nAcceptance criteria:\n- API + doc comments align with spec and can be used by buffer/renderer without ambiguity.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:37:58.381616305Z","created_by":"ubuntu","updated_at":"2026-01-25T04:01:31.016668657Z","closed_at":"2026-01-25T04:01:31.016567086Z","close_reason":"Public API: alloc, intern, incref, decref, get, is_valid, refcount. Doc comments document invariants (slot 0 invalid, refcount semantics). Comprehensive unit tests for all edge cases.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.3.3","depends_on_id":"bd-2qg.3","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.3.3","depends_on_id":"bd-2qg.3.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.4","title":"Integrate GraphemePool into Cell/Buffer/Renderer hot paths","description":"Replace Arc<str> grapheme storage with grapheme pool IDs per spec. Update CellContent (and/or internal representation) to carry encoded u32 with high-bit marker + width bits + pool ID. Update buffer::draw_text and width handling so multi‑codepoint graphemes allocate pool entries, set continuation cells, and preserve zero‑alloc in hot loops. Update AnsiWriter/Renderer path to resolve grapheme IDs back to UTF‑8 when emitting. Include migration notes for any public API changes and ensure LinkPool usage is unaffected.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:02:21.018233080Z","created_by":"ubuntu","updated_at":"2026-01-25T04:29:06.676397807Z","closed_at":"2026-01-25T04:29:06.676380695Z","close_reason":"All 4 child beads completed: (1) Cell/CellContent representation with GraphemeId encoding, (2) buffer draw_text_with_pool and draw_char_with_pool, (3) AnsiWriter write_cell_with_pool methods, (4) Renderer grapheme_pool ownership. GraphemePool integrated into rendering hot path with zero-alloc design. All 54+ grapheme/cell/buffer tests pass.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.4","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.4","depends_on_id":"bd-2qg.3","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":12,"issue_id":"bd-2qg.4","author":"Dicklesworthstone","text":"Purpose: wire the pool into the rendering hot path without regressions.\nThis includes Cell representation, draw_text/draw_char, and AnsiWriter emission.\nSuccess means grapheme clusters render identically to legacy with proper width/continuations and no extra allocations.","created_at":"2026-01-25T00:42:20Z"}]}
{"id":"bd-2qg.4.1","title":"Update Cell/CellContent representation for grapheme IDs","description":"Scope:\n- Replace Arc<str> grapheme storage with encoded u32 grapheme references per spec.\n\nConsiderations:\n- Maintain Eq/PartialEq for diffing.\n- Ensure continuation cells still represent width>1.\n- Update any public API constructors (Cell::from_grapheme).\n\nAcceptance criteria:\n- Cell/CellContent updated with minimal API breakage and clear conversion path from &str to pool ID.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:38:06.822537948Z","created_by":"ubuntu","updated_at":"2026-01-25T03:50:18.893595942Z","closed_at":"2026-01-25T03:50:18.893577788Z","close_reason":"Implemented GraphemeId with Zig-spec encoding (24-bit pool ID + 7-bit width). Cell and CellContent are now Copy. Added write_content_with_pool for pool-aware rendering.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.4.1","depends_on_id":"bd-2qg.4","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.4.2","title":"Update buffer draw_text/draw_char to allocate grapheme IDs","description":"Scope:\n- Modify text drawing to use grapheme pool allocation for multi-codepoint clusters and width bits.\n\nAcceptance criteria:\n- draw_text properly handles Unicode grapheme clusters, wide chars, and continuation cells using encoded IDs.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:38:14.729431006Z","created_by":"ubuntu","updated_at":"2026-01-25T04:23:04.845017134Z","closed_at":"2026-01-25T04:23:04.844999340Z","close_reason":"Added draw_text_with_pool and draw_char_with_pool functions. Single codepoints stored as Char, multi-codepoint graphemes allocated via pool.intern(). 5 new tests verify deduplication and pool integration.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.4.2","depends_on_id":"bd-2qg.4","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.4.2","depends_on_id":"bd-2qg.4.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.4.3","title":"Update AnsiWriter rendering path to resolve grapheme IDs","description":"Scope:\n- Resolve encoded grapheme IDs back to UTF-8 at render time.\n- Ensure width=2 graphemes do not emit continuation cells.\n\nAcceptance criteria:\n- Output matches legacy expectations for emojis/ZWJ sequences and respects sync-output/diff logic.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:38:21.117688440Z","created_by":"ubuntu","updated_at":"2026-01-25T04:25:40.055602647Z","closed_at":"2026-01-25T04:25:40.055575747Z","close_reason":"Added write_cell_with_pool and write_cell_at_with_pool methods to AnsiWriter. Resolves grapheme IDs from pool to UTF-8 strings. Falls back to spaces for invalid IDs. 6 new tests.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.4.3","depends_on_id":"bd-2qg.4","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.4.3","depends_on_id":"bd-2qg.4.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.4.4","title":"Plumb GraphemePool ownership through Renderer/Buffer","description":"Scope:\n- Decide where the pool instance lives (Renderer, OptimizedBuffer, or global) and pass references without extra allocations.\n\nAcceptance criteria:\n- Buffer text drawing and renderer output can access the same pool safely; no lifetime leaks; no shared mutable aliasing violations.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:38:27.660947225Z","created_by":"ubuntu","updated_at":"2026-01-25T04:28:27.274370901Z","closed_at":"2026-01-25T04:28:27.274354239Z","close_reason":"Implemented Renderer ownership of GraphemePool following the LinkPool pattern. Added grapheme_pool field to Renderer struct initialized in constructor, with grapheme_pool() and grapheme_pool_ref() accessor methods. Buffer drawing accesses pool via &mut reference passed to draw_text_with_pool. All 29 grapheme tests pass.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.4.4","depends_on_id":"bd-2qg.4","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.4.4","depends_on_id":"bd-2qg.4.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.5","title":"Audit text module for grapheme pool impact (TextBuffer/EditBuffer/View)","description":"Review text/* to ensure grapheme pool integration doesn’t break styled segments, wrapping, cursor navigation, or width calculations. Decide whether text rendering should also intern graphemes (for EditorView rendering) or keep separate representation, and document reasoning. Implement any necessary adjustments and add targeted tests for wrapped multi‑codepoint graphemes and cursor navigation.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:02:27.456630350Z","created_by":"ubuntu","updated_at":"2026-01-25T05:04:38.980706249Z","closed_at":"2026-01-25T05:04:38.980686762Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.5","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.5","depends_on_id":"bd-2qg.4","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":13,"issue_id":"bd-2qg.5","author":"Dicklesworthstone","text":"Purpose: ensure text/editing layers behave correctly with grapheme pooling.\nVerify wrapping, cursor movement, selections, and width calculations for multi-codepoint graphemes.\nThis is where subtle regressions often appear, so targeted tests are required.","created_at":"2026-01-25T00:42:28Z"}]}
{"id":"bd-2qg.5.1","title":"TextBufferView + EditorView rendering with grapheme IDs","description":"Scope:\n- Verify rendering pipeline for text views works with grapheme pool IDs. Ensure width calculations and visual cursor movement still correct.\n\nAcceptance criteria:\n- Manual tests + unit tests for wrapped grapheme clusters and cursor navigation across width-2 graphemes.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:38:35.845564899Z","created_by":"ubuntu","updated_at":"2026-01-25T05:03:21.988220195Z","closed_at":"2026-01-25T05:03:21.988192503Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.5.1","depends_on_id":"bd-2qg.5","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.5.2","title":"Text module API audit for grapheme pool exposure","description":"Scope:\n- Audit any public APIs that return or accept grapheme strings; decide whether to expose pool IDs or keep API in &str while using pool internally.\n\nAcceptance criteria:\n- Clear policy documented and reflected in code; no accidental public exposure of internal encoding.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:38:43.077548148Z","created_by":"ubuntu","updated_at":"2026-01-25T05:04:26.056548185Z","closed_at":"2026-01-25T05:04:26.056524871Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.5.2","depends_on_id":"bd-2qg.5","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.6","title":"Add grapheme pool tests + conformance fixtures for grapheme encoding","description":"Extend unit tests to validate grapheme pool encoding (high bit, width bits, pool ID extraction) and correct rendering of multi‑codepoint graphemes. Update conformance fixtures to include grapheme cases (ZWJ sequences, combining marks, width=2 emoji), ensuring expected ANSI output matches legacy behavior.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:02:35.445890557Z","created_by":"ubuntu","updated_at":"2026-01-25T05:08:58.182690003Z","closed_at":"2026-01-25T05:08:58.182672730Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.6","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.6","depends_on_id":"bd-2qg.4","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.6","depends_on_id":"bd-2qg.5","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":14,"issue_id":"bd-2qg.6","author":"Dicklesworthstone","text":"Purpose: lock correctness with tests/fixtures that explicitly cover grapheme encoding and rendering.\nFixtures should be deterministic and derived from legacy capture once that tool exists.\nThese tests are the parity proof for grapheme behavior.","created_at":"2026-01-25T00:42:34Z"}]}
{"id":"bd-2qg.6.1","title":"Unit tests for grapheme encoding + pool lifecycle","description":"Scope:\n- Add unit tests for encode/decode, width bits, refcount increment/decrement, slot reuse, and invalid IDs.\n\nAcceptance criteria:\n- Tests are deterministic and cover both ASCII and multi‑codepoint graphemes.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:38:50.377100750Z","created_by":"ubuntu","updated_at":"2026-01-25T04:30:41.181426548Z","closed_at":"2026-01-25T04:30:41.181409236Z","close_reason":"All required tests already implemented in grapheme_pool.rs and cell.rs. 29 tests cover: encode/decode (GraphemeId roundtrip), width bits (encoding/extraction), refcount increment/decrement, slot reuse after free, invalid ID handling. Tests use both ASCII and multi-codepoint graphemes (ZWJ family emoji). Tests are deterministic.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.6.1","depends_on_id":"bd-2qg.3","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.6.1","depends_on_id":"bd-2qg.6","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.6.2","title":"Conformance fixtures: grapheme cases (ZWJ, combining, width=2)","description":"Scope:\n- Add fixture cases covering ZWJ sequences, combining marks, and width=2 emoji.\n- Ensure expected ANSI output and width calculations align with legacy spec.\n\nAcceptance criteria:\n- Fixtures are self-contained, deterministic, and validated by conformance tests.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:38:57.266990481Z","created_by":"ubuntu","updated_at":"2026-01-25T05:08:52.099336251Z","closed_at":"2026-01-25T05:08:52.099312577Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.6.2","depends_on_id":"bd-2qg.4","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.6.2","depends_on_id":"bd-2qg.6","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.6.2","depends_on_id":"bd-2qg.6.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.6.3","title":"Conformance fixtures: hyperlink/link-id packing cases","description":"Scope:\n- Add fixture cases that exercise link ID packing and OSC 8 hyperlink output in ANSI tests.\n- Validate that style flags are preserved when link IDs are set/cleared.\n\nAcceptance criteria:\n- Fixtures cover link id set/clear and hyperlink start/end sequences; conformance tests validate output.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:49:04.409912219Z","created_by":"ubuntu","updated_at":"2026-01-25T05:08:52.129375712Z","closed_at":"2026-01-25T05:08:52.129350054Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.6.3","depends_on_id":"bd-2qg.6","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.6.3","depends_on_id":"bd-2qg.6.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.6.3","depends_on_id":"bd-2qg.7","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":15,"issue_id":"bd-2qg.6.3","author":"Dicklesworthstone","text":"This closes the gap in conformance coverage for hyperlink behavior and link-id packing.\nFixtures should include both correct OSC 8 sequences and preservation of style bits during link-id set/clear.","created_at":"2026-01-25T00:51:11Z"}]}
{"id":"bd-2qg.7","title":"Align TextAttributes with Zig spec link-id packing (bits 8–31)","description":"Spec requires link IDs packed into TextAttributes (lower 8 bits flags, upper 24 bits link ID). Current Rust uses separate link_id field. Implement packed representation or provide a spec‑equivalent adapter without loss. Update Style builder, Cell, AnsiWriter, and LinkPool usage accordingly. Document API impacts and migration path; add tests for set/get link ID preserving flags.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:02:44.135107544Z","created_by":"ubuntu","updated_at":"2026-01-25T03:09:54.497388713Z","closed_at":"2026-01-25T03:09:54.497144373Z","close_reason":"Aligned TextAttributes with packed link IDs; updated Style/Cell/Renderer/AnsiWriter and docs","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.7","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.7","depends_on_id":"bd-2qg.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":16,"issue_id":"bd-2qg.7","author":"Dicklesworthstone","text":"Purpose: bring TextAttributes in line with Zig spec by packing link IDs into bits 8–31.\nThis may be a breaking API change; track migration notes and ensure hyperlink emission still works.\nAll style flag behavior must remain unchanged.","created_at":"2026-01-25T00:42:42Z"}]}
{"id":"bd-2qg.7.1","title":"Define packed TextAttributes type + helpers","description":"Scope:\n- Implement u32 (or newtype) attributes with lower 8 bits flags and upper 24 bits link ID.\n- Provide helpers: get_link_id, set_link_id, clear_link_id; preserve flag bits.\n\nAcceptance criteria:\n- Tests prove bit packing works and existing flag behavior is unchanged.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:39:06.983009416Z","created_by":"ubuntu","updated_at":"2026-01-25T03:09:36.645099452Z","closed_at":"2026-01-25T03:09:36.644905306Z","close_reason":"Packed TextAttributes implemented with link ID helpers and tests","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.7.1","depends_on_id":"bd-2qg.7","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.7.2","title":"Wire packed link IDs through Style/Cell/AnsiWriter","description":"Scope:\n- Remove separate link_id field where possible and route hyperlink handling through packed TextAttributes.\n- Update Style builder, Cell constructors, LinkPool usage, and AnsiWriter hyperlink emission.\n\nAcceptance criteria:\n- Links render correctly; no regressions in style flags; updated tests/fixtures pass.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:39:14.588562226Z","created_by":"ubuntu","updated_at":"2026-01-25T03:09:42.501799413Z","closed_at":"2026-01-25T03:09:42.500273990Z","close_reason":"Wired packed link IDs through Style/Cell/AnsiWriter/Renderer","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.7.2","depends_on_id":"bd-2qg.7","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.7.2","depends_on_id":"bd-2qg.7.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.7.3","title":"API migration + compatibility notes for link-id packing","description":"Scope:\n- Document any public API changes (e.g., TextAttributes type width, removal of Style.link_id field).\n- Update examples/tests to new API and note breaking changes in UPGRADE_LOG.md.\n\nAcceptance criteria:\n- Clear migration notes for future users and internal code updates complete.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:39:21.323793599Z","created_by":"ubuntu","updated_at":"2026-01-25T03:09:48.581160327Z","closed_at":"2026-01-25T03:09:48.580737510Z","close_reason":"Documented API change and updated harness for packed link IDs","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.7.3","depends_on_id":"bd-2qg.7","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.7.3","depends_on_id":"bd-2qg.7.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.8","title":"Threaded renderer design (API, ownership, shutdown, sync-output)","description":"Design threaded rendering per Zig feature parity: define Rust API surface (e.g., Renderer::spawn or ThreadedRenderer wrapper), buffer ownership model (double buffer shared or message passing), and shutdown semantics. Consider Terminal !Send, sync output, cursor state, and drop/cleanup guarantees. Include reasoning about performance vs complexity and how to preserve zero‑alloc hot path.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:02:50.146469141Z","created_by":"ubuntu","updated_at":"2026-01-25T04:42:03.951626409Z","closed_at":"2026-01-25T04:42:03.951608575Z","close_reason":"Design phase complete. All 3 child beads closed: (1) API sketch + command protocol, (2) Thread lifecycle + cleanup semantics, (3) Performance model. Documentation in FEATURE_PARITY.md covers ThreadedRenderer API, ownership model (buffer movement via channels), shutdown/drop behavior, panic recovery, terminal state invariants, diff strategy, and benchmarking approach. Ready for implementation in bd-2qg.9.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.8","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.8","depends_on_id":"bd-2qg.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":17,"issue_id":"bd-2qg.8","author":"Dicklesworthstone","text":"Purpose: design a threaded renderer that preserves terminal safety and performance.\nThe design must handle ownership, diffing, sync-output, and clean shutdown without leaving terminal in a bad state.\nThis bead produces the blueprint used by implementation.","created_at":"2026-01-25T00:42:50Z"}]}
{"id":"bd-2qg.8.1","title":"Threaded renderer API sketch + command protocol","description":"Scope:\n- Define exact API (constructor, present/submit, resize, cursor, title, shutdown).\n- Define message protocol between main thread and render thread (commands, buffer ownership).\n\nAcceptance criteria:\n- API + protocol diagram documented; ready for implementation.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:39:30.519289239Z","created_by":"ubuntu","updated_at":"2026-01-25T03:16:02.038370344Z","closed_at":"2026-01-25T03:16:02.038183242Z","close_reason":"Documented threaded renderer API and command protocol sketch","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.8.1","depends_on_id":"bd-2qg.8","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.8.2","title":"Thread lifecycle + cleanup semantics","description":"Scope:\n- Define drop behavior, graceful shutdown, and terminal state restoration on thread exit or panic.\n- Ensure raw mode / alt screen are always cleaned up.\n\nAcceptance criteria:\n- Lifecycle documented and verified by tests or reasoning; no orphaned terminal state.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:39:38.071785644Z","created_by":"ubuntu","updated_at":"2026-01-25T04:40:52.708766474Z","closed_at":"2026-01-25T04:40:52.708748570Z","close_reason":"Documented thread lifecycle and cleanup semantics in FEATURE_PARITY.md. Covers: startup sequence, graceful shutdown protocol, Drop behavior (blocking join to guarantee cleanup), panic recovery with catch_unwind, terminal state invariants (alt screen, cursor, mouse, raw mode), thread safety (Terminal !Send, buffer movement), timeout handling, and testing strategy. Ready for implementation in bd-2qg.9.1.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.8.2","depends_on_id":"bd-2qg.8","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.8.2","depends_on_id":"bd-2qg.8.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.8.3","title":"Performance model for threaded renderer","description":"Scope:\n- Compare expected perf of threaded vs single-threaded rendering; ensure no extra allocations or locking on hot path.\n- Decide whether to batch diff generation on worker thread.\n\nAcceptance criteria:\n- Performance considerations documented with a clear justification for design choices.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:39:45.842514974Z","created_by":"ubuntu","updated_at":"2026-01-25T04:41:47.250804800Z","closed_at":"2026-01-25T04:41:47.250787488Z","close_reason":"Documented performance model in FEATURE_PARITY.md. Covers: single vs threaded comparison table, hot path analysis (zero allocations, no locks), diff strategy (render thread for parallelism), memory layout, channel choice (std::sync::mpsc for SPSC), synchronous present rationale, and benchmarking strategy. Design ready for implementation.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.8.3","depends_on_id":"bd-2qg.8","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.8.3","depends_on_id":"bd-2qg.8.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.9","title":"Implement threaded renderer + tests/demo","description":"Implement the design from bd-2qg.8. Provide a safe API for submitting frames, resizing, and teardown. Ensure terminal cleanup on thread exit and that diff rendering still minimizes output. Add tests for startup/shutdown + basic frame present (use mock writer if needed) and update examples/docs with a minimal threaded usage snippet.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:02:56.486916524Z","created_by":"ubuntu","updated_at":"2026-01-25T04:48:50.045622867Z","closed_at":"2026-01-25T04:48:50.045605094Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.9","depends_on_id":"bd-2qg","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.9","depends_on_id":"bd-2qg.8","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}],"comments":[{"id":18,"issue_id":"bd-2qg.9","author":"Dicklesworthstone","text":"Purpose: implement and validate threaded rendering per the approved design.\nMust include tests for startup/shutdown and at least one smoke render path.\nA minimal example or doc snippet should exist to guide usage.","created_at":"2026-01-25T00:42:56Z"}]}
{"id":"bd-2qg.9.1","title":"Implement threaded renderer core (thread + channels)","description":"Scope:\n- Implement the render thread and messaging protocol (from bd-2qg.8).\n- Ensure buffer ownership is safe and efficient; avoid per-frame allocation.\n\nAcceptance criteria:\n- Threaded renderer compiles, can render at least a simple frame, and shuts down cleanly.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:39:54.126331452Z","created_by":"ubuntu","updated_at":"2026-01-25T04:45:59.719336638Z","closed_at":"2026-01-25T04:45:59.719318123Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.9.1","depends_on_id":"bd-2qg.9","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.9.2","title":"Threaded renderer tests (startup/shutdown + smoke render)","description":"Scope:\n- Add tests that spawn the threaded renderer, submit a frame, and verify clean shutdown.\n- Use mock writer or capture output to avoid terminal dependency.\n\nAcceptance criteria:\n- Tests pass reliably in CI and validate cleanup semantics.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:40:00.988797063Z","created_by":"ubuntu","updated_at":"2026-01-25T04:47:21.254553054Z","closed_at":"2026-01-25T04:47:21.254535572Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.9.2","depends_on_id":"bd-2qg.9","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.9.2","depends_on_id":"bd-2qg.9.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2qg.9.3","title":"Threaded renderer example/docs snippet","description":"Scope:\n- Update or add a minimal example showing threaded usage and shutdown.\n- Ensure example compiles under current API.\n\nAcceptance criteria:\n- README or examples contain a working snippet; docs reflect new API.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T00:40:08.851639952Z","created_by":"ubuntu","updated_at":"2026-01-25T04:48:35.006123124Z","closed_at":"2026-01-25T04:48:35.006106012Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2qg.9.3","depends_on_id":"bd-2qg.9","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2qg.9.3","depends_on_id":"bd-2qg.9.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2sk","title":"TextBufferView Line Info Cache","description":"## Overview\nImplement line information caching for efficient rendering of wrapped text. Without this, wrapping is O(n) on every render.\n\n## Scope\nCache precomputed line information:\n- starts[] - byte offset where each virtual line starts\n- widths[] - display width of each virtual line\n- sources[] - source (logical) line index for each virtual line\n- wraps[] - boolean: is this line a continuation?\n- max_width - maximum line width\n\n## Implementation Details\n\n### LineInfo Structure\n```rust\n#[derive(Clone, Debug)]\npub struct LineInfo {\n    pub byte_start: usize,\n    pub byte_end: usize,\n    pub width: usize,\n    pub source_line: usize,\n    pub is_continuation: bool,\n}\n\npub struct LineCache {\n    lines: Vec<LineInfo>,\n    max_width: usize,\n    wrap_mode: WrapMode,\n    wrap_width: u32,\n    content_hash: u64,  // Invalidation check\n}\n\nimpl LineCache {\n    pub fn compute(buffer: &TextBuffer, wrap_mode: WrapMode, wrap_width: u32) -> Self;\n    pub fn is_valid(&self, buffer: &TextBuffer, wrap_mode: WrapMode, wrap_width: u32) -> bool;\n    pub fn virtual_line_count(&self) -> usize;\n    pub fn get_line(&self, idx: usize) -> Option<&LineInfo>;\n    pub fn source_to_virtual(&self, source_line: usize) -> usize;\n    pub fn virtual_to_source(&self, virtual_line: usize) -> usize;\n}\n```\n\n### Word Wrap Algorithm\n```rust\nfn compute_wrapped_lines(line: &str, wrap_width: u32, wrap_mode: WrapMode) -> Vec<(usize, usize, usize)> {\n    match wrap_mode {\n        WrapMode::None => vec![(0, line.len(), display_width(line))],\n        WrapMode::Char => wrap_at_chars(line, wrap_width),\n        WrapMode::Word => wrap_at_words(line, wrap_width),\n    }\n}\n```\n\n## Files to Create/Modify\n- src/text/line_cache.rs - new file (~250 lines)\n- src/text/view.rs - integrate cache, update virtual_line_count()\n- src/text/mod.rs - export LineCache\n\n## Testing Requirements\n\n### Unit Tests (minimum 14 tests with detailed logging)\n- test_line_cache_no_wrap\n- test_line_cache_char_wrap_exact\n- test_line_cache_char_wrap_overflow\n- test_line_cache_word_wrap_simple\n- test_line_cache_word_wrap_long_word\n- test_line_cache_word_wrap_multiple_spaces\n- test_line_cache_multiple_lines\n- test_line_cache_empty_lines\n- test_line_cache_utf8_width\n- test_line_cache_cjk_characters\n- test_line_cache_invalidation\n- test_line_cache_invalidation_wrap_change\n- test_source_to_virtual_mapping\n- test_virtual_to_source_mapping\n\n### Detailed Test Logging Framework\nEach test MUST log cache state and mappings:\n\n```rust\n#[test]\nfn test_line_cache_word_wrap_simple() {\n    let mut buffer = TextBuffer::new();\n    buffer.set_text(\"Hello world this is a test\");\n    \n    eprintln!(\"[TEST] Input text: {:?}\", buffer.text());\n    eprintln!(\"[TEST] Text length: {} bytes\", buffer.text().len());\n    eprintln!(\"[TEST] Wrap width: 10 columns\");\n    \n    let cache = LineCache::compute(&buffer, WrapMode::Word, 10);\n    \n    eprintln!(\"[TEST] Cache computed:\");\n    eprintln!(\"[TEST]   virtual_line_count: {}\", cache.virtual_line_count());\n    eprintln!(\"[TEST]   max_width: {}\", cache.max_width());\n    \n    for (i, line) in cache.lines().iter().enumerate() {\n        let text_slice = &buffer.text()[line.byte_start..line.byte_end];\n        eprintln!(\"[TEST]   Line {}: bytes {}..{} width={} src={} cont={} text={:?}\",\n            i, line.byte_start, line.byte_end, line.width, \n            line.source_line, line.is_continuation, text_slice);\n    }\n    \n    // Expected: \"Hello \" / \"world \" / \"this is \" / \"a test\"\n    assert!(cache.virtual_line_count() >= 3, \n        \"Expected at least 3 virtual lines, got {}\", cache.virtual_line_count());\n    \n    // Verify word boundaries\n    for line in cache.lines() {\n        let text = &buffer.text()[line.byte_start..line.byte_end];\n        eprintln!(\"[TEST] Checking line {:?} - should not break mid-word\", text.trim());\n        // Words should not be split\n        assert!(!text.trim().contains(' ') || text.ends_with(' ') || line.byte_end == buffer.text().len(),\n            \"Line {:?} may have broken a word incorrectly\", text);\n    }\n    \n    eprintln!(\"[TEST] PASS: Word wrap breaks at word boundaries\");\n}\n\n#[test]\nfn test_line_cache_cjk_characters() {\n    let mut buffer = TextBuffer::new();\n    // CJK characters are typically 2 columns wide\n    buffer.set_text(\"Hello\\u{4e2d}\\u{6587}World\");  // \"Hello中文World\"\n    \n    eprintln!(\"[TEST] Input: {:?}\", buffer.text());\n    eprintln!(\"[TEST] Byte length: {}\", buffer.text().len());\n    eprintln!(\"[TEST] Expected display widths:\");\n    eprintln!(\"[TEST]   'Hello' = 5 cols\");\n    eprintln!(\"[TEST]   '中' = 2 cols\");\n    eprintln!(\"[TEST]   '文' = 2 cols\");\n    eprintln!(\"[TEST]   'World' = 5 cols\");\n    eprintln!(\"[TEST]   Total = 14 cols\");\n    \n    let cache = LineCache::compute(&buffer, WrapMode::Char, 8);\n    \n    eprintln!(\"[TEST] Cache with wrap_width=8:\");\n    for (i, line) in cache.lines().iter().enumerate() {\n        let text = &buffer.text()[line.byte_start..line.byte_end];\n        eprintln!(\"[TEST]   Line {}: width={} text={:?}\", i, line.width, text);\n    }\n    \n    // Verify no CJK character is split\n    for line in cache.lines() {\n        let text = &buffer.text()[line.byte_start..line.byte_end];\n        eprintln!(\"[TEST] Verifying line {:?} has valid char boundaries\", text);\n        assert!(text.is_char_boundary(0), \"Line start not at char boundary\");\n    }\n    \n    eprintln!(\"[TEST] PASS: CJK characters handled correctly\");\n}\n\n#[test]\nfn test_line_cache_invalidation() {\n    let mut buffer = TextBuffer::new();\n    buffer.set_text(\"Hello\");\n    \n    let cache = LineCache::compute(&buffer, WrapMode::None, 80);\n    let hash1 = cache.content_hash();\n    eprintln!(\"[TEST] Initial cache hash: {:016x}\", hash1);\n    \n    assert!(cache.is_valid(&buffer, WrapMode::None, 80));\n    eprintln!(\"[TEST] Cache valid before modification: true\");\n    \n    // Modify buffer\n    buffer.set_text(\"Hello World\");\n    eprintln!(\"[TEST] Buffer modified to: {:?}\", buffer.text());\n    \n    assert!(!cache.is_valid(&buffer, WrapMode::None, 80));\n    eprintln!(\"[TEST] Cache valid after modification: false\");\n    \n    let new_cache = LineCache::compute(&buffer, WrapMode::None, 80);\n    let hash2 = new_cache.content_hash();\n    eprintln!(\"[TEST] New cache hash: {:016x}\", hash2);\n    \n    assert_ne!(hash1, hash2, \"Hashes should differ after content change\");\n    eprintln!(\"[TEST] PASS: Cache invalidation works correctly\");\n}\n\n#[test]\nfn test_source_to_virtual_mapping() {\n    let mut buffer = TextBuffer::new();\n    buffer.set_text(\"Short\\nThis is a longer line that will wrap\\nEnd\");\n    \n    eprintln!(\"[TEST] Input text with 3 logical lines:\");\n    for (i, line) in buffer.text().lines().enumerate() {\n        eprintln!(\"[TEST]   Logical line {}: {:?}\", i, line);\n    }\n    \n    let cache = LineCache::compute(&buffer, WrapMode::Word, 15);\n    \n    eprintln!(\"[TEST] Virtual lines (wrap_width=15):\");\n    for (i, line) in cache.lines().iter().enumerate() {\n        eprintln!(\"[TEST]   Virtual {}: source={} cont={}\", \n            i, line.source_line, line.is_continuation);\n    }\n    \n    // Test mappings\n    for src in 0..3 {\n        let virt = cache.source_to_virtual(src);\n        eprintln!(\"[TEST] source_to_virtual({}) = {}\", src, virt);\n    }\n    \n    for virt in 0..cache.virtual_line_count() {\n        let src = cache.virtual_to_source(virt);\n        eprintln!(\"[TEST] virtual_to_source({}) = {}\", virt, src);\n    }\n    \n    // Verify round-trip for source lines\n    for src in 0..3 {\n        let virt = cache.source_to_virtual(src);\n        let back = cache.virtual_to_source(virt);\n        assert_eq!(back, src, \"Round-trip failed for source line {}\", src);\n    }\n    \n    eprintln!(\"[TEST] PASS: Source/virtual mappings are correct\");\n}\n```\n\n### Performance Test\n```rust\n#[test]\nfn test_line_cache_performance() {\n    use std::time::Instant;\n    \n    // Generate 10K lines of text\n    let text: String = (0..10_000)\n        .map(|i| format!(\"Line {} with some content that might wrap\\n\", i))\n        .collect();\n    \n    let mut buffer = TextBuffer::new();\n    buffer.set_text(&text);\n    \n    eprintln!(\"[PERF] Buffer size: {} bytes, {} lines\", \n        buffer.text().len(), buffer.len_lines());\n    \n    let start = Instant::now();\n    let cache = LineCache::compute(&buffer, WrapMode::Word, 80);\n    let elapsed = start.elapsed();\n    \n    eprintln!(\"[PERF] Cache computation time: {:?}\", elapsed);\n    eprintln!(\"[PERF] Virtual lines: {}\", cache.virtual_line_count());\n    eprintln!(\"[PERF] Lines per millisecond: {:.0}\", \n        10_000.0 / elapsed.as_secs_f64() / 1000.0);\n    \n    assert!(elapsed.as_millis() < 10, \n        \"Cache computation took {:?}, should be <10ms\", elapsed);\n    \n    eprintln!(\"[PERF] PASS: 10K lines cached in <10ms\");\n}\n```\n\n## Acceptance Criteria\n- [ ] Cache computes correct line info for all wrap modes\n- [ ] Word wrap breaks at spaces when possible\n- [ ] Wide characters (CJK) dont break mid-character\n- [ ] Cache invalidates when content changes\n- [ ] Cache invalidates when wrap mode/width changes\n- [ ] source_to_virtual and virtual_to_source mappings correct\n- [ ] All 14+ unit tests pass with detailed logging\n- [ ] Each test logs byte offsets, widths, and mappings\n- [ ] Performance: 10K lines cached in <10ms\n- [ ] Performance test logs timing metrics\n\nDependents:\n  <- bd-21g (blocks) - TextBufferView measureForDimensions\n  <- bd-1tl (blocks) - EditorView Visual Navigation","acceptance_criteria":"- [ ] Cache computes correct line info for all wrap modes\n- [ ] Word wrap breaks at spaces when possible\n- [ ] Wide characters (CJK) don't break mid-character\n- [ ] Cache invalidates when content changes\n- [ ] source_to_virtual and virtual_to_source mappings correct\n- [ ] All 10+ unit tests pass\n- [ ] Performance: 10K lines cached in <10ms\n\n---","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:11:50.119589408Z","closed_at":"2026-01-19T22:11:50.119543782Z","close_reason":"Added LineInfo helper methods (source_to_virtual, virtual_to_source, etc.) and 16 comprehensive tests with detailed logging. All 24 view tests pass.","compaction_level":0,"original_size":0}
{"id":"bd-2t1r","title":"demo_showcase features: OSC 8 hyperlinks prove-out (LinkPool in logs/help/palette)","description":"# demo_showcase Features — OSC 8 Hyperlinks Prove‑Out (LinkPool)\n\n## Purpose\n\nOpenTUI supports OSC 8 hyperlinks via `LinkPool` + `TextAttributes::link_id`. This bead ensures hyperlinks appear in multiple real UI contexts.\n\n## Requirements\n\n- Allocate URLs through `renderer.link_pool().alloc(url)`.\n- Apply link IDs via `Style::with_link(id)`.\n\nHyperlinks must appear in at least:\n\n- Logs panel: one or more log entries contain a clickable URL.\n- Help overlay: “Docs / Links” section is clickable.\n- Command palette: a footer row or command description contains a clickable URL.\n\n## Capability Gating\n\nIf the terminal does not support hyperlinks (`capabilities.hyperlinks == false`):\n\n- Render the same text but without link attributes.\n- Add a subtle `(no hyperlinks)` indicator in the inspector/status bar.\n\n## Acceptance Notes\n\n- In hyperlink-capable terminals, clicking a rendered link opens the URL (terminal-dependent).\n- In non-capable terminals, the UI still looks good and makes the limitation explicit.","acceptance_criteria":"Done when:\n- Hyperlinks render in all three contexts: Logs panel, Help overlay, and Command palette.\n- Link IDs are allocated via `renderer.link_pool()` and applied via `Style::with_link(id)`.\n- In hyperlink-capable mode, PTY/E2E capture observes at least one OSC 8 hyperlink sequence.\n- With hyperlinks disabled (e.g., `--cap-preset no_hyperlinks` or detected capabilities), OSC 8 sequences are absent and the UI shows a subtle capability warning/indicator.\n- Headless JSON markers include at least one linkified row when hyperlinks are enabled.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:27:39.954930425Z","created_by":"ubuntu","updated_at":"2026-01-27T23:16:42.664200554Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","features"],"dependencies":[{"issue_id":"bd-2t1r","depends_on_id":"bd-1ei","type":"blocks","created_at":"2026-01-27T22:33:16.051541172Z","created_by":"ubuntu"},{"issue_id":"bd-2t1r","depends_on_id":"bd-1ob","type":"blocks","created_at":"2026-01-27T22:32:23.371289209Z","created_by":"ubuntu"},{"issue_id":"bd-2t1r","depends_on_id":"bd-1w9","type":"blocks","created_at":"2026-01-27T22:32:22.792183095Z","created_by":"ubuntu"},{"issue_id":"bd-2t1r","depends_on_id":"bd-2c6","type":"blocks","created_at":"2026-01-27T22:32:21.631300478Z","created_by":"ubuntu"},{"issue_id":"bd-2t1r","depends_on_id":"bd-37p","type":"parent-child","created_at":"2026-01-27T22:27:39.971075913Z","created_by":"ubuntu"},{"issue_id":"bd-2t1r","depends_on_id":"bd-3pe","type":"blocks","created_at":"2026-01-27T22:32:22.215789467Z","created_by":"ubuntu"},{"issue_id":"bd-2t1r","depends_on_id":"bd-pnln","type":"blocks","created_at":"2026-01-27T22:55:18.638767113Z","created_by":"ubuntu"}]}
{"id":"bd-2t3","title":"demo_showcase runtime: animation clock + frame pacing (dt, easing, fps cap)","description":"# demo_showcase Runtime — Animation Clock + Frame Pacing\n\n## Purpose\n\nMake the demo feel alive and premium:\n\n- smooth animations (header gradient pulse, chart motion, selection transitions)\n- stable dt handling\n- optional FPS cap\n\n## Time Model\n\n- Use `Instant` to compute `dt` per frame.\n- Keep a monotonic `t: f32` seconds for animations.\n- Clamp dt to avoid huge jumps (e.g., after resize / backgrounding).\n\n## Easing Helpers (No Dependencies)\n\nImplement a tiny set of easing functions:\n\n- `smoothstep`\n- `ease_in_out_cubic`\n- `pulse = 0.5 + 0.5 * sin(t * ω)`\n\n## FPS Cap\n\nIf `--fps N` is set:\n\n- target frame duration = `1/N`\n- after `present()`, sleep the remaining time\n\nImportant: don’t sleep negative; also don’t accumulate drift.\n\n## Pause Semantics\n\nIf terminal focus is lost:\n\n- set `paused = true`\n- stop advancing animation time\n- keep rendering (or drop to low FPS) so UI shows “paused”","acceptance_criteria":"Checklist:\n- [ ] dt/t model exists and is stable\n- [ ] Small set of easing helpers exist (no extra deps)\n- [ ] Optional FPS cap works\n- [ ] Focus-lost pause stops animations deterministically","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:10:42.198469978Z","created_by":"ubuntu","updated_at":"2026-01-27T22:12:23.071083183Z","compaction_level":0,"original_size":0,"labels":["animation","demo_showcase","runtime"],"dependencies":[{"issue_id":"bd-2t3","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:10:42.227829615Z","created_by":"ubuntu"},{"issue_id":"bd-2t3","depends_on_id":"bd-2iv","type":"blocks","created_at":"2026-01-27T22:12:20.485545788Z","created_by":"ubuntu"},{"issue_id":"bd-2t3","depends_on_id":"bd-35g","type":"blocks","created_at":"2026-01-27T22:12:23.071058597Z","created_by":"ubuntu"}]}
{"id":"bd-2ti","title":"Optimize draw_buffer_region() to avoid cell.clone()","description":"draw_buffer_region() calls cell.clone() for each copied cell. Since Cell's content may contain Arc<str> for graphemes, this involves atomic operations. Could potentially refactor to avoid clone in the common case (single chars).","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-21T16:54:46.858333769Z","created_by":"ubuntu","updated_at":"2026-01-21T17:16:44.210082213Z","closed_at":"2026-01-21T17:16:44.210010528Z","close_reason":"Avoided per-cell clone on invisible cells; inline blending with scissor/opacity checks; cargo check/clippy/fmt clean","compaction_level":0,"original_size":0}
{"id":"bd-2tj","title":"demo_showcase UI: editor panel (EditBuffer + EditorView + highlighting + wrap/undo)","description":"# demo_showcase UI — Editor Panel\n\n## Purpose\n\nThe editor panel is the “serious app” anchor:\n\n- proves rope-backed editing (`EditBuffer`)\n- proves undo/redo\n- proves wrapping + visual navigation\n- proves syntax highlighting + theme switching\n\n## Requirements\n\n- Use `EditorView` as the renderer for the panel.\n- Load sample Rust content from the content pack (`bd-1ei`).\n- Enable highlighting via `TokenizerRegistry::with_builtins()` and `Theme`.\n\n## Interactions\n\n- Standard editor keys from spec (`bd-3l0`): arrows, word nav, home/end, page up/down\n- `Ctrl+Z` undo, `Ctrl+Y` redo\n- `Ctrl+W` cycle wrap mode\n- `Ctrl+L` toggle line numbers\n- Bracketed paste:\n  - `Event::Paste` inserts into the editor at cursor\n  - show toast `Pasted N chars`\n\n## Rendering\n\n- Panel header includes:\n  - file name\n  - wrap mode\n  - theme name\n  - dirty indicator (simulated)\n\n## Notes / Known Constraints\n\n- `EditorView` currently renders via `TextBufferView::render_to` (placeholder grapheme IDs).\n  - For the editor content, keep multi-codepoint graphemes out of the default sample.\n  - Grapheme pool prove-out will occur in a dedicated Unicode panel.","acceptance_criteria":"Checklist:\n- [ ] Editor panel renders inside its rect and clips correctly\n- [ ] Keyboard navigation works\n- [ ] Undo/redo works and is visible\n- [ ] Wrap modes work (None/Word/Char)\n- [ ] Highlighting works and theme can be changed\n- [ ] Paste inserts content and shows toast","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:13:37.774610286Z","created_by":"ubuntu","updated_at":"2026-01-27T22:33:26.302939956Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","text","ui"],"dependencies":[{"issue_id":"bd-2tj","depends_on_id":"bd-1pd","type":"blocks","created_at":"2026-01-27T22:31:53.387284578Z","created_by":"ubuntu"},{"issue_id":"bd-2tj","depends_on_id":"bd-35g","type":"blocks","created_at":"2026-01-27T22:31:53.935875752Z","created_by":"ubuntu"},{"issue_id":"bd-2tj","depends_on_id":"bd-3l0","type":"blocks","created_at":"2026-01-27T22:31:54.500590553Z","created_by":"ubuntu"},{"issue_id":"bd-2tj","depends_on_id":"bd-c75","type":"parent-child","created_at":"2026-01-27T22:13:37.792555333Z","created_by":"ubuntu"},{"issue_id":"bd-2tj","depends_on_id":"bd-hc0","type":"blocks","created_at":"2026-01-27T22:33:20.155974038Z","created_by":"ubuntu"},{"issue_id":"bd-2tj","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:33:26.302913466Z","created_by":"ubuntu"}]}
{"id":"bd-2wt","title":"Add color field to CursorState","description":"Spec section 11.3 requires CursorState to have color: Rgba field for cursor color. Currently missing. Add the field and update cursor color operations.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-27T18:14:36.838881364Z","created_by":"ubuntu","updated_at":"2026-01-27T18:20:05.733090442Z","closed_at":"2026-01-27T18:20:05.733029649Z","close_reason":"Added color: Option<Rgba> field to CursorState at src/terminal/cursor.rs:31 with set_color() method","compaction_level":0,"original_size":0}
{"id":"bd-2x0","title":"[EPIC] Syntax Highlighting System","description":"# Epic: Syntax Highlighting System\n\n## Background & Motivation\n\nOpenTUI currently has a basic `SyntaxStyleRegistry` in `src/highlight/` that provides infrastructure for registering named styles (keyword, string, comment, etc.) but has NO actual tokenization or highlighting implementation. This is a significant gap because:\n\n1. **Text editors are a primary use case** - The EditorView component exists specifically for building editor-like applications, but without syntax highlighting, it's severely limited\n2. **The architecture is ready** - StyledSegment, TextBuffer, and the rendering pipeline already support styled text spans; we just need tokenization\n3. **Competitive necessity** - Any serious terminal UI library needs syntax highlighting to be viable for developer tools\n\n## Goals\n\n1. Implement a flexible, extensible tokenizer architecture that can support multiple languages\n2. Provide built-in support for common languages (Rust, Python, JavaScript, Markdown, JSON, TOML)\n3. Integrate seamlessly with existing TextBuffer and EditorView components\n4. Support custom themes with easy color scheme switching\n5. Maintain OpenTUI's performance standards (incremental re-highlighting, lazy evaluation)\n\n## Design Principles\n\n- **Correctness over speed** - Highlighting should be accurate; we can optimize later\n- **Incremental by default** - Only re-tokenize changed regions\n- **Theme-agnostic tokenization** - Tokenizers produce semantic tokens; themes map to colors\n- **No external dependencies** - Keep the library lean; avoid tree-sitter or similar heavy deps\n\n## Non-Goals\n\n- Full LSP/semantic highlighting (that's application-level)\n- Every language under the sun (users can add custom tokenizers)\n- Perfect parsing (we're doing syntax highlighting, not compilation)\n\n## Success Criteria\n\n- Can highlight Rust code in the editor example with keywords, strings, comments colored\n- Can switch themes at runtime without re-tokenizing\n- Incremental highlighting works (editing middle of file doesn't re-highlight entire file)\n- At least 5 built-in language tokenizers\n- Comprehensive test coverage for tokenizers\n\n## Estimated Scope\n\n~2000-3000 LOC across tokenizer infrastructure, language implementations, themes, and tests.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:37:06.318637099Z","created_by":"ubuntu","updated_at":"2026-01-25T15:23:16.952312825Z","closed_at":"2026-01-25T15:23:16.952293578Z","close_reason":"All subtasks completed: tokenizers, themes, and integration done","compaction_level":0,"original_size":0,"labels":["epic","highlight"]}
{"id":"bd-2x0.1","title":"Define Token and TokenKind types","description":"# Task: Define Token and TokenKind types\n\n## Context\n\nThis is the foundational data model for the entire syntax highlighting system. Every tokenizer will produce `Token` instances, and every theme will map `TokenKind` variants to styles.\n\n## What to Implement\n\nCreate `src/highlight/token.rs` with:\n\n### TokenKind Enum\n\n```rust\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\npub enum TokenKind {\n    // Keywords\n    Keyword,           // fn, let, if, else, for, while, etc.\n    KeywordControl,    // if, else, match, loop, return, break\n    KeywordType,       // struct, enum, trait, impl, type\n    KeywordModifier,   // pub, mut, const, static, async, unsafe\n    \n    // Literals\n    String,            // \"hello\", 'c'\n    StringEscape,      // \\n, \\t, \\x00, etc. inside strings\n    Number,            // 42, 3.14, 0xFF, 1_000_000\n    Boolean,           // true, false\n    \n    // Identifiers\n    Identifier,        // variable names, function names\n    Type,              // type names (PascalCase convention)\n    Constant,          // SCREAMING_CASE constants\n    Function,          // function/method names\n    Macro,             // macro invocations (Rust: foo!)\n    \n    // Comments\n    Comment,           // // single line\n    CommentBlock,      // /* block */\n    CommentDoc,        // /// or //! doc comments\n    \n    // Operators and punctuation\n    Operator,          // +, -, *, /, =, ==, etc.\n    Punctuation,       // (, ), {, }, [, ], ;, :, etc.\n    Delimiter,         // < > for generics, | for closures\n    \n    // Special\n    Attribute,         // #[derive(...)]\n    Lifetime,          // 'a, 'static\n    Label,             // 'label: for labeled loops\n    \n    // Markup (for markdown, etc.)\n    Heading,           // # Heading\n    Link,              // [text](url)\n    Emphasis,          // *italic*, **bold**\n    CodeInline,        // `code`\n    CodeBlock,         // ```code```\n    \n    // Errors\n    Error,             // Invalid syntax\n    \n    // Default\n    Text,              // Plain text, whitespace\n}\n```\n\n### Token Struct\n\n```rust\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct Token {\n    pub kind: TokenKind,\n    pub start: usize,    // Byte offset in source\n    pub end: usize,      // Byte offset (exclusive)\n}\n\nimpl Token {\n    pub fn new(kind: TokenKind, start: usize, end: usize) -> Self { ... }\n    pub fn len(&self) -> usize { self.end - self.start }\n    pub fn is_empty(&self) -> bool { self.len() == 0 }\n    pub fn range(&self) -> std::ops::Range<usize> { self.start..self.end }\n}\n```\n\n### TokenSpan (for rendering)\n\n```rust\n/// A token with the actual text slice for rendering\n#[derive(Clone, Debug)]\npub struct TokenSpan<'a> {\n    pub kind: TokenKind,\n    pub text: &'a str,\n}\n```\n\n## Design Decisions\n\n1. **Byte offsets, not char offsets** - Byte offsets are faster and work directly with Rust strings. The rope can convert to char offsets if needed.\n\n2. **Granular TokenKind** - We have many variants (KeywordControl vs Keyword) to allow themes to be very specific. Themes can always map multiple kinds to the same style.\n\n3. **No style in Token** - Tokens are semantic; styles are applied by themes. This separation allows runtime theme switching without re-tokenizing.\n\n4. **Copy/Clone for TokenKind** - It's a small enum, should be cheap to copy.\n\n## Testing\n\n- Test Token construction and accessors\n- Test TokenKind is Copy\n- Test TokenSpan lifetime handling\n- Property tests for range validity (start <= end)\n\n## Files to Create/Modify\n\n- CREATE: `src/highlight/token.rs`\n- MODIFY: `src/highlight/mod.rs` (add `pub mod token; pub use token::*;`)\n\n## Acceptance Criteria\n\n- [ ] TokenKind covers all common syntax elements\n- [ ] Token struct is efficient (no heap allocation)\n- [ ] All types implement necessary traits (Debug, Clone, PartialEq)\n- [ ] Unit tests pass\n- [ ] `cargo clippy` passes","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:37:59.510660429Z","created_by":"ubuntu","updated_at":"2026-01-25T01:17:46.361240373Z","closed_at":"2026-01-25T01:17:46.361221147Z","close_reason":"Completed","compaction_level":0,"original_size":0,"labels":["core","highlight"],"dependencies":[{"issue_id":"bd-2x0.1","depends_on_id":"bd-2x0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2x0.10","title":"Integrate syntax highlighting with TextBuffer and EditorView","description":"# Task: Integrate syntax highlighting with TextBuffer and EditorView\n\n## Context\n\nThis is the critical integration task that connects the tokenization and theming systems to the existing text editing infrastructure. After this, users can simply enable highlighting on an EditorView and get colored syntax.\n\n## What to Implement\n\n### 1. HighlightedBuffer\n\nA wrapper that adds highlighting capability to TextBuffer:\n\n```rust\n/// TextBuffer with syntax highlighting support.\npub struct HighlightedBuffer {\n    buffer: TextBuffer,\n    tokenizer: Option<Box<dyn Tokenizer>>,\n    theme: Theme,\n    \n    // Per-line token cache\n    line_tokens: Vec<Vec<Token>>,\n    line_states: Vec<LineState>,  // State at END of each line\n    \n    // Dirty tracking for incremental updates\n    dirty_from: Option<usize>,  // First dirty line\n}\n\nimpl HighlightedBuffer {\n    pub fn new(buffer: TextBuffer) -> Self { ... }\n    pub fn with_tokenizer(mut self, tokenizer: Box<dyn Tokenizer>) -> Self { ... }\n    pub fn with_theme(mut self, theme: Theme) -> Self { ... }\n    \n    /// Set the tokenizer (triggers full re-highlight)\n    pub fn set_tokenizer(&mut self, tokenizer: Option<Box<dyn Tokenizer>>) { ... }\n    \n    /// Set the theme (no re-tokenization needed)\n    pub fn set_theme(&mut self, theme: Theme) { ... }\n    \n    /// Get tokens for a line (uses cache)\n    pub fn tokens_for_line(&self, line: usize) -> &[Token] { ... }\n    \n    /// Get styled segments for rendering a line\n    pub fn styled_line(&self, line: usize) -> Vec<StyledSegment> { ... }\n    \n    /// Mark lines as dirty (called after edits)\n    pub fn mark_dirty(&mut self, from_line: usize) { ... }\n    \n    /// Re-tokenize dirty lines\n    pub fn update_highlighting(&mut self) { ... }\n    \n    // Delegate TextBuffer methods\n    pub fn text(&self) -> &str { self.buffer.text() }\n    pub fn line(&self, n: usize) -> Option<&str> { self.buffer.line(n) }\n    pub fn line_count(&self) -> usize { self.buffer.line_count() }\n    // ... etc\n}\n```\n\n### 2. Incremental Highlighting Algorithm\n\nWhen text is edited, we don't want to re-tokenize the entire file:\n\n```rust\nimpl HighlightedBuffer {\n    pub fn update_highlighting(&mut self) {\n        let Some(dirty_from) = self.dirty_from.take() else { return };\n        let Some(tokenizer) = &self.tokenizer else { return };\n        \n        // Get state at start of dirty region\n        let mut state = if dirty_from == 0 {\n            LineState::Normal\n        } else {\n            self.line_states[dirty_from - 1]\n        };\n        \n        // Re-tokenize from dirty_from until state matches cached state\n        for line_idx in dirty_from..self.buffer.line_count() {\n            let line = self.buffer.line(line_idx).unwrap_or(\"\");\n            let (tokens, new_state) = tokenizer.tokenize_line(line, state);\n            \n            // Update cache\n            if line_idx < self.line_tokens.len() {\n                self.line_tokens[line_idx] = tokens;\n                \n                // Check if we can stop early\n                if line_idx < self.line_states.len() \n                   && self.line_states[line_idx] == new_state \n                {\n                    // State matches - rest of file is unchanged\n                    break;\n                }\n                self.line_states[line_idx] = new_state;\n            } else {\n                self.line_tokens.push(tokens);\n                self.line_states.push(new_state);\n            }\n            \n            state = new_state;\n        }\n    }\n}\n```\n\n### 3. EditorView Integration\n\nModify EditorView to use HighlightedBuffer:\n\n```rust\nimpl EditorView {\n    /// Enable syntax highlighting with auto-detected tokenizer\n    pub fn enable_highlighting(&mut self, registry: &TokenizerRegistry) {\n        // Detect language from file extension or content\n        // Set up HighlightedBuffer\n    }\n    \n    /// Set highlighting theme\n    pub fn set_highlighting_theme(&mut self, theme: Theme) { ... }\n    \n    // In render method:\n    fn render_line(&self, line_idx: usize, buffer: &mut OptimizedBuffer, ...) {\n        if let Some(highlighted) = &self.highlighted_buffer {\n            // Get styled segments and render with colors\n            for segment in highlighted.styled_line(line_idx) {\n                buffer.draw_text(x, y, &segment.text, segment.style);\n                x += segment.width();\n            }\n        } else {\n            // Plain text rendering (existing code)\n        }\n    }\n}\n```\n\n### 4. Edit Tracking\n\nHook into TextBuffer edits to mark lines dirty:\n\n```rust\nimpl HighlightedBuffer {\n    pub fn insert(&mut self, pos: usize, text: &str) {\n        let line = self.buffer.line_of_byte(pos);\n        self.buffer.insert(pos, text);\n        self.mark_dirty(line);\n        // Adjust line_tokens/line_states vectors for inserted lines\n    }\n    \n    pub fn delete(&mut self, range: Range<usize>) {\n        let line = self.buffer.line_of_byte(range.start);\n        self.buffer.delete(range);\n        self.mark_dirty(line);\n        // Adjust line_tokens/line_states vectors for deleted lines\n    }\n}\n```\n\n## Design Decisions\n\n1. **Wrapper pattern** - HighlightedBuffer wraps TextBuffer rather than modifying it. This keeps TextBuffer simple and highlighting optional.\n\n2. **Per-line caching** - Store tokens per line for efficient lookup. Line-based makes sense for editors.\n\n3. **State propagation** - Track state at end of each line. When state matches cached state, stop re-tokenizing.\n\n4. **Lazy update** - `mark_dirty()` just records; `update_highlighting()` does actual work. Caller controls when highlighting runs.\n\n5. **Theme is separate from tokenization** - Changing theme doesn't re-tokenize; just changes how tokens map to styles.\n\n## Dependencies\n\n- Requires: bd-2x0.1 (Token types)\n- Requires: bd-2x0.2 (Tokenizer trait)\n- Requires: bd-2x0.3 (Theme system)\n- Requires: At least one language tokenizer (bd-2x0.4)\n\n## Testing\n\n```rust\n#[test] fn test_highlighted_buffer_basic() { ... }\n#[test] fn test_incremental_update_single_line() { ... }\n#[test] fn test_incremental_update_multiline_change() { ... }\n#[test] fn test_incremental_state_propagation() { ... }\n#[test] fn test_insert_preserves_highlighting() { ... }\n#[test] fn test_delete_preserves_highlighting() { ... }\n#[test] fn test_theme_change_no_retokenize() { ... }\n```\n\n## Files to Create/Modify\n\n- CREATE: `src/highlight/buffer.rs`\n- MODIFY: `src/text/editor.rs` (EditorView integration)\n- MODIFY: `src/highlight/mod.rs`\n- MODIFY: `src/lib.rs` (re-export HighlightedBuffer)\n\n## Acceptance Criteria\n\n- [ ] HighlightedBuffer provides styled segments for lines\n- [ ] Incremental highlighting works (edit middle of file, only affected lines re-tokenize)\n- [ ] Theme changes don't re-tokenize\n- [ ] EditorView renders with colors when highlighting enabled\n- [ ] Performance: <1ms to update highlighting after typical edit\n- [ ] Comprehensive tests for incremental update algorithm","notes":"## CRITICAL: AGENTS.md Alignment\n\n### Performance Requirements\nPer AGENTS.md \"Performance Requirements\" section:\n- **Zero allocations on update_highlighting()** for typical edits (single line change)\n- **O(n) where n = changed lines** not total lines\n- **<1ms for incremental update** (already in acceptance criteria)\n- **<10ms for full re-highlight** of 10,000 line file\n\n### Memory Layout\nTokens should be stored contiguously per line for cache efficiency. Consider:\n```rust\n// Good: contiguous storage\nline_tokens: Vec<Vec<Token>>  // Each inner Vec is contiguous\n\n// Consider for v2: arena allocation\n// tokens: bumpalo::Bump with per-line slices\n```\n\n### Integration Points\nWhen modifying `src/text/editor.rs`:\n- Do NOT break existing EditorView API\n- Highlighting should be opt-in via `.with_highlighting()` builder\n- Non-highlighted editors should have zero overhead\n\n### Coverage Target\nAGENTS.md requires src/text/ ≥75% coverage. Ensure new EditorView integration maintains this.\n\n### Testing with Tracing\nPer bd-2x0.11 and bd-2x0.12:\n- All tests use tracing (info!, debug!)\n- Run: RUST_LOG=debug cargo test highlight_integration -- --nocapture","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T00:47:45.693296960Z","created_by":"ubuntu","updated_at":"2026-01-25T11:13:36.847274370Z","closed_at":"2026-01-25T11:13:36.847253541Z","close_reason":"Integrated HighlightedBuffer with TextBuffer/EditorView; added incremental update + theme refresh and tests","compaction_level":0,"original_size":0,"labels":["highlight","integration"],"dependencies":[{"issue_id":"bd-2x0.10","depends_on_id":"bd-2x0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.10","depends_on_id":"bd-2x0.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.10","depends_on_id":"bd-2x0.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.10","depends_on_id":"bd-2x0.3","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.10","depends_on_id":"bd-2x0.4","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2x0.11","title":"Unit Tests for Syntax Highlighting Tokenizers","description":"# Unit Tests for Syntax Highlighting Tokenizers\n\n## Purpose\n\nComprehensive unit test suite for all tokenizers in the syntax highlighting system. Each test must have detailed assertions and logging to ensure correctness and debuggability.\n\n## Test Categories\n\n### 1. Token Type Tests\n\nFor each language tokenizer, test that tokens are categorized correctly:\n\n```rust\n#[cfg(test)]\nmod tokenizer_tests {\n    use super::*;\n    use tracing::{info, debug};\n\n    fn setup_test_logging() {\n        let _ = tracing_subscriber::fmt()\n            .with_max_level(tracing::Level::DEBUG)\n            .with_test_writer()\n            .try_init();\n    }\n\n    #[test]\n    fn test_rust_keyword_recognition() {\n        setup_test_logging();\n        let tokenizer = RustTokenizer::new();\n        \n        let keywords = [\"fn\", \"let\", \"mut\", \"if\", \"else\", \"match\"];\n        \n        for kw in keywords {\n            info\\!(keyword = kw, \"Testing keyword recognition\");\n            let (tokens, state) = tokenizer.tokenize_line(kw, LineState::Normal);\n            debug\\!(?tokens, \"Tokenization result\");\n            assert\\!(\\!tokens.is_empty(), \"Should produce tokens for keyword: {kw}\");\n            assert\\!(matches\\!(tokens[0].kind, TokenKind::Keyword | TokenKind::KeywordControl));\n        }\n    }\n}\n```\n\n### 2. Multi-line State Tests\n\nTest state propagation for multi-line constructs (block comments, raw strings):\n- Start of block comment -> InBlockComment state\n- Middle lines -> remain in comment state\n- End of block comment -> Normal state\n- Nested comments track depth correctly\n\n### 3. Edge Case Tests\n\n- Lifetime vs char literal disambiguation\n- Empty input handling\n- Whitespace-only lines\n- Maximum token length\n- Unicode in identifiers\n\n### 4. Token Span Verification\n\nVerify token spans are contiguous and cover entire line:\n- No gaps between tokens\n- No overlaps\n- Sum of spans equals line length\n\n## Logging Requirements\n\nAll tests MUST use tracing crate:\n- info\\!() for test case identification\n- debug\\!() for intermediate values\n- Run with: RUST_LOG=debug cargo test -- --nocapture\n\n## Files to Create\n\n- src/highlight/tests/tokenizer_tests.rs\n- src/highlight/tests/mod.rs\n- src/highlight/languages/tests/rust_tests.rs\n- src/highlight/languages/tests/python_tests.rs\n\n## Acceptance Criteria\n\n- [ ] 100+ unit tests across all tokenizers\n- [ ] Every TokenKind has at least one test\n- [ ] Multi-line state transitions tested\n- [ ] Edge cases documented and tested\n- [ ] Token span coverage verified\n- [ ] All tests use tracing for logging\n- [ ] Coverage >90% for tokenizer code\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T01:58:09.875606795Z","created_by":"ubuntu","updated_at":"2026-01-25T12:25:55.707714206Z","closed_at":"2026-01-25T12:25:55.707696242Z","close_reason":"Implemented tokenizer test suite across languages with tracing logs and span/state checks","compaction_level":0,"original_size":0,"labels":["highlight","testing"],"dependencies":[{"issue_id":"bd-2x0.11","depends_on_id":"bd-2x0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.11","depends_on_id":"bd-2x0.4","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.11","depends_on_id":"bd-2x0.5","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.11","depends_on_id":"bd-2x0.6","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.11","depends_on_id":"bd-2x0.7","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.11","depends_on_id":"bd-2x0.8","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.11","depends_on_id":"bd-2x0.9","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2x0.12","title":"E2E Test Suite for Syntax Highlighting","description":"# E2E Test Suite for Syntax Highlighting\n\n## Purpose\n\nEnd-to-end integration tests that verify syntax highlighting works correctly in realistic scenarios. These tests validate the entire pipeline from source code to rendered output.\n\n## Test Architecture\n\n### 1. Test Harness Script\n\nCreate `tests/e2e/highlight_e2e.rs`:\n\n```rust\n//! E2E tests for syntax highlighting pipeline\n//! \n//! Run with: cargo test --test highlight_e2e -- --nocapture\n//! With logging: RUST_LOG=debug cargo test --test highlight_e2e -- --nocapture\n\nuse opentui::{\n    OptimizedBuffer, Renderer, Rgba, Style,\n    highlight::{HighlightedBuffer, Theme, RustTokenizer, TokenizerRegistry},\n    text::TextBuffer,\n};\nuse std::time::Instant;\nuse tracing::{info, debug, warn, error, span, Level};\n\nfn init_logging() {\n    let _ = tracing_subscriber::fmt()\n        .with_max_level(Level::DEBUG)\n        .with_target(true)\n        .with_file(true)\n        .with_line_number(true)\n        .try_init();\n}\n\n#[test]\nfn e2e_rust_file_highlighting() {\n    init_logging();\n    let span = span!(Level::INFO, \"e2e_rust_file\");\n    let _enter = span.enter();\n    \n    info!(\"Starting Rust file E2E test\");\n    \n    // Load test fixture\n    let source = include_str!(\"fixtures/sample.rs\");\n    info!(lines = source.lines().count(), \"Loaded test fixture\");\n    \n    // Create text buffer\n    let text_buffer = TextBuffer::from_str(source);\n    debug!(line_count = text_buffer.line_count(), \"TextBuffer created\");\n    \n    // Set up highlighting\n    let tokenizer = Box::new(RustTokenizer::new());\n    let theme = Theme::dark();\n    let mut highlighted = HighlightedBuffer::new(text_buffer)\n        .with_tokenizer(tokenizer)\n        .with_theme(theme);\n    \n    // Initial highlighting\n    let start = Instant::now();\n    highlighted.update_highlighting();\n    let initial_time = start.elapsed();\n    info!(?initial_time, \"Initial highlighting complete\");\n    \n    // Verify tokens were generated\n    for line_idx in 0..highlighted.line_count().min(10) {\n        let tokens = highlighted.tokens_for_line(line_idx);\n        let line_text = highlighted.line(line_idx).unwrap_or(\"\");\n        debug!(\n            line = line_idx,\n            token_count = tokens.len(),\n            text_preview = &line_text[..line_text.len().min(40)],\n            \"Line tokenized\"\n        );\n        \n        // Verify tokens cover entire line\n        if !tokens.is_empty() {\n            let last_token = tokens.last().unwrap();\n            assert_eq!(\n                last_token.span.end, line_text.len(),\n                \"Tokens should cover entire line {line_idx}\"\n            );\n        }\n    }\n    \n    // Test incremental update\n    info!(\"Testing incremental update\");\n    let edit_line = highlighted.line_count() / 2;\n    highlighted.mark_dirty(edit_line);\n    \n    let start = Instant::now();\n    highlighted.update_highlighting();\n    let incremental_time = start.elapsed();\n    info!(?incremental_time, \"Incremental update complete\");\n    \n    assert!(\n        incremental_time < initial_time,\n        \"Incremental update should be faster than initial\"\n    );\n    \n    info!(\"E2E test PASSED\");\n}\n\n#[test]\nfn e2e_theme_switching() {\n    init_logging();\n    info!(\"Testing theme switching\");\n    \n    let source = \"fn main() { println!(\\\"hello\\\"); }\";\n    let text_buffer = TextBuffer::from_str(source);\n    let mut highlighted = HighlightedBuffer::new(text_buffer)\n        .with_tokenizer(Box::new(RustTokenizer::new()))\n        .with_theme(Theme::dark());\n    \n    highlighted.update_highlighting();\n    let dark_styles = highlighted.styled_line(0);\n    debug!(?dark_styles, \"Dark theme styles\");\n    \n    // Switch theme\n    highlighted.set_theme(Theme::light());\n    let light_styles = highlighted.styled_line(0);\n    debug!(?light_styles, \"Light theme styles\");\n    \n    // Styles should differ (different colors)\n    assert_ne!(\n        format!(\"{:?}\", dark_styles),\n        format!(\"{:?}\", light_styles),\n        \"Theme switch should change styles\"\n    );\n    \n    info!(\"Theme switching test PASSED\");\n}\n\n#[test]\nfn e2e_render_highlighted_buffer() {\n    init_logging();\n    info!(\"Testing buffer rendering with highlighting\");\n    \n    let source = r#\"\nfn main() {\n    let x = 42;\n    println!(\"x = {}\", x);\n}\n\"#;\n    \n    let text_buffer = TextBuffer::from_str(source);\n    let mut highlighted = HighlightedBuffer::new(text_buffer)\n        .with_tokenizer(Box::new(RustTokenizer::new()))\n        .with_theme(Theme::dark());\n    highlighted.update_highlighting();\n    \n    // Render to buffer\n    let mut buffer = OptimizedBuffer::new(80, 24);\n    buffer.clear(Rgba::from_hex(\"#1a1a2e\").unwrap());\n    \n    for (y, line_idx) in (0..highlighted.line_count()).enumerate() {\n        let styled_segments = highlighted.styled_line(line_idx);\n        let mut x = 0u32;\n        \n        for segment in styled_segments {\n            buffer.draw_text(x, y as u32, &segment.text, segment.style);\n            x += segment.text.len() as u32;\n            debug!(y, x_start = x, text = segment.text, \"Drew segment\");\n        }\n    }\n    \n    // Verify buffer has content\n    let non_empty_cells = buffer.cells().iter()\n        .filter(|c| !c.is_empty())\n        .count();\n    info!(non_empty_cells, \"Buffer populated\");\n    assert!(non_empty_cells > 50, \"Buffer should have significant content\");\n    \n    info!(\"Render test PASSED\");\n}\n```\n\n### 2. Test Fixtures\n\nCreate `tests/e2e/fixtures/`:\n- `sample.rs` - Rust code with all syntax elements\n- `sample.py` - Python code covering all features\n- `sample.json` - JSON with nested structures\n- `sample.toml` - TOML configuration file\n- `sample.md` - Markdown with code blocks\n\n### 3. Performance Regression Tests\n\n```rust\n#[test]\nfn e2e_performance_regression() {\n    init_logging();\n    info!(\"Performance regression test\");\n    \n    // Generate large file\n    let mut source = String::new();\n    for i in 0..1000 {\n        source.push_str(&format!(\"fn func_{i}() {{ let x = {i}; }}\\n\"));\n    }\n    \n    let text_buffer = TextBuffer::from_str(&source);\n    let mut highlighted = HighlightedBuffer::new(text_buffer)\n        .with_tokenizer(Box::new(RustTokenizer::new()))\n        .with_theme(Theme::dark());\n    \n    // Initial highlight should complete in reasonable time\n    let start = Instant::now();\n    highlighted.update_highlighting();\n    let elapsed = start.elapsed();\n    \n    info!(?elapsed, lines = 1000, \"Performance timing\");\n    assert!(\n        elapsed.as_millis() < 500,\n        \"1000 lines should highlight in <500ms, took {:?}\", elapsed\n    );\n    \n    // Incremental update should be much faster\n    highlighted.mark_dirty(500);\n    let start = Instant::now();\n    highlighted.update_highlighting();\n    let incremental = start.elapsed();\n    \n    info!(?incremental, \"Incremental update timing\");\n    assert!(\n        incremental.as_millis() < 50,\n        \"Incremental update should be <50ms, took {:?}\", incremental\n    );\n}\n```\n\n### 4. Error Handling Tests\n\n```rust\n#[test]\nfn e2e_malformed_input_handling() {\n    init_logging();\n    info!(\"Testing malformed input handling\");\n    \n    let malformed_inputs = [\n        \"fn main() { /* unterminated comment\",\n        r#\"let s = \"unterminated string\"#,\n        \"let x = 0x\",  // Invalid hex\n        \"fn ()\",  // Invalid syntax\n    ];\n    \n    for input in malformed_inputs {\n        info!(input, \"Testing malformed input\");\n        let text_buffer = TextBuffer::from_str(input);\n        let mut highlighted = HighlightedBuffer::new(text_buffer)\n            .with_tokenizer(Box::new(RustTokenizer::new()))\n            .with_theme(Theme::dark());\n        \n        // Should not panic\n        highlighted.update_highlighting();\n        \n        // Should produce some output\n        let tokens = highlighted.tokens_for_line(0);\n        debug!(?tokens, \"Tokens for malformed input\");\n        assert!(!tokens.is_empty() || input.is_empty());\n        \n        info!(\"Handled gracefully\");\n    }\n}\n```\n\n## Running E2E Tests\n\n```bash\n# Run all E2E tests with logging\nRUST_LOG=debug cargo test --test highlight_e2e -- --nocapture\n\n# Run specific test\nRUST_LOG=debug cargo test --test highlight_e2e e2e_rust_file -- --nocapture\n\n# Run with timing\nRUST_LOG=info cargo test --test highlight_e2e -- --nocapture 2>&1 | grep -E \"(PASSED|timing|elapsed)\"\n```\n\n## Files to Create\n\n- tests/e2e/highlight_e2e.rs\n- tests/e2e/fixtures/sample.rs\n- tests/e2e/fixtures/sample.py\n- tests/e2e/fixtures/sample.json\n- tests/e2e/fixtures/sample.toml\n- tests/e2e/fixtures/sample.md\n\n## Acceptance Criteria\n\n- [ ] E2E test harness compiles and runs\n- [ ] All fixture files created with comprehensive syntax coverage\n- [ ] Performance regression tests pass\n- [ ] Theme switching verified\n- [ ] Buffer rendering verified\n- [ ] Malformed input handled gracefully\n- [ ] All tests have detailed tracing logs\n- [ ] CI integration documented\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-25T01:58:50.402895543Z","created_by":"ubuntu","updated_at":"2026-01-25T12:37:46.966062315Z","closed_at":"2026-01-25T12:37:46.966040985Z","close_reason":"Added highlight E2E integration tests with fixtures, rendering, perf, and error handling","compaction_level":0,"original_size":0,"labels":["e2e","highlight","testing"],"dependencies":[{"issue_id":"bd-2x0.12","depends_on_id":"bd-2x0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.12","depends_on_id":"bd-2x0.10","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.12","depends_on_id":"bd-2x0.11","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2x0.2","title":"Define Tokenizer trait and LineState","description":"# Task: Define Tokenizer trait and LineState\n\n## Context\n\nThe Tokenizer trait is the core abstraction that all language-specific tokenizers will implement. The design must support:\n\n1. **Incremental tokenization** - Only re-tokenize changed lines\n2. **Multi-line constructs** - Block comments, multi-line strings, heredocs\n3. **State continuity** - Remember state at end of each line for the next line\n\n## What to Implement\n\nCreate `src/highlight/tokenizer.rs` with:\n\n### LineState Enum\n\nRepresents the lexical state at the end of a line that affects how the next line starts:\n\n```rust\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Default)]\npub enum LineState {\n    #[default]\n    Normal,                    // Normal code context\n    InString(StringKind),      // Inside a string literal\n    InComment(CommentKind),    // Inside a comment\n    InRawString(u8),           // Rust r#\"...\"# with # count\n    InHeredoc(HeredocKind),    // Shell/Ruby heredocs\n}\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\npub enum StringKind {\n    Double,      // \"...\"\n    Single,      // '...'\n    Backtick,    // `...` (JS template literals)\n    Triple,      // \"\"\"...\"\"\" or '''...''' (Python)\n}\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\npub enum CommentKind {\n    Block,       // /* ... */\n    Doc,         // /** ... */ or similar\n    Nested(u8),  // For languages with nested /* /* */ */ (depth count)\n}\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\npub enum HeredocKind {\n    Shell,       // <<EOF ... EOF\n    Ruby,        // <<~HEREDOC ... HEREDOC\n}\n```\n\n### Tokenizer Trait\n\n```rust\npub trait Tokenizer: Send + Sync {\n    /// Human-readable name of this tokenizer\n    fn name(&self) -> &str;\n    \n    /// File extensions this tokenizer handles (e.g., [\"rs\", \"rust\"])\n    fn extensions(&self) -> &[&str];\n    \n    /// Tokenize a single line given the state from the previous line.\n    /// Returns: (tokens, state_at_end_of_line)\n    fn tokenize_line(&self, line: &str, state: LineState) -> (Vec<Token>, LineState);\n    \n    /// Convenience: tokenize entire text (calls tokenize_line repeatedly)\n    fn tokenize(&self, text: &str) -> Vec<Token> {\n        let mut tokens = Vec::new();\n        let mut state = LineState::Normal;\n        let mut offset = 0;\n        \n        for line in text.lines() {\n            let (line_tokens, new_state) = self.tokenize_line(line, state);\n            for mut token in line_tokens {\n                token.start += offset;\n                token.end += offset;\n                tokens.push(token);\n            }\n            offset += line.len() + 1; // +1 for newline\n            state = new_state;\n        }\n        tokens\n    }\n}\n```\n\n### TokenizerRegistry\n\n```rust\n#[derive(Default)]\npub struct TokenizerRegistry {\n    tokenizers: Vec<Box<dyn Tokenizer>>,\n    by_extension: HashMap<String, usize>,  // extension -> index\n    by_name: HashMap<String, usize>,       // name -> index\n}\n\nimpl TokenizerRegistry {\n    pub fn new() -> Self { ... }\n    \n    /// Register a tokenizer\n    pub fn register(&mut self, tokenizer: Box<dyn Tokenizer>) { ... }\n    \n    /// Get tokenizer by file extension\n    pub fn for_extension(&self, ext: &str) -> Option<&dyn Tokenizer> { ... }\n    \n    /// Get tokenizer by name\n    pub fn by_name(&self, name: &str) -> Option<&dyn Tokenizer> { ... }\n    \n    /// Create registry with all built-in tokenizers\n    pub fn with_builtins() -> Self { ... }\n}\n```\n\n## Design Decisions\n\n1. **Line-based tokenization** - Most editors work line-by-line; this fits naturally. Each line's state is stored for incremental updates.\n\n2. **LineState is Copy** - Must be cheap to store per-line. We limit nesting depth to u8 (255 levels is plenty).\n\n3. **Tokenizer is Send + Sync** - Allows parallel tokenization of different files or file sections.\n\n4. **Default trait implementation for tokenize()** - Languages only need to implement `tokenize_line`; full-file tokenization is automatic.\n\n## Dependencies\n\n- Requires: bd-2x0.1 (Token and TokenKind types)\n\n## Testing\n\n- Test LineState default is Normal\n- Test Tokenizer default tokenize() implementation\n- Test TokenizerRegistry registration and lookup\n- Test extension matching (case-insensitive)\n\n## Files to Create/Modify\n\n- CREATE: `src/highlight/tokenizer.rs`\n- MODIFY: `src/highlight/mod.rs`\n\n## Acceptance Criteria\n\n- [ ] Tokenizer trait supports incremental line-by-line tokenization\n- [ ] LineState covers multi-line constructs for common languages\n- [ ] TokenizerRegistry provides lookup by extension and name\n- [ ] All traits implement Send + Sync where needed\n- [ ] Unit tests pass","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:38:52.363804077Z","created_by":"ubuntu","updated_at":"2026-01-25T01:20:47.883661938Z","closed_at":"2026-01-25T01:20:47.883641980Z","close_reason":"Completed","compaction_level":0,"original_size":0,"labels":["core","highlight"],"dependencies":[{"issue_id":"bd-2x0.2","depends_on_id":"bd-2x0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.2","depends_on_id":"bd-2x0.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2x0.3","title":"Implement Theme system for syntax highlighting","description":"# Task: Implement Theme system for syntax highlighting\n\n## Context\n\nA Theme maps TokenKind variants to visual Styles. This separation between tokenization (semantic) and styling (visual) is crucial because:\n\n1. **Runtime theme switching** - Users can change color schemes without re-tokenizing\n2. **Theme sharing** - Themes are independent of language; one theme works for all languages\n3. **Customization** - Users can override specific token styles easily\n\n## What to Implement\n\nCreate `src/highlight/theme.rs` with:\n\n### Theme Struct\n\n```rust\nuse crate::{Style, Rgba};\nuse super::TokenKind;\nuse std::collections::HashMap;\n\n#[derive(Clone, Debug)]\npub struct Theme {\n    name: String,\n    styles: HashMap<TokenKind, Style>,\n    default_style: Style,\n    \n    // Editor chrome colors (not token-related)\n    background: Rgba,\n    foreground: Rgba,\n    selection: Rgba,\n    cursor: Rgba,\n    line_number: Rgba,\n    line_number_active: Rgba,\n    gutter: Rgba,\n}\n\nimpl Theme {\n    pub fn new(name: impl Into<String>) -> Self { ... }\n    \n    /// Get style for a token kind, falling back to default\n    pub fn style_for(&self, kind: TokenKind) -> Style { ... }\n    \n    /// Set style for a token kind\n    pub fn set_style(&mut self, kind: TokenKind, style: Style) -> &mut Self { ... }\n    \n    /// Builder-style methods for fluent API\n    pub fn with_style(mut self, kind: TokenKind, style: Style) -> Self { ... }\n    pub fn with_background(mut self, color: Rgba) -> Self { ... }\n    pub fn with_foreground(mut self, color: Rgba) -> Self { ... }\n    \n    // Getters for editor chrome\n    pub fn background(&self) -> Rgba { ... }\n    pub fn foreground(&self) -> Rgba { ... }\n    pub fn selection(&self) -> Rgba { ... }\n    pub fn cursor(&self) -> Rgba { ... }\n    pub fn line_number(&self) -> Rgba { ... }\n    pub fn gutter(&self) -> Rgba { ... }\n}\n```\n\n### Built-in Themes\n\nProvide several high-quality default themes:\n\n```rust\nimpl Theme {\n    /// Dark theme inspired by popular editor themes (like Dracula/One Dark)\n    pub fn dark() -> Self {\n        Self::new(\"Dark\")\n            .with_background(Rgba::from_hex(\"#282a36\").unwrap())\n            .with_foreground(Rgba::from_hex(\"#f8f8f2\").unwrap())\n            .with_style(TokenKind::Keyword, Style::fg(Rgba::from_hex(\"#ff79c6\").unwrap()))\n            .with_style(TokenKind::KeywordControl, Style::fg(Rgba::from_hex(\"#ff79c6\").unwrap()))\n            .with_style(TokenKind::KeywordType, Style::fg(Rgba::from_hex(\"#8be9fd\").unwrap()).with_italic())\n            .with_style(TokenKind::String, Style::fg(Rgba::from_hex(\"#f1fa8c\").unwrap()))\n            .with_style(TokenKind::Number, Style::fg(Rgba::from_hex(\"#bd93f9\").unwrap()))\n            .with_style(TokenKind::Comment, Style::fg(Rgba::from_hex(\"#6272a4\").unwrap()).with_italic())\n            .with_style(TokenKind::Function, Style::fg(Rgba::from_hex(\"#50fa7b\").unwrap()))\n            .with_style(TokenKind::Type, Style::fg(Rgba::from_hex(\"#8be9fd\").unwrap()))\n            .with_style(TokenKind::Operator, Style::fg(Rgba::from_hex(\"#ff79c6\").unwrap()))\n            // ... etc\n    }\n    \n    /// Light theme for bright environments\n    pub fn light() -> Self { ... }\n    \n    /// High-contrast theme for accessibility\n    pub fn high_contrast() -> Self { ... }\n    \n    /// Monochrome theme (different weights/styles only)\n    pub fn monochrome() -> Self { ... }\n    \n    /// Solarized dark\n    pub fn solarized_dark() -> Self { ... }\n    \n    /// Solarized light  \n    pub fn solarized_light() -> Self { ... }\n}\n```\n\n### ThemeRegistry\n\n```rust\n#[derive(Default)]\npub struct ThemeRegistry {\n    themes: HashMap<String, Theme>,\n    current: String,\n}\n\nimpl ThemeRegistry {\n    pub fn new() -> Self { ... }\n    \n    /// Create with all built-in themes, \"dark\" as default\n    pub fn with_builtins() -> Self { ... }\n    \n    pub fn register(&mut self, theme: Theme) { ... }\n    pub fn get(&self, name: &str) -> Option<&Theme> { ... }\n    pub fn current(&self) -> &Theme { ... }\n    pub fn set_current(&mut self, name: &str) -> Result<(), &str> { ... }\n    pub fn list(&self) -> impl Iterator<Item = &str> { ... }\n}\n```\n\n## Design Decisions\n\n1. **HashMap for styles** - Fast lookup by TokenKind; most themes define <30 styles so memory is fine.\n\n2. **Default style fallback** - Unknown TokenKinds get the default (usually just foreground color).\n\n3. **Editor chrome in Theme** - Background, selection, gutter colors belong with the theme since they should be coordinated.\n\n4. **Built-in themes** - Ship with good defaults so users get a great experience immediately.\n\n5. **Builder pattern** - Makes theme construction readable and chainable.\n\n## Dependencies\n\n- Requires: bd-2x0.1 (Token and TokenKind types)\n\n## Testing\n\n- Test style lookup with and without specific style defined\n- Test fallback to default style\n- Test built-in themes have all essential styles defined\n- Test ThemeRegistry current/switching\n- Verify colors are valid in built-in themes\n\n## Files to Create/Modify\n\n- CREATE: `src/highlight/theme.rs`\n- MODIFY: `src/highlight/mod.rs`\n\n## Acceptance Criteria\n\n- [ ] Theme provides style lookup for all TokenKind variants\n- [ ] At least 4 built-in themes (dark, light, high_contrast, solarized)\n- [ ] ThemeRegistry supports registration and switching\n- [ ] Built-in themes are visually appealing and accessible\n- [ ] Unit tests pass","notes":"## CRITICAL: Performance Requirements\n\nTheme style lookup is called on EVERY token during rendering. It MUST be:\n- **O(1) lookup** - Use array indexed by TokenKind discriminant, not HashMap\n- **Zero allocation** - Return &Style reference, not cloned Style\n- **Cache-friendly** - Styles stored contiguously\n\n### Recommended Implementation\n\n```rust\npub struct Theme {\n    // Array indexed by TokenKind discriminant for O(1) lookup\n    styles: [Style; TokenKind::COUNT],\n    default_style: Style,\n    // ... chrome colors\n}\n\nimpl Theme {\n    pub fn style_for(&self, kind: TokenKind) -> &Style {\n        &self.styles[kind as usize]\n    }\n}\n```\n\n### Why This Matters\n\nFor a 10,000 line file with ~50 tokens/line = 500,000 style lookups.\n- HashMap: ~50ns/lookup = 25ms overhead\n- Array: ~1ns/lookup = 0.5ms overhead\n\n## Testing with Tracing\n\nAll tests must use tracing for logging per bd-2x0.11:\n- info!() for test case entry\n- debug!() for style values\n- Run: RUST_LOG=debug cargo test theme -- --nocapture\n\n## Accessibility Note\n\nHigh contrast theme MUST meet WCAG AA contrast requirements (4.5:1 minimum).","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:41:35.949529175Z","created_by":"ubuntu","updated_at":"2026-01-25T10:57:09.403592200Z","closed_at":"2026-01-25T10:57:09.403572333Z","close_reason":"Implemented Theme system with array lookup, built-in themes, registry, and tests","compaction_level":0,"original_size":0,"labels":["core","highlight"],"dependencies":[{"issue_id":"bd-2x0.3","depends_on_id":"bd-2x0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.3","depends_on_id":"bd-2x0.1","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2x0.4","title":"Implement Rust tokenizer","description":"# Task: Implement Rust tokenizer\n\n## Context\n\nRust is the primary language for OpenTUI users (it's a Rust library!), so this tokenizer should be the most complete and well-tested. It will serve as the reference implementation for other language tokenizers.\n\n## Rust Syntax Elements to Handle\n\n### Keywords (sorted by category)\n\n```\n// Control flow\nif, else, match, loop, while, for, break, continue, return\n\n// Definitions\nfn, let, const, static, struct, enum, trait, impl, type, mod, use\n\n// Modifiers\npub, mut, ref, move, async, await, unsafe, extern, dyn\n\n// Other\nas, in, where, Self, self, super, crate, true, false\n```\n\n### Literals\n\n```rust\n// Strings\n\"hello\"              // Regular string\nr\"raw string\"        // Raw string\nr#\"with \"quotes\"\"#   // Raw string with # delimiters\nb\"bytes\"             // Byte string\nbr\"raw bytes\"        // Raw byte string\n'c'                  // Char\nb'c'                 // Byte\n\n// Numbers\n42                   // Integer\n42_000               // With underscores\n3.14                 // Float\n1e10                 // Scientific\n0xFF                 // Hex\n0o77                 // Octal\n0b1010               // Binary\n42u32                // With suffix\n3.14f64              // Float with suffix\n```\n\n### Comments\n\n```rust\n// Single line\n/* Block comment */\n/** Outer doc comment */\n//! Inner doc comment\n/*! Inner block doc */\n```\n\n### Special Rust Syntax\n\n```rust\n#[derive(Debug)]     // Attributes\n#![allow(unused)]    // Inner attributes\n'lifetime            // Lifetimes\n'label: loop {}      // Labels\nfoo!()               // Macros\n$var                 // Macro variables\n```\n\n## Implementation\n\nCreate `src/highlight/languages/rust.rs`:\n\n```rust\npub struct RustTokenizer;\n\nimpl RustTokenizer {\n    pub fn new() -> Self { Self }\n    \n    // Keyword detection\n    fn is_keyword(word: &str) -> Option<TokenKind> { ... }\n    \n    // Number literal parsing\n    fn scan_number(&self, chars: &[char], start: usize) -> Option<(Token, usize)> { ... }\n    \n    // String literal parsing (handles raw strings)\n    fn scan_string(&self, chars: &[char], start: usize, state: LineState) \n        -> Option<(Token, usize, LineState)> { ... }\n    \n    // Attribute parsing\n    fn scan_attribute(&self, chars: &[char], start: usize) \n        -> Option<(Token, usize)> { ... }\n}\n\nimpl Tokenizer for RustTokenizer {\n    fn name(&self) -> &str { \"Rust\" }\n    fn extensions(&self) -> &[&str] { &[\"rs\"] }\n    \n    fn tokenize_line(&self, line: &str, state: LineState) -> (Vec<Token>, LineState) {\n        // Main tokenization loop\n        // Handle:\n        // 1. Continue multi-line state (string, comment)\n        // 2. Scan whitespace\n        // 3. Try each token type in order of likelihood\n        // 4. Track state changes for multi-line constructs\n    }\n}\n```\n\n## Multi-line Handling\n\nThe Rust tokenizer must handle these multi-line constructs:\n\n1. **Block comments** - `/* ... */` including nested `/* /* */ */`\n2. **Raw strings** - `r#\"...\"#` can span lines\n3. **Regular strings** - Cannot span lines (but we should handle gracefully)\n\n## Edge Cases\n\n- `r#` vs `r##` vs `r###` raw string detection\n- Nested block comments with depth tracking\n- Lifetime vs char literal (`'a` vs `'a'`)\n- Macro invocation detection (`foo!` pattern)\n- Distinguishing types (PascalCase) from other identifiers\n- Number suffixes (`42u32`) - suffix is part of Number token\n\n## Dependencies\n\n- Requires: bd-2x0.2 (Tokenizer trait)\n\n## Testing\n\nTest files to create in `src/highlight/languages/tests/`:\n\n```rust\n#[test]\nfn test_rust_keywords() { ... }\n\n#[test]\nfn test_rust_strings() { ... }\n\n#[test]\nfn test_rust_raw_strings() { ... }\n\n#[test]\nfn test_rust_numbers() { ... }\n\n#[test]\nfn test_rust_comments() { ... }\n\n#[test]\nfn test_rust_attributes() { ... }\n\n#[test]\nfn test_rust_lifetimes() { ... }\n\n#[test]\nfn test_rust_macros() { ... }\n\n#[test]\nfn test_rust_multiline_comment() { ... }\n\n#[test]\nfn test_rust_nested_comments() { ... }\n\n#[test]\nfn test_rust_real_code() {\n    // Test against actual Rust code snippets\n}\n```\n\n## Files to Create/Modify\n\n- CREATE: `src/highlight/languages/mod.rs`\n- CREATE: `src/highlight/languages/rust.rs`\n- MODIFY: `src/highlight/mod.rs`\n\n## Acceptance Criteria\n\n- [ ] All Rust keywords recognized\n- [ ] All string types handled (regular, raw, byte)\n- [ ] Numbers with all prefixes/suffixes recognized\n- [ ] Comments including nested block comments\n- [ ] Attributes and inner attributes\n- [ ] Lifetimes distinguished from char literals\n- [ ] Macro invocations detected\n- [ ] Multi-line constructs work correctly\n- [ ] >90% test coverage for tokenizer\n- [ ] Manual testing with real Rust files looks correct","notes":"## CRITICAL: Performance Requirements (per AGENTS.md)\n\n1. **Zero allocations per token** - Use &str slices into the source line, NOT String\n2. **No per-grapheme allocation** - Reuse buffers where possible\n3. **<1μs per line** for typical Rust code (verified by benchmark)\n4. **Hot path optimization** - Keyword lookup via perfect hash or trie, not HashMap\n\n## Benchmark Requirement\n\nAdd to `benches/highlight.rs`:\n```rust\nfn bench_rust_tokenizer(c: &mut Criterion) {\n    let source = include_str\\!(\"../src/lib.rs\");\n    let tokenizer = RustTokenizer::new();\n    \n    c.bench_function(\"rust_tokenize_1000_lines\", |b| {\n        b.iter(|| {\n            let mut state = LineState::Normal;\n            for line in source.lines().take(1000) {\n                let (_, new_state) = tokenizer.tokenize_line(line, state);\n                state = new_state;\n            }\n        })\n    });\n}\n```\n\nPerformance regression >10% should fail CI.\n\n## Testing with Tracing\n\nAll tests MUST use tracing per bd-2x0.11:\n- Run with: RUST_LOG=debug cargo test rust_tokenizer -- --nocapture","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-25T00:42:47.590327099Z","created_by":"ubuntu","updated_at":"2026-01-25T10:49:34.071795555Z","closed_at":"2026-01-25T10:49:34.071770227Z","close_reason":"Implemented nested comments/byte strings/labels; added tests and ran check/clippy/test","compaction_level":0,"original_size":0,"labels":["highlight","lang"],"dependencies":[{"issue_id":"bd-2x0.4","depends_on_id":"bd-2x0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.4","depends_on_id":"bd-2x0.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2x0.5","title":"Implement Python tokenizer","description":"# Task: Implement Python tokenizer\n\n## Context\n\nPython is one of the most popular programming languages and a common choice for scripting and automation. A Python tokenizer expands OpenTUI's utility for building developer tools.\n\n## Python Syntax Elements\n\n### Keywords\n\n```python\n# Control flow\nif, elif, else, for, while, break, continue, return, yield, pass, raise, try, except, finally, with, as, assert\n\n# Definitions\ndef, class, lambda, global, nonlocal, import, from\n\n# Operators as keywords\nand, or, not, in, is, True, False, None\n\n# Async\nasync, await\n```\n\n### Literals\n\n```python\n# Strings (many varieties!)\n\"double\"\n'single'\n\"\"\"triple double\"\"\"\n'''triple single'''\nf\"f-string {expr}\"\nr\"raw string\"\nb\"bytes\"\nrf\"raw f-string\"\n\n# Numbers\n42\n3.14\n1_000_000\n0xFF\n0o77\n0b1010\n1e10\n3+4j  # Complex\n```\n\n### Comments\n\n```python\n# Single line only (Python has no block comments)\n```\n\n### Decorators\n\n```python\n@decorator\n@decorator(args)\n@module.decorator\n```\n\n### Special Syntax\n\n```python\n:=  # Walrus operator\n->  # Return type annotation\n...  # Ellipsis\n```\n\n## Multi-line Handling\n\nPython has several multi-line constructs:\n\n1. **Triple-quoted strings** - `\"\"\"...\"\"\"` or `'''...'''`\n2. **Implicit line continuation** - Inside `()`, `[]`, `{}`\n3. **Explicit continuation** - Line ending with `\\`\n\nFor simplicity, we'll handle triple-quoted strings fully. Continuation handling is optional (code still looks reasonable without it).\n\n## Implementation\n\nCreate `src/highlight/languages/python.rs`:\n\n```rust\npub struct PythonTokenizer;\n\nimpl Tokenizer for PythonTokenizer {\n    fn name(&self) -> &str { \"Python\" }\n    fn extensions(&self) -> &[&str] { &[\"py\", \"pyw\", \"pyi\"] }\n    \n    fn tokenize_line(&self, line: &str, state: LineState) -> (Vec<Token>, LineState) {\n        // Handle triple-quoted string continuation\n        // Scan tokens: comments, strings, decorators, keywords, numbers, operators\n    }\n}\n```\n\n## Edge Cases\n\n- f-strings with nested expressions (`f\"{x + {y}}\"`)\n- Distinguishing `@decorator` from `@` operator\n- Triple-quoted string with embedded quotes\n- Raw f-strings (`rf\"...\"`)\n- Type annotations with `->` and `:`\n\n## Dependencies\n\n- Requires: bd-2x0.2 (Tokenizer trait)\n\n## Testing\n\n```rust\n#[test] fn test_python_keywords() { ... }\n#[test] fn test_python_strings() { ... }\n#[test] fn test_python_fstrings() { ... }\n#[test] fn test_python_triple_quoted() { ... }\n#[test] fn test_python_decorators() { ... }\n#[test] fn test_python_numbers() { ... }\n```\n\n## Files to Create/Modify\n\n- CREATE: `src/highlight/languages/python.rs`\n- MODIFY: `src/highlight/languages/mod.rs`\n\n## Acceptance Criteria\n\n- [ ] All Python keywords recognized\n- [ ] String varieties (single, double, triple, raw, f-string, bytes)\n- [ ] Decorators highlighted\n- [ ] Triple-quoted multi-line strings work\n- [ ] Comments highlighted\n- [ ] Numbers with all formats\n- [ ] Test coverage >80%","notes":"AGENTS.md alignment: Performance target <1μs/line. Zero-allocation on hot path where possible. Tests must use tracing (info!, debug!) for detailed logging. Consider &str slices and avoid String allocations during tokenization.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T00:43:57.425342981Z","created_by":"ubuntu","updated_at":"2026-01-25T11:57:54.330007016Z","closed_at":"2026-01-25T11:57:54.329983652Z","close_reason":"Implemented Python tokenizer + tests","compaction_level":0,"original_size":0,"labels":["highlight","lang"],"dependencies":[{"issue_id":"bd-2x0.5","depends_on_id":"bd-2x0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.5","depends_on_id":"bd-2x0.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2x0.6","title":"Implement JavaScript/TypeScript tokenizer","description":"# Task: Implement JavaScript/TypeScript tokenizer\n\n## Context\n\nJavaScript is ubiquitous in web development, and TypeScript is increasingly popular. Supporting both with a single tokenizer (TypeScript is a superset) maximizes utility.\n\n## JavaScript/TypeScript Syntax Elements\n\n### Keywords\n\n```javascript\n// Control flow\nif, else, switch, case, default, for, while, do, break, continue, return, throw, try, catch, finally\n\n// Definitions\nfunction, var, let, const, class, extends, import, export, from, as, default\n\n// Values\ntrue, false, null, undefined, NaN, Infinity, this, super\n\n// Operators as keywords\ntypeof, instanceof, in, of, new, delete, void, yield, await\n\n// TypeScript additions\ninterface, type, enum, namespace, module, declare, readonly, abstract, implements, private, protected, public, static, override, as, is, keyof, infer, never, unknown, any\n```\n\n### Literals\n\n```javascript\n// Strings\n\"double\"\n'single'\n`template ${expr}`  // Template literals with interpolation\n\n// Numbers\n42\n3.14\n0xFF\n0o77\n0b1010\n1e10\n1_000_000  // Numeric separators (ES2021)\n123n       // BigInt\n\n// Regex\n/pattern/flags\n```\n\n### Comments\n\n```javascript\n// Single line\n/* Block comment */\n/** JSDoc comment */\n```\n\n### Special Syntax\n\n```javascript\n=>      // Arrow functions\n?.      // Optional chaining\n??      // Nullish coalescing\n...     // Spread/rest\n#field  // Private fields\n@decorator  // Decorators (stage 3)\n```\n\n## Multi-line Handling\n\n1. **Template literals** - `` `...` `` can span multiple lines\n2. **Block comments** - `/* ... */`\n3. **Regex literals** - Cannot span lines (but `/` is tricky to distinguish from division)\n\n## Implementation\n\nCreate `src/highlight/languages/javascript.rs`:\n\n```rust\npub struct JavaScriptTokenizer {\n    typescript_mode: bool,  // Enable TS-specific keywords\n}\n\nimpl JavaScriptTokenizer {\n    pub fn javascript() -> Self { Self { typescript_mode: false } }\n    pub fn typescript() -> Self { Self { typescript_mode: true } }\n}\n\nimpl Tokenizer for JavaScriptTokenizer {\n    fn name(&self) -> &str { \n        if self.typescript_mode { \"TypeScript\" } else { \"JavaScript\" } \n    }\n    fn extensions(&self) -> &[&str] { \n        if self.typescript_mode { \n            &[\"ts\", \"tsx\", \"mts\", \"cts\"] \n        } else { \n            &[\"js\", \"jsx\", \"mjs\", \"cjs\"] \n        }\n    }\n    \n    fn tokenize_line(&self, line: &str, state: LineState) -> (Vec<Token>, LineState) {\n        // Handle template literal continuation\n        // Handle block comment continuation\n        // Distinguish regex from division (context-sensitive!)\n    }\n}\n```\n\n## Edge Cases\n\n- Regex vs division (`/pattern/` vs `a / b`)\n- Template literal interpolation (`${expr}`)\n- JSX (optional; could be separate tokenizer)\n- Automatic semicolon insertion (doesn't affect highlighting)\n- Private fields (`#name`)\n\n## Dependencies\n\n- Requires: bd-2x0.2 (Tokenizer trait)\n\n## Testing\n\n```rust\n#[test] fn test_js_keywords() { ... }\n#[test] fn test_js_strings() { ... }\n#[test] fn test_js_template_literals() { ... }\n#[test] fn test_js_regex() { ... }\n#[test] fn test_ts_types() { ... }\n#[test] fn test_js_comments() { ... }\n```\n\n## Files to Create/Modify\n\n- CREATE: `src/highlight/languages/javascript.rs`\n- MODIFY: `src/highlight/languages/mod.rs`\n\n## Acceptance Criteria\n\n- [ ] All JS keywords recognized\n- [ ] TypeScript keywords recognized when in TS mode\n- [ ] String types (single, double, template)\n- [ ] Template literal interpolation\n- [ ] Regex literals (basic detection)\n- [ ] Block and line comments\n- [ ] Numbers including BigInt\n- [ ] Test coverage >80%","notes":"AGENTS.md alignment: Performance target <1μs/line. Zero-allocation on hot path - return token spans (&str slices) not owned Strings. Tests must use tracing (info!, debug!) for detailed logging. Template literal state tracking in LineState.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T00:44:39.565482163Z","created_by":"ubuntu","updated_at":"2026-01-25T12:08:12.998457414Z","closed_at":"2026-01-25T12:08:12.998439039Z","close_reason":"Implemented JS/TS tokenizer + tests","compaction_level":0,"original_size":0,"labels":["highlight","lang"],"dependencies":[{"issue_id":"bd-2x0.6","depends_on_id":"bd-2x0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.6","depends_on_id":"bd-2x0.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2x0.7","title":"Implement JSON tokenizer","description":"# Task: Implement JSON tokenizer\n\n## Context\n\nJSON is ubiquitous for configuration and data exchange. It's also one of the simplest languages to tokenize, making it a good starting point and reference for testing the highlighting system.\n\n## JSON Syntax (Complete Specification)\n\nJSON has exactly these token types:\n\n### Structural Characters\n```\n{ } [ ] : ,\n```\n\n### Literals\n```json\n\"string\"       // Strings (always double-quoted)\n123            // Numbers (integer)\n-456           // Negative numbers\n3.14           // Decimal numbers\n1e10           // Scientific notation\ntrue           // Boolean\nfalse          // Boolean\nnull           // Null\n```\n\n### String Escapes\n```json\n\\\"   \\\\   \\/   \\b   \\f   \\n   \\r   \\t   \\uXXXX\n```\n\n## Implementation\n\nCreate `src/highlight/languages/json.rs`:\n\n```rust\npub struct JsonTokenizer;\n\nimpl Tokenizer for JsonTokenizer {\n    fn name(&self) -> &str { \"JSON\" }\n    fn extensions(&self) -> &[&str] { &[\"json\", \"jsonc\", \"json5\"] }\n    \n    fn tokenize_line(&self, line: &str, state: LineState) -> (Vec<Token>, LineState) {\n        // JSON is line-based for most purposes\n        // Strings technically can't span lines in strict JSON\n        // But we handle JSONC (with comments) and JSON5 (with multi-line)\n    }\n}\n```\n\n### Token Mapping\n\n| JSON Element | TokenKind |\n|-------------|-----------|\n| `\"key\":` (object key) | Identifier or String |\n| `\"value\"` | String |\n| `\\n`, `\\t`, etc. | StringEscape |\n| `123`, `-3.14` | Number |\n| `true`, `false` | Boolean |\n| `null` | Constant |\n| `{`, `}`, `[`, `]` | Punctuation |\n| `:`, `,` | Delimiter |\n| `//` comment (JSONC) | Comment |\n| `/* */` comment (JSONC) | CommentBlock |\n\n## Edge Cases\n\n- Distinguishing object keys from string values (keys are followed by `:`)\n- Unicode escapes (`\\uXXXX`)\n- Scientific notation (`1e-10`)\n- JSONC comment support\n- Invalid JSON (highlight as Error)\n\n## Dependencies\n\n- Requires: bd-2x0.2 (Tokenizer trait)\n\n## Testing\n\n```rust\n#[test] fn test_json_strings() { ... }\n#[test] fn test_json_numbers() { ... }\n#[test] fn test_json_booleans_null() { ... }\n#[test] fn test_json_structure() { ... }\n#[test] fn test_json_escapes() { ... }\n#[test] fn test_jsonc_comments() { ... }\n```\n\n## Files to Create/Modify\n\n- CREATE: `src/highlight/languages/json.rs`\n- MODIFY: `src/highlight/languages/mod.rs`\n\n## Acceptance Criteria\n\n- [ ] All JSON value types highlighted correctly\n- [ ] Object keys distinguished from string values\n- [ ] String escapes highlighted\n- [ ] Numbers with all formats (int, float, scientific, negative)\n- [ ] JSONC comment support\n- [ ] Invalid syntax highlighted as Error\n- [ ] Test coverage >90% (JSON is simple enough for high coverage)","notes":"## Performance Requirements\n\nSame as all tokenizers (per AGENTS.md):\n- **Zero allocations per token** - Use &str slices into source\n- **<1μs per line** for typical JSON\n- JSON is simpler than Rust, so performance should be even better\n\n## Testing with Tracing\n\nPer bd-2x0.11:\n- All tests use tracing (info!, debug!)\n- Run: RUST_LOG=debug cargo test json_tokenizer -- --nocapture\n\n## Note on JSONC Support\n\nJSONC (JSON with Comments) is common in VS Code configs. Support single-line `//` and block `/* */` comments, but mark the file extension separately (.jsonc) to not confuse strict JSON parsers.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T00:45:17.329963585Z","created_by":"ubuntu","updated_at":"2026-01-25T12:12:13.051156990Z","closed_at":"2026-01-25T12:12:13.051138806Z","close_reason":"Implemented JSON tokenizer + tests","compaction_level":0,"original_size":0,"labels":["highlight","lang"],"dependencies":[{"issue_id":"bd-2x0.7","depends_on_id":"bd-2x0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.7","depends_on_id":"bd-2x0.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2x0.8","title":"Implement TOML tokenizer","description":"# Task: Implement TOML tokenizer\n\n## Context\n\nTOML (Tom's Obvious Minimal Language) is the standard configuration format for Rust projects (Cargo.toml). Since OpenTUI is a Rust library, excellent TOML support is particularly relevant.\n\n## TOML Syntax Elements\n\n### Structure\n\n```toml\n[section]\n[section.subsection]\n[[array.of.tables]]\n\nkey = value\n\"quoted key\" = value\ndotted.key = value\n```\n\n### Values\n\n```toml\n# Strings\nstring = \"basic\"\nmultiline = \"\"\"\n  multi\n  line\n\"\"\"\nliteral = 'no \\escapes'\nliteral_multiline = '''\n  multi\n  line\n'''\n\n# Numbers\ninteger = 42\nhex = 0xDEADBEEF\noctal = 0o755\nbinary = 0b11010110\nfloat = 3.14\ninfinity = inf\nnan = nan\n\n# Boolean\nbool = true\n\n# Dates and times\ndate = 2024-01-15\ntime = 14:30:00\ndatetime = 2024-01-15T14:30:00Z\ndatetime_local = 2024-01-15T14:30:00\n\n# Arrays\narray = [1, 2, 3]\nnested = [[1, 2], [3, 4]]\n\n# Inline tables\ninline = { key = \"value\", other = 42 }\n```\n\n### Comments\n\n```toml\n# Single line comment only\nkey = \"value\"  # End of line comment\n```\n\n## Implementation\n\nCreate `src/highlight/languages/toml.rs`:\n\n```rust\npub struct TomlTokenizer;\n\nimpl Tokenizer for TomlTokenizer {\n    fn name(&self) -> &str { \"TOML\" }\n    fn extensions(&self) -> &[&str] { &[\"toml\"] }\n    \n    fn tokenize_line(&self, line: &str, state: LineState) -> (Vec<Token>, LineState) {\n        // Handle multi-line string continuation\n        // Section headers [name]\n        // Key = value pairs\n        // Comments\n    }\n}\n```\n\n### Token Mapping\n\n| TOML Element | TokenKind |\n|-------------|-----------|\n| `[section]` | Type |\n| `[[array]]` | Type |\n| `key =` | Identifier |\n| `\"string\"` | String |\n| `42`, `0xFF` | Number |\n| `true`/`false` | Boolean |\n| `2024-01-15` | Number (or custom Date) |\n| `# comment` | Comment |\n| `=`, `,` | Operator |\n| `[`, `]`, `{`, `}` | Punctuation |\n\n## Multi-line Handling\n\n- Multi-line basic strings: `\"\"\" ... \"\"\"`\n- Multi-line literal strings: `''' ... '''`\n\n## Edge Cases\n\n- Dotted keys (`package.version`)\n- Bare keys vs quoted keys\n- Date/time literals (many formats)\n- Unicode in strings and keys\n- Inline tables vs regular tables\n\n## Dependencies\n\n- Requires: bd-2x0.2 (Tokenizer trait)\n\n## Testing\n\n```rust\n#[test] fn test_toml_sections() { ... }\n#[test] fn test_toml_key_values() { ... }\n#[test] fn test_toml_strings() { ... }\n#[test] fn test_toml_multiline_strings() { ... }\n#[test] fn test_toml_numbers() { ... }\n#[test] fn test_toml_dates() { ... }\n#[test] fn test_toml_arrays() { ... }\n#[test] fn test_toml_inline_tables() { ... }\n```\n\n## Files to Create/Modify\n\n- CREATE: `src/highlight/languages/toml.rs`\n- MODIFY: `src/highlight/languages/mod.rs`\n\n## Acceptance Criteria\n\n- [ ] Section headers `[name]` highlighted as Type\n- [ ] Keys highlighted as Identifier\n- [ ] All string variants (basic, literal, multiline)\n- [ ] Numbers including special formats (hex, date/time)\n- [ ] Comments highlighted\n- [ ] Multi-line strings work correctly\n- [ ] Test coverage >85%","notes":"AGENTS.md alignment: Performance target <1μs/line. Zero-allocation tokenization - return spans not owned strings. Tests must use tracing (info!, debug!) for detailed logging. TOML is critical for Cargo.toml editing use cases.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T00:45:50.867576492Z","created_by":"ubuntu","updated_at":"2026-01-25T12:15:42.748398045Z","closed_at":"2026-01-25T12:15:42.748379901Z","close_reason":"Implemented TOML tokenizer + tests","compaction_level":0,"original_size":0,"labels":["highlight","lang"],"dependencies":[{"issue_id":"bd-2x0.8","depends_on_id":"bd-2x0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.8","depends_on_id":"bd-2x0.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2x0.9","title":"Implement Markdown tokenizer","description":"# Task: Implement Markdown tokenizer\n\n## Context\n\nMarkdown is the de facto standard for documentation, READMEs, and notes. Terminal-based editors and tools frequently work with Markdown, making it a high-value tokenizer to include.\n\n## Markdown Syntax Elements\n\n### Headings\n\n```markdown\n# Heading 1\n## Heading 2\n### Heading 3 (up to 6)\n\nAlternative Heading\n==================\n\nAlternative H2\n--------------\n```\n\n### Emphasis\n\n```markdown\n*italic* or _italic_\n**bold** or __bold__\n***bold italic***\n~~strikethrough~~\n```\n\n### Code\n\n```markdown\n`inline code`\n\n    indented code block (4 spaces)\n\n```language\nfenced code block\n```\n```\n\n### Links and Images\n\n```markdown\n[link text](url)\n[link text](url \"title\")\n[reference link][ref]\n[ref]: url\n\n![alt text](image.png)\n![alt text](image.png \"title\")\n```\n\n### Lists\n\n```markdown\n- Unordered item\n* Also unordered\n+ Also unordered\n\n1. Ordered item\n2. Ordered item\n\n- [ ] Task item unchecked\n- [x] Task item checked\n```\n\n### Blockquotes\n\n```markdown\n> Quote line\n> Continued quote\n```\n\n### Horizontal Rules\n\n```markdown\n---\n***\n___\n```\n\n### Tables (GFM)\n\n```markdown\n| Header | Header |\n|--------|--------|\n| Cell   | Cell   |\n```\n\n### HTML\n\n```markdown\n<div>Raw HTML</div>\n```\n\n## Implementation\n\nCreate `src/highlight/languages/markdown.rs`:\n\n```rust\npub struct MarkdownTokenizer;\n\nimpl Tokenizer for MarkdownTokenizer {\n    fn name(&self) -> &str { \"Markdown\" }\n    fn extensions(&self) -> &[&str] { &[\"md\", \"markdown\", \"mkd\", \"mkdn\"] }\n    \n    fn tokenize_line(&self, line: &str, state: LineState) -> (Vec<Token>, LineState) {\n        // Handle fenced code block continuation\n        // Line-start elements: headings, lists, blockquotes, HR\n        // Inline elements: emphasis, code, links\n    }\n}\n```\n\n### Token Mapping\n\n| Markdown Element | TokenKind |\n|-----------------|-----------|\n| `# Heading` | Heading |\n| `*italic*` | Emphasis |\n| `**bold**` | Emphasis + Bold style |\n| `[text](url)` | Link |\n| `![alt](url)` | Link |\n| `` `code` `` | CodeInline |\n| ``` ```code``` ``` | CodeBlock |\n| `> quote` | Comment (or custom Quote) |\n| `- item` | Punctuation + Text |\n| `---` | Punctuation |\n\n## Multi-line Handling\n\n1. **Fenced code blocks** - ``` ... ``` (track the fence marker)\n2. **Indented code blocks** - 4+ spaces at line start\n3. **Multi-line blockquotes** - Lines starting with `>`\n\n## Edge Cases\n\n- Escaping: `\\*not italic\\*`\n- Nested emphasis: `***bold and italic***`\n- Links with parentheses in URL\n- Code spans with backticks inside: ``` `` `code` `` ```\n- Setext headings (underline style)\n- HTML blocks\n\n## Dependencies\n\n- Requires: bd-2x0.2 (Tokenizer trait)\n\n## Testing\n\n```rust\n#[test] fn test_md_headings() { ... }\n#[test] fn test_md_emphasis() { ... }\n#[test] fn test_md_code_inline() { ... }\n#[test] fn test_md_code_blocks() { ... }\n#[test] fn test_md_links() { ... }\n#[test] fn test_md_lists() { ... }\n#[test] fn test_md_blockquotes() { ... }\n#[test] fn test_md_escaping() { ... }\n```\n\n## Files to Create/Modify\n\n- CREATE: `src/highlight/languages/markdown.rs`\n- MODIFY: `src/highlight/languages/mod.rs`\n\n## Acceptance Criteria\n\n- [ ] Headings (ATX and Setext styles)\n- [ ] Emphasis (italic, bold, strikethrough)\n- [ ] Inline and fenced code\n- [ ] Links and images\n- [ ] Lists (ordered, unordered, task)\n- [ ] Blockquotes\n- [ ] Fenced code block continuation\n- [ ] Escape sequences\n- [ ] Test coverage >85%","notes":"AGENTS.md alignment: Performance target <1μs/line. Zero-allocation tokenization. Tests must use tracing (info!, debug!) for detailed logging. Markdown is high-value for documentation editing in terminal apps.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-25T00:46:23.879677476Z","created_by":"ubuntu","updated_at":"2026-01-25T12:19:02.704966007Z","closed_at":"2026-01-25T12:19:02.704947462Z","close_reason":"Implemented Markdown tokenizer + tests","compaction_level":0,"original_size":0,"labels":["highlight","lang"],"dependencies":[{"issue_id":"bd-2x0.9","depends_on_id":"bd-2x0","type":"parent-child","created_at":"2026-01-27T06:52:24Z","created_by":"import"},{"issue_id":"bd-2x0.9","depends_on_id":"bd-2x0.2","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-2xk1","title":"demo_showcase quality: run fmt/clippy/test gates before landing","description":"# demo_showcase Quality — Run fmt/clippy/test Gates Before Landing\n\n## Purpose\n\nThe demo will touch many parts of the codebase. This bead ensures we don’t “ship a broken flagship”.\n\n## Required Gates\n\nRun these locally (and ensure CI passes):\n\n- `cargo fmt --check`\n- `cargo clippy --all-targets -- -D warnings`\n- `cargo test`\n\nIf demo modifies hot paths or rendering behavior, optionally run the buffer benchmark suite (`cargo bench --bench buffer`) as a sanity check.\n\n## Acceptance Notes\n\n- No formatting drift.\n- No clippy warnings.\n- All tests pass, including demo compile/smoke tests.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:29:54.666703286Z","created_by":"ubuntu","updated_at":"2026-01-27T23:13:10.570602896Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","testing"],"dependencies":[{"issue_id":"bd-2xk1","depends_on_id":"bd-10de","type":"blocks","created_at":"2026-01-27T22:33:50.821280848Z","created_by":"ubuntu"},{"issue_id":"bd-2xk1","depends_on_id":"bd-1n67","type":"blocks","created_at":"2026-01-27T22:33:51.409960028Z","created_by":"ubuntu"},{"issue_id":"bd-2xk1","depends_on_id":"bd-2649","type":"blocks","created_at":"2026-01-27T22:51:18.505590317Z","created_by":"ubuntu"},{"issue_id":"bd-2xk1","depends_on_id":"bd-2bnv","type":"blocks","created_at":"2026-01-27T23:13:10.570568702Z","created_by":"ubuntu"},{"issue_id":"bd-2xk1","depends_on_id":"bd-31gz","type":"blocks","created_at":"2026-01-27T22:33:52.010278354Z","created_by":"ubuntu"},{"issue_id":"bd-2xk1","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-01-27T22:29:54.679232573Z","created_by":"ubuntu"},{"issue_id":"bd-2xk1","depends_on_id":"bd-3cj0","type":"blocks","created_at":"2026-01-27T22:51:20.439486754Z","created_by":"ubuntu"},{"issue_id":"bd-2xk1","depends_on_id":"bd-bqd1","type":"blocks","created_at":"2026-01-27T22:51:19.058244445Z","created_by":"ubuntu"},{"issue_id":"bd-2xk1","depends_on_id":"bd-jfno","type":"blocks","created_at":"2026-01-27T22:51:19.654855091Z","created_by":"ubuntu"}]}
{"id":"bd-313","title":"Expand benchmark coverage beyond buffer module","description":"Currently only benches/buffer.rs exists. Add benchmarks for: renderer diff detection, color blending operations, text buffer operations, unicode width calculations.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-21T20:28:46.184813379Z","created_by":"ubuntu","updated_at":"2026-01-21T22:37:44.657047735Z","closed_at":"2026-01-21T22:37:44.656970329Z","close_reason":"Comprehensive benchmarks added for color blending (creation, blending, conversion, interpolation), text buffer (TextBuffer, EditBuffer, cursor movement, undo/redo), renderer diff detection (identical, single change, row change, scattered, full diff), and unicode width calculations (ASCII, CJK, emoji, grapheme operations). All benchmarks compile and run successfully.","compaction_level":0,"original_size":0}
{"id":"bd-31gz","title":"demo_showcase docs: README section (how to run + flags + keybinds)","description":"# demo_showcase Docs — README Section (How to Run + Flags + Keybinds)\n\n## Purpose\n\nThe flagship demo should be discoverable. Add a README section that explains:\n\n- how to run the demo\n- what it demonstrates\n- essential keybinds\n- tour mode and headless smoke mode\n- recommended terminals for best visuals\n\n## Content Requirements\n\nAdd a `Demo Showcase` section to `README.md`:\n\nRun:\n- cargo run --bin demo_showcase\n\nTour (unattended):\n- cargo run --bin demo_showcase -- --tour --exit-after-tour\n\nHeadless smoke:\n- cargo run --bin demo_showcase -- --headless-smoke\n\nHeadless JSON dump (for tests/debugging):\n- cargo run --bin demo_showcase -- --headless-smoke --headless-dump-json\n\nDegradation matrix (example manual run):\n- cargo run --bin demo_showcase -- --headless-smoke --headless-dump-json --headless-size 50x15 --cap-preset minimal\n\nDocument keybinds (or point to the in-app help overlay) and call out terminal recommendations (kitty/alacritty/wezterm/ghostty) for best results.\n\n## Flag Summary (Must Match bd-2iv)\n\nInclude a small, explicit list of supported flags (grouped by category):\n\nInteractive:\n- --fps <N>\n- --tour\n- --exit-after-tour\n- --max-frames <N>\n\nHeadless/testing:\n- --headless-smoke\n- --headless-dump-json\n- --headless-check <name>\n- --headless-size <WxH>\n\nTerminal behavior:\n- --no-mouse\n- --no-alt-screen\n- --no-cap-queries\n\nCapability override:\n- --cap-preset <name>\n\nAdvanced:\n- --threaded\n- --seed <N>\n\n## Acceptance Notes\n\n- README makes it obvious the demo exists and how to run it.\n- Flags documented match the actual CLI (bd-2iv).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:29:37.288336317Z","created_by":"ubuntu","updated_at":"2026-01-27T23:13:03.087136609Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","docs"],"dependencies":[{"issue_id":"bd-31gz","depends_on_id":"bd-1gy","type":"blocks","created_at":"2026-01-27T22:32:38.026379403Z","created_by":"ubuntu"},{"issue_id":"bd-31gz","depends_on_id":"bd-2iv","type":"blocks","created_at":"2026-01-27T22:32:36.008108527Z","created_by":"ubuntu"},{"issue_id":"bd-31gz","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-01-27T22:29:37.300717928Z","created_by":"ubuntu"},{"issue_id":"bd-31gz","depends_on_id":"bd-3l0","type":"blocks","created_at":"2026-01-27T22:32:37.034595590Z","created_by":"ubuntu"}]}
{"id":"bd-35e","title":"demo_showcase UI: toast + notification system (stack + fade)","description":"# demo_showcase UI — Toast + Notification System (Stack + Fade)\n\n## Purpose\n\nToasts make the demo feel like a real application and also give us a constant excuse to show:\n\n- translucent overlays (opacity stack)\n- animated alpha fades (time-driven)\n- crisp typography + spacing\n\nThey also provide immediate feedback when commands/actions occur.\n\n## Behaviors\n\n- Toasts appear in a consistent corner (e.g., bottom-right above the status bar).\n- Multiple toasts stack with a small vertical gap.\n- Each toast has:\n  - severity: Info / Warn / Error\n  - title + optional detail line\n  - TTL (auto-dismiss) with fade-out\n  - optional “action” hint (e.g., `R` retry)\n\n## Rendering Notes\n\n- Background should be semi-transparent with a gradient edge or subtle border.\n- Severity affects accent color and icon glyph.\n- Clip the toast region with scissor so it never draws into the status bar.\n\n## Integration Points\n\nToasts should be produced by:\n\n- command palette executions\n- tour step transitions\n- simulated preview errors/retries\n- clipboard/link actions\n\nImplementation suggestion:\n\n- `struct Toast { created_at, ttl, level, title, detail, ... }`\n- `struct ToastManager { toasts: VecDeque<Toast> }`\n- render in the main render pass after panels but before full-screen overlays.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:24:23.894150944Z","created_by":"ubuntu","updated_at":"2026-01-27T22:32:01.203757246Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","ui"],"dependencies":[{"issue_id":"bd-35e","depends_on_id":"bd-1pd","type":"blocks","created_at":"2026-01-27T22:32:00.676575823Z","created_by":"ubuntu"},{"issue_id":"bd-35e","depends_on_id":"bd-2t3","type":"blocks","created_at":"2026-01-27T22:32:01.203719095Z","created_by":"ubuntu"},{"issue_id":"bd-35e","depends_on_id":"bd-c75","type":"parent-child","created_at":"2026-01-27T22:24:23.906489096Z","created_by":"ubuntu"},{"issue_id":"bd-35e","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:32:00.094359519Z","created_by":"ubuntu"}]}
{"id":"bd-35g","title":"demo_showcase runtime: App state machine (modes, focus, event routing)","description":"# demo_showcase Runtime — App State Machine (Modes, Focus, Routing)\n\n## Purpose\n\nDefine a clean “brain” for the demo so the UI remains coherent as features accumulate.\n\n## Core State\n\nSuggested structure:\n\n```rust\nenum Mode {\n    Normal,\n    Help,\n    CommandPalette,\n    Tour,\n}\n\nenum Focus {\n    Sidebar,\n    Editor,\n    Preview,\n    Logs,\n}\n\nstruct App {\n    mode: Mode,\n    focus: Focus,\n    paused: bool, // e.g. focus lost\n\n    // Panel state\n    sidebar: SidebarState,\n    editor: EditorState,\n    preview: PreviewState,\n    logs: LogState,\n\n    // Overlay state\n    palette: PaletteState,\n    help: HelpState,\n    tour: TourState,\n\n    // UX polish\n    toasts: ToastQueue,\n    last_resize: Option<(u32,u32)>,\n}\n```\n\n## Event Routing Rules\n\n1. **Global shortcuts first** (quit/help/palette/tour/debug/invalidate)\n2. **System events next** (resize, focus gained/lost)\n3. **Mode-specific** handling (help/palette/tour)\n4. **Focused panel** receives remaining key/mouse events\n\nThis prevents conflicts and keeps behavior predictable.\n\n## Action Layer (Optional but Recommended)\n\nInstead of mutating state directly in input handlers, parse events into actions:\n\n```rust\nenum Action {\n    Quit,\n    ToggleHelp,\n    TogglePalette,\n    ToggleTour,\n    CycleFocus(i32),\n    Editor(EditorAction),\n    Sidebar(SidebarAction),\n    Preview(PreviewAction),\n    Logs(LogsAction),\n    Resize(u32,u32),\n    FocusChanged(bool),\n}\n```\n\nThis makes tour mode trivial: it just emits Actions.\n\n## Focus / Hit Testing Integration\n\nMouse clicks should:\n\n- map screen coords → HitGrid id\n- translate id → semantic action (e.g. “sidebar item 3”)\n- update focus + selection consistently\n\n## Output\n\nA well-defined state machine that later UI beads can build on without “spaghetti input handling”.","acceptance_criteria":"Checklist:\n- [ ] Modes are explicit (Normal/Help/Palette/Tour)\n- [ ] Focus routing is explicit and consistent\n- [ ] Global shortcuts take precedence and never conflict\n- [ ] Resize and focus events update app state predictably\n- [ ] HitGrid click IDs map cleanly to semantic actions\n- [ ] Tour mode can drive the app via the same action pathway","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:09:36.517144360Z","created_by":"ubuntu","updated_at":"2026-01-27T23:00:33.568945954Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","runtime"],"dependencies":[{"issue_id":"bd-35g","depends_on_id":"bd-1m9","type":"blocks","created_at":"2026-01-27T22:11:59.454327871Z","created_by":"ubuntu"},{"issue_id":"bd-35g","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:09:36.530331471Z","created_by":"ubuntu"},{"issue_id":"bd-35g","depends_on_id":"bd-2iv","type":"blocks","created_at":"2026-01-27T22:11:56.645724337Z","created_by":"ubuntu"},{"issue_id":"bd-35g","depends_on_id":"bd-2mu","type":"blocks","created_at":"2026-01-27T22:11:54.177006201Z","created_by":"ubuntu"},{"issue_id":"bd-35g","depends_on_id":"bd-3l0","type":"blocks","created_at":"2026-01-27T22:11:51.610250289Z","created_by":"ubuntu"}]}
{"id":"bd-35rk","title":"demo_showcase features: HitGrid + mouse interactions (clickable UI + hover/pressed)","description":"# demo_showcase Features — HitGrid + Mouse Interactions (Clickable UI + Hover/Pressed)\n\n## Purpose\n\nA “turned up to 11” demo should be *clickable*. OpenTUI’s `HitGrid` is how we map mouse coordinates to UI actions.\n\nThis bead ensures mouse interaction feels real and demonstrates:\n\n- hit testing correctness\n- hit scissoring correctness (no clicks through clipped regions)\n- keyboard/mouse parity (same actions available)\n\n## Hit ID Scheme\n\nDefine a stable mapping from hit IDs → actions.\n\nExample approach (demo-only):\n\n- Reserve ID ranges by component:\n  - `1000-1999` chrome buttons\n  - `2000-2999` sidebar rows\n  - `3000-3999` editor area\n  - `4000-4999` preview toggles\n  - `5000-5999` log rows\n  - `9000+` overlay controls\n\nThe exact numbers aren’t important; stability and debuggability are.\n\n## Rendering Requirements\n\n- Every interactive element registers hit areas during render:\n  - `Renderer::register_hit_area(x, y, w, h, id)`\n- Use `Renderer::push_hit_scissor(rect)` around clipped lists so hit areas never extend beyond visible rows.\n\n## Interaction Requirements\n\n- Click to focus panels.\n- Click sidebar item to switch section.\n- Click log row to select.\n- Click overlay buttons (close/next/pause).\n\nOptional polish:\n\n- Hover styling (if mouse move events are available): subtly highlight hovered row.\n- Pressed styling: show a brief “pressed” state on click.\n\n## Acceptance Notes\n\n- No hit areas fire outside the visible scissor regions.\n- Mouse interactions work even when the UI is resizing.","acceptance_criteria":"Done when:\n- A stable hit-id scheme is defined (reserved ranges per component) and used consistently.\n- Click interactions work for: top bar buttons, sidebar rows, overlay controls, and selectable log rows.\n- Hit scissoring is correct: clipped regions cannot be clicked outside the visible area.\n- Visual feedback exists for hover (when available) and pressed states (on click).\n- Keyboard/mouse parity holds: every click action has an equivalent keyboard path.\n- When mouse is disabled (`--no-mouse` or equivalent gating), the UI remains fully operable via keyboard and does not show misleading click hints.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:27:55.640771011Z","created_by":"ubuntu","updated_at":"2026-01-27T23:16:36.041304145Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","features","input"],"dependencies":[{"issue_id":"bd-35rk","depends_on_id":"bd-1al","type":"blocks","created_at":"2026-01-27T22:32:27.303690270Z","created_by":"ubuntu"},{"issue_id":"bd-35rk","depends_on_id":"bd-1e4","type":"blocks","created_at":"2026-01-27T22:32:26.192658052Z","created_by":"ubuntu"},{"issue_id":"bd-35rk","depends_on_id":"bd-1fu","type":"blocks","created_at":"2026-01-27T22:32:26.754711998Z","created_by":"ubuntu"},{"issue_id":"bd-35rk","depends_on_id":"bd-1m9","type":"blocks","created_at":"2026-01-27T22:32:25.037470993Z","created_by":"ubuntu"},{"issue_id":"bd-35rk","depends_on_id":"bd-35g","type":"blocks","created_at":"2026-01-27T22:32:25.595167417Z","created_by":"ubuntu"},{"issue_id":"bd-35rk","depends_on_id":"bd-37p","type":"parent-child","created_at":"2026-01-27T22:27:55.656569873Z","created_by":"ubuntu"},{"issue_id":"bd-35rk","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:33:17.024063982Z","created_by":"ubuntu"}]}
{"id":"bd-37p","title":"[EPIC] demo_showcase: advanced features prove-out (graphemes, hitgrid, hyperlinks, pixels)","description":"# Epic: demo_showcase — Advanced Feature Prove‑Out\n\n## Purpose\n\nEnsure the demo app explicitly and recognizably exercises OpenTUI’s “wow” features:\n\n- Grapheme pool rendering (multi-codepoint emoji / ZWJ sequences)\n- Hyperlinks via OSC 8\n- Hit testing grid + mouse interactions\n- Pixel-level rendering primitives (supersampling / grayscale)\n- Scissor + opacity stacks in nested UI contexts\n\n## Key Principle\n\nThese features must not appear as isolated “hello world” snippets.\nThey should be integrated into believable UI behaviors (preview panels, clickable controls, tooltips, etc.).","acceptance_criteria":"Checklist:\n- [ ] Grapheme pool is exercised with a visible “this would break without pool” string\n- [ ] Hyperlink cells are rendered and clickable in supported terminals\n- [ ] Mouse click/scroll drives real navigation via `HitGrid`\n- [ ] PixelBuffer/GrayscaleBuffer output is integrated into the UI, not a separate screen\n- [ ] At least one overlay uses opacity stack + blending for a glass effect","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:04:34.519122126Z","created_by":"ubuntu","updated_at":"2026-01-27T22:04:44.123727790Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","epic","features"],"dependencies":[{"issue_id":"bd-37p","depends_on_id":"bd-1co","type":"parent-child","created_at":"2026-01-27T22:04:34.541866115Z","created_by":"ubuntu"}]}
{"id":"bd-383","title":"[EPIC] demo_showcase: tests, docs, and quality gates","description":"# Epic: demo_showcase — Tests, Docs, Quality Gates\n\n## Purpose\n\nA flagship demo that breaks silently is worse than no demo.\n\nThis epic ensures we have layered confidence:\n\n- fast compile coverage\n- deterministic headless runtime checks\n- snapshot regressions for UI/feature markers\n- optional true E2E PTY tests for ANSI/terminal behavior\n- scripts to run and collect artifacts\n- documentation so the demo is discoverable\n\n## Deliverables (This Epic Owns)\n\n### CI-Friendly\n\n- Compile coverage for the new binary target\n- Headless smoke mode + test that runs it\n- Snapshot regression suite (insta) based on headless JSON output\n- Tour determinism regression suite (headless tour + JSON)\n\n### Local / Developer Workflows\n\n- Optional PTY-based E2E tests (ignored by default) that assert on ANSI sequences\n- One-command scripts in `scripts/` to run checks and collect artifacts\n\n### Documentation\n\n- README: how to run, flags, tour mode, headless smoke\n- In-app help overlay is the primary keybind reference\n\n## Constraints\n\n- Tests must be deterministic and CI-friendly.\n- Avoid fragile “golden screenshot” tests that depend on terminal quirks.\n- When tests fail, logs must be actionable (include reproduction commands + stored artifacts).","acceptance_criteria":"Checklist:\n- [ ] `cargo test` includes a compile test for `demo_showcase`\n- [ ] Headless smoke tests validate core layout/render functions\n- [ ] README includes how to run the demo + what it proves\n- [ ] In-app help overlay documents keybinds and features\n- [ ] `cargo fmt --check` + `cargo clippy --all-targets -- -D warnings` stay clean","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:04:51.321133317Z","created_by":"ubuntu","updated_at":"2026-01-27T22:51:59.434073381Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","docs","epic","testing"],"dependencies":[{"issue_id":"bd-383","depends_on_id":"bd-1co","type":"parent-child","created_at":"2026-01-27T22:04:51.345376964Z","created_by":"ubuntu"}]}
{"id":"bd-3cj0","title":"demo_showcase scripts: e2e runner + artifact collection (one command)","description":"# demo_showcase Scripts — E2E Runner + Artifact Collection (One Command)\n\n## Purpose\n\nWe want a single, repeatable local workflow to validate the demo end-to-end and collect artifacts for debugging.\n\nThis bead adds one or more scripts in `scripts/` that:\n\n- run headless smoke + JSON dump\n- run snapshot tests (including degradation matrix)\n- optionally run ignored PTY tests\n- collect stdout/stderr and captured ANSI bytes into an artifacts directory\n\n## Proposed Script(s)\n\n### 1) scripts/demo_showcase_verify.sh\n\nA fast, CI-like validation pass:\n\n- cargo fmt --check\n- cargo clippy --all-targets -- -D warnings\n- cargo test\n\nThen (optional but useful for quick manual inspection):\n\n- cargo run --all-features --bin demo_showcase -- --headless-smoke --headless-dump-json --max-frames 10\n\n### 2) scripts/demo_showcase_e2e_pty.sh\n\nRuns ignored PTY tests locally with artifacts enabled:\n\n- HARNESS_ARTIFACTS=1 HARNESS_ARTIFACTS_DIR=target/test-artifacts \\\n    cargo test --test demo_showcase_pty_e2e -- --ignored --nocapture\n\n## Artifact Conventions\n\nReuse the existing harness conventions:\n\n- HARNESS_ARTIFACTS=1\n- HARNESS_ARTIFACTS_DIR=target/test-artifacts\n\nArtifacts should include:\n\n- headless JSON dumps\n- snapshot mismatch output (if any)\n- degradation matrix JSON snapshots (bd-2bnv)\n- PTY captured ANSI bytes (raw + escaped/hex) when PTY tests run\n\n## Acceptance Notes\n\n- Running the verify script gives a clear PASS/FAIL summary.\n- On failure, it prints reproduction commands and points to artifact paths.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:49:38.884053450Z","created_by":"ubuntu","updated_at":"2026-01-27T23:12:49.874628070Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","scripts","testing"],"dependencies":[{"issue_id":"bd-3cj0","depends_on_id":"bd-2649","type":"blocks","created_at":"2026-01-27T22:49:59.009326578Z","created_by":"ubuntu"},{"issue_id":"bd-3cj0","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-01-27T22:49:38.899710558Z","created_by":"ubuntu"},{"issue_id":"bd-3cj0","depends_on_id":"bd-61g0","type":"blocks","created_at":"2026-01-27T22:49:59.644070379Z","created_by":"ubuntu"}]}
{"id":"bd-3gb","title":"Fix integer overflow and unbounded paste buffer vulnerabilities","description":"Fixed three security/reliability issues found during code review: (1) Integer overflow in OptimizedBuffer::new() and resize() using saturating_mul, (2) Integer overflow in HitGrid::new() and resize() using saturating_mul, (3) Unbounded paste_buffer growth in InputParser limited to 10MB max","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-27T16:38:12.288682606Z","created_by":"ubuntu","updated_at":"2026-01-27T16:38:25.436300159Z","closed_at":"2026-01-27T16:38:25.436240579Z","close_reason":"Fixed in this session - used saturating_mul for integer overflow prevention and added 10MB limit on paste buffer","compaction_level":0,"original_size":0}
{"id":"bd-3ii","title":"demo_showcase runtime: layout helpers (Rect, splitting, clamping, compact mode)","description":"# demo_showcase Runtime — Layout Helpers\n\n## Purpose\n\nOpenTUI intentionally does not ship a layout system. The demo still needs *readable, reusable* layout helpers.\n\n## Minimal Layout Toolkit (Inside the Binary)\n\nDefine a tiny `Rect` and helpers:\n\n```rust\n#[derive(Clone, Copy)]\nstruct Rect { x: i32, y: i32, w: u32, h: u32 }\n\nimpl Rect {\n    fn inset(self, pad: u32) -> Rect { ... }\n    fn split_h(self, left_w: u32) -> (Rect, Rect) { ... }\n    fn split_v(self, top_h: u32) -> (Rect, Rect) { ... }\n    fn clamp_to(self, w: u32, h: u32) -> Rect { ... }\n}\n```\n\nAlso provide layout decisions:\n\n- sidebar width (min/max)\n- preview width\n- status bar height\n- top bar height\n\n## Compact Layout Mode\n\nWhen terminal is too small, we switch to a single-panel layout:\n\n- Show top bar + status bar\n- Main content = focused panel full-screen\n- Sidebar becomes an overlay or toggled view\n\nThis implements the resilience rules from `bd-1i7`.\n\n## Scissor Strategy\n\nFor each panel:\n\n- compute outer rect (border)\n- compute inner rect (content)\n- `buffer.push_scissor(inner_clip)`\n- draw content\n- `buffer.pop_scissor()`\n\n## Output\n\nA tiny, deterministic layout layer that keeps the demo’s code maintainable.","acceptance_criteria":"Checklist:\n- [ ] `Rect` + split/inset helpers exist (minimal but sufficient)\n- [ ] Panel rectangles are computed in one place per frame\n- [ ] Compact layout mode rules are implemented\n- [ ] Scissor usage is standardized per panel","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:10:00.689913873Z","created_by":"ubuntu","updated_at":"2026-01-27T22:12:06.640085119Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","runtime","ui"],"dependencies":[{"issue_id":"bd-3ii","depends_on_id":"bd-1i7","type":"blocks","created_at":"2026-01-27T22:12:06.640056476Z","created_by":"ubuntu"},{"issue_id":"bd-3ii","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:10:00.719418675Z","created_by":"ubuntu"},{"issue_id":"bd-3ii","depends_on_id":"bd-2mu","type":"blocks","created_at":"2026-01-27T22:12:01.973808970Z","created_by":"ubuntu"}]}
{"id":"bd-3iv","title":"Add token bounds validation in highlighted_buffer","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-27T16:54:14.063935824Z","created_by":"ubuntu","updated_at":"2026-01-27T17:00:06.166612370Z","closed_at":"2026-01-27T17:00:06.166550585Z","close_reason":"done","compaction_level":0,"original_size":0}
{"id":"bd-3l0","title":"demo_showcase spec: keybindings + interaction model (keyboard/mouse/focus)","description":"# demo_showcase Spec — Keybindings + Interaction Model\n\n## Philosophy\n\n- **Discoverable**: status bar + help overlay always tell you what to do.\n- **Low cognitive load**: a small set of global chords; panel-local keys only when focused.\n- **Mouse is first-class**: click to focus; scroll to scroll; clickable buttons prove HitGrid.\n\n## Global Keybindings (Always Active)\n\n- `Ctrl+Q` — Quit\n- `F1` — Help overlay (toggle)\n- `Ctrl+P` — Command palette (toggle)\n- `Ctrl+T` — Tour mode (toggle / start from step 1)\n- `Ctrl+D` — Toggle OpenTUI debug overlay (fps/cells/memory)\n- `Tab` / `Shift+Tab` — Cycle focused panel\n- `Ctrl+R` — Force full redraw (`renderer.invalidate()`)\n\n## Panel Focus Model\n\nThere is always exactly one **focused panel**:\n\n- Focus is drawn (border highlight + subtle glow)\n- Keyboard events route primarily to the focused panel\n- Mouse click inside a panel sets focus\n\nPanels:\n- Sidebar\n- Editor\n- Preview\n- Logs\n\n## Mouse Interaction Model (Must Exercise HitGrid)\n\n- Click on sidebar items selects section\n- Click on top bar “buttons” toggles overlays (Help / Palette / Tour)\n- Scroll wheel over sidebar/logs scrolls that panel\n- Click on hyperlink-like rows shows visual pressed feedback (even though link open is handled by terminal)\n\nImplementation hint: register hit areas for:\n\n- Each sidebar row\n- Each top-bar button\n- Selected preview “tabs”\n\n## Input Events to Explicitly Surface\n\nThe app should *visibly react* to:\n\n- Focus gained/lost events:\n  - When focus lost: pause animations, show “PAUSED (focus lost)” badge\n  - When focus gained: resume\n- Bracketed paste:\n  - Paste into editor inserts text and shows toast “Pasted N chars”\n- Resize:\n  - Layout recompute + toast “Resized to WxH”\n\n## Editor Keybindings (When Editor Focused)\n\nKeep it close to existing `examples/editor.rs`:\n\n- Arrow keys: move cursor\n- `Ctrl+Left/Right`: word navigation\n- `Home/End`: line start/end\n- `PageUp/PageDown`: scroll\n- `Ctrl+Z` / `Ctrl+Y`: undo/redo\n- `Ctrl+W`: cycle wrap mode (None → Word → Char)\n- `Ctrl+L`: toggle line numbers\n\n## Overlay Keybindings\n\n- Help overlay:\n  - `Esc` / `F1` to close\n- Command palette:\n  - `Esc` close\n  - `Enter` activate selected action\n  - Up/Down navigate list\n- Tour:\n  - `Enter` / `Space` next step\n  - `Backspace` previous step\n  - `Esc` exit tour","acceptance_criteria":"Checklist:\n- [ ] Global keybindings defined and minimal\n- [ ] Focus model defined and consistent\n- [ ] Mouse behaviors defined (click, scroll, hit testing targets)\n- [ ] Focus gained/lost behavior defined (pause/resume)\n- [ ] Bracketed paste behavior defined (insert + toast)\n- [ ] Editor keys defined (undo/redo, wrap, line numbers, navigation)\n- [ ] Overlay keys defined (help/palette/tour)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:05:42.145358418Z","created_by":"ubuntu","updated_at":"2026-01-27T22:07:55.959006498Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","design","input"],"dependencies":[{"issue_id":"bd-3l0","depends_on_id":"bd-2jc","type":"parent-child","created_at":"2026-01-27T22:05:42.168791836Z","created_by":"ubuntu"},{"issue_id":"bd-3l0","depends_on_id":"bd-2mu","type":"blocks","created_at":"2026-01-27T22:07:55.958980961Z","created_by":"ubuntu"}]}
{"id":"bd-3o0","title":"demo_showcase runtime: tour mode driver (script executor + deterministic timing)","description":"# demo_showcase Runtime — Tour Mode Driver (Script Executor + Deterministic Timing)\n\n## Purpose\n\nTour mode is how we get:\n\n- unattended demos (screen recordings)\n- deterministic behavior for tests/smoke runs\n- a guided narrative that proves features in a clear order\n\nThis bead implements the runtime that executes the tour script defined in `bd-1gy`.\n\n## Behaviors\n\n- CLI flag --tour starts tour immediately.\n- Tour runs a fixed sequence of steps:\n  - changes focus/panels\n  - triggers overlays (command palette/help)\n  - scrolls lists/logs\n  - types/pastes into editor\n  - triggers preview animations / errors / recovery\n\nDeterminism:\n\n- no randomness\n- timing driven by a monotonic clock + fixed durations\n- any synthetic inputs are generated by the tour driver\n\nAutomatic termination (for recordings/E2E):\n\n- If `--exit-after-tour` is enabled (see `bd-3vjm` / `bd-2iv`), the app should exit 0 when the final tour step completes.\n- `--max-frames` acts as a hard safety bound; it should never be required for a normal tour, but it prevents hangs.\n\n## Interactive + Headless\n\nThe tour driver must work in BOTH:\n\n- interactive mode (real renderer)\n- headless mode (for CI regression tests)\n\nHeadless mode should be able to execute the tour and emit JSON markers that tests can snapshot (see `bd-bqd1`).\n\n## Implementation Approach\n\n- Introduce a TourRunner in the demo binary:\n  - state: TourState { step_idx, step_started_at, paused, ... }\n  - fn tick(now, app, out_actions)\n\n- The tour runner should not directly draw; it only manipulates app state and injects actions.\n\n- When the tour wants to show something, it should set a TourHighlight { rect, message } that the tour overlay bead renders.\n\n## Acceptance Notes\n\n- cargo run --bin demo_showcase -- --tour produces a stable “demo story” without user input.\n- Tour can be paused/resumed and cleanly exited.\n- Tour never leaves the app in a broken focus/input state when it ends.\n- With `--exit-after-tour`, the process terminates cleanly at completion.","acceptance_criteria":"Done when:\n- `cargo run --bin demo_showcase -- --tour` produces a complete, deterministic feature walkthrough without user input.\n- Tour driving works in both interactive mode and headless mode (headless emits stable tour step markers in JSON).\n- Tour controls work: next/prev, pause/resume, and exit without leaving focus/input in a broken state.\n- With `--exit-after-tour`, the process exits 0 when the final step completes and the terminal is restored cleanly.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:25:18.030533207Z","created_by":"ubuntu","updated_at":"2026-01-27T23:16:55.587961203Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","runtime"],"dependencies":[{"issue_id":"bd-3o0","depends_on_id":"bd-1gy","type":"blocks","created_at":"2026-01-27T22:32:16.254927712Z","created_by":"ubuntu"},{"issue_id":"bd-3o0","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:25:18.042919278Z","created_by":"ubuntu"},{"issue_id":"bd-3o0","depends_on_id":"bd-2iv","type":"blocks","created_at":"2026-01-27T22:32:16.993258401Z","created_by":"ubuntu"},{"issue_id":"bd-3o0","depends_on_id":"bd-2t3","type":"blocks","created_at":"2026-01-27T22:32:18.262929423Z","created_by":"ubuntu"},{"issue_id":"bd-3o0","depends_on_id":"bd-35g","type":"blocks","created_at":"2026-01-27T22:32:17.664069555Z","created_by":"ubuntu"}]}
{"id":"bd-3oqa","title":"demo_showcase runtime: event/log routing (emit_event + set_log_callback -> logs panel)","description":"# demo_showcase Runtime — Event/Log Routing (emit_event + set_log_callback → Logs Panel)\n\n## Purpose\n\nOpenTUI includes an event/log callback system (`src/event.rs`). The demo should use it so we:\n\n- prove the module works\n- get a realistic logs stream without sprinkling UI code with ad-hoc logging\n\n## What To Implement\n\n- At demo startup:\n  - call `set_event_callback` and `set_log_callback`\n  - route events/logs into the demo’s internal `LogModel` (ring buffer)\n\n- Provide a small helper API in demo-only code:\n  - `fn log_info(msg)` / `fn log_warn(msg)` / `fn log_error(msg)`\n  - optionally `emit_event(\"action\", json)` for structured actions\n\n## Concurrency Notes\n\nCallbacks are `Send + Sync` and stored behind a `Mutex`. Keep callbacks fast:\n\n- push into a lock-free-ish queue (or just a bounded `VecDeque` behind a `Mutex` owned by the app)\n- avoid allocating large strings in hot paths\n\n## Acceptance Notes\n\n- Core app actions (palette commands, tour steps, resize, focus changes) generate log entries.\n- Logs panel reflects these entries without frame hitching.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:26:21.888226798Z","created_by":"ubuntu","updated_at":"2026-01-27T22:32:15.671632007Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","runtime"],"dependencies":[{"issue_id":"bd-3oqa","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:26:21.908976801Z","created_by":"ubuntu"},{"issue_id":"bd-3oqa","depends_on_id":"bd-2c6","type":"blocks","created_at":"2026-01-27T22:32:15.671602532Z","created_by":"ubuntu"},{"issue_id":"bd-3oqa","depends_on_id":"bd-hc0","type":"blocks","created_at":"2026-01-27T22:32:15.124481842Z","created_by":"ubuntu"}]}
{"id":"bd-3ot0","title":"demo_showcase runtime: optional ThreadedRenderer backend (--threaded)","description":"# demo_showcase Runtime — Optional ThreadedRenderer Backend (`--threaded`)\n\n## Purpose\n\nOpenTUI has a `ThreadedRenderer` that moves terminal I/O off the main thread. The flagship demo should be able to showcase this as an optional mode.\n\nThis is not required for the first “works and looks amazing” milestone, but it’s an impressive proof point for real applications.\n\n## Behavior\n\n- CLI flag: `--threaded`\n- When enabled, the demo uses `opentui::renderer::ThreadedRenderer` instead of `Renderer`.\n- The UI + state machine should behave the same.\n\n## Design Constraint\n\n`Renderer` and `ThreadedRenderer` have different ownership models (threaded moves buffers/pools through channels). To avoid duplicating the whole app:\n\n- Introduce a small demo-only backend wrapper:\n  - `enum Backend { Direct(Renderer), Threaded(ThreadedRenderer) }`\n  - helper methods: `buffer()`, `present()`, `resize()`, `set_title()`, `set_cursor()`\n\n## GraphemePool Note (Important)\n\nIf tour/unicode panels use grapheme pool content, ensure that the threaded path does not leak grapheme refs:\n\n- Avoid using `ThreadedRenderer::clear()` if it doesn’t clear with pool.\n- Prefer explicit `buffer().clear_with_pool(grapheme_pool(), bg)` / `resize_with_pool` patterns.\n- If the library needs a small fix (pool-aware clear/resize convenience), file a follow-up bead or patch the library directly.\n\n## Acceptance Notes\n\n- `cargo run --bin demo_showcase -- --threaded` works and exits cleanly.\n- Rendering remains smooth and input remains responsive.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-27T22:26:45.107585716Z","created_by":"ubuntu","updated_at":"2026-01-27T22:32:19.962836338Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","features","runtime"],"dependencies":[{"issue_id":"bd-3ot0","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:26:45.142106801Z","created_by":"ubuntu"},{"issue_id":"bd-3ot0","depends_on_id":"bd-2iv","type":"blocks","created_at":"2026-01-27T22:32:18.844522494Z","created_by":"ubuntu"},{"issue_id":"bd-3ot0","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:32:19.962802535Z","created_by":"ubuntu"},{"issue_id":"bd-3ot0","depends_on_id":"bd-z1b","type":"blocks","created_at":"2026-01-27T22:32:19.396568255Z","created_by":"ubuntu"}]}
{"id":"bd-3pe","title":"demo_showcase UI: help overlay (F1) + feature legend","description":"# demo_showcase UI — Help Overlay (F1) + Feature Legend\n\n## Purpose\n\nThe help overlay makes the demo self-contained and also proves multiple library features:\n\n- overlay rendering + opacity stack (glass modal)\n- scissor clipping (scrollable help content)\n- hyperlink rendering via OSC 8 (LinkPool)\n\nIt also prevents the “what do I press?” problem for first-time viewers.\n\n## Content Requirements\n\n### Keybinds\n\nInclude (at minimum):\n\n- `Ctrl+Q` quit\n- `Tab` / `Shift+Tab` focus next/prev panel\n- `Ctrl+P` command palette\n- `F1` help\n- `Ctrl+T` tour start/stop\n- editor keys (arrows, word movement, wrap toggle, undo/redo)\n- log/preview navigation keys\n\n### Mouse\n\n- click to focus panels\n- click to activate buttons\n- scroll to scroll lists/logs\n\n### Feature Legend\n\nMake it explicit where each OpenTUI feature is visible in the app:\n\n- RGBA alpha blending (preview overlays / glass modals)\n- scissor stack (sidebar/log scroll clipping)\n- opacity stack (overlays + tinted UI sections)\n- grapheme pool (unicode panel)\n- OSC 8 links (logs + help)\n- hitgrid (clickable UI)\n- pixel buffers (preview panel)\n- diff rendering + sync output (perf/inspector + smoothness)\n\n### Clickable Links\n\nInclude a small “Docs / Links” section with OSC 8 hyperlinks:\n\n- repo URL\n- unicode width reference\n\nThe links must be allocated through `renderer.link_pool()` and applied via `Style::with_link`.\n\n## Rendering Notes\n\n- Help content should be scrollable when terminal is small.\n- Use clear typography hierarchy: title, section headers, monospace keycaps.\n- Use hit areas for the “Close” button and for any tab-like subviews.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:24:04.642163943Z","created_by":"ubuntu","updated_at":"2026-01-27T22:32:05.666034752Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","docs","ui"],"dependencies":[{"issue_id":"bd-3pe","depends_on_id":"bd-1al","type":"blocks","created_at":"2026-01-27T22:32:04.565909821Z","created_by":"ubuntu"},{"issue_id":"bd-3pe","depends_on_id":"bd-1ei","type":"blocks","created_at":"2026-01-27T22:32:05.666002312Z","created_by":"ubuntu"},{"issue_id":"bd-3pe","depends_on_id":"bd-3l0","type":"blocks","created_at":"2026-01-27T22:32:05.092958035Z","created_by":"ubuntu"},{"issue_id":"bd-3pe","depends_on_id":"bd-c75","type":"parent-child","created_at":"2026-01-27T22:24:04.656207314Z","created_by":"ubuntu"}]}
{"id":"bd-3vjm","title":"demo_showcase runtime: deterministic termination controls (--max-frames / --exit-after-tour)","description":"# demo_showcase Runtime — Deterministic Termination Controls\n\n## Purpose\n\nWe need deterministic ways to stop the app without human input so we can:\n\n- run real PTY-based E2E tests without brittle \"send keys\" logic\n- record unattended videos reliably (tour ends -> app exits)\n- keep runs bounded for CI and debugging\n\n## Required Controls\n\n### 1) `--max-frames <N>` (Hard Frame Budget)\n\n- After the demo has **presented N frames**, exit 0.\n- Count frames consistently across modes (interactive + headless).\n- Print a stable summary line on exit (useful for tests/logs), e.g.:\n  - `EXIT_OK reason=max_frames frames=<N> last_dirty_cells=<K>`\n\n### 2) `--exit-after-tour` (Tour Completion Exit)\n\n- When tour mode reaches the last step and completes it, exit 0 automatically.\n- The exit should be clean:\n  - restore cursor\n  - leave alt screen (if used)\n  - disable mouse (if enabled)\n- Tour should still be escapable with user input; this flag only adds an automatic exit at completion.\n\n## Integration Notes\n\n- Flag parsing belongs in `bd-2iv`, but the **run-loop semantics** and **tour end handling** live here.\n- Headless mode (`bd-2el`) should also honor these controls so tests can bound runtime.\n\n## Why This Matters\n\nWithout deterministic termination, we end up with flaky tests and awkward demo workflows.\nThese controls make the demo feel \"professional\" to develop and validate.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T23:10:07.678047128Z","created_by":"ubuntu","updated_at":"2026-01-27T23:10:07.723962692Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","runtime","testing"],"dependencies":[{"issue_id":"bd-3vjm","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T23:10:07.707235213Z","created_by":"ubuntu"},{"issue_id":"bd-3vjm","depends_on_id":"bd-2iv","type":"blocks","created_at":"2026-01-27T23:10:07.718517533Z","created_by":"ubuntu"},{"issue_id":"bd-3vjm","depends_on_id":"bd-3o0","type":"blocks","created_at":"2026-01-27T23:10:07.723946582Z","created_by":"ubuntu"},{"issue_id":"bd-3vjm","depends_on_id":"bd-z1b","type":"blocks","created_at":"2026-01-27T23:10:07.712843797Z","created_by":"ubuntu"}]}
{"id":"bd-61g0","title":"demo_showcase e2e: PTY harness + ANSI capture (real terminal sequences, ignored by default)","description":"# demo_showcase E2E — PTY Harness + ANSI Capture (Ignored by Default)\n\n## Purpose\n\nHeadless tests prove the render pipeline is correct, but they cannot prove real terminal I/O behavior.\n\nThis bead adds true end-to-end tests by running the demo under a pseudo-terminal (PTY), capturing ANSI output bytes, and asserting on key invariants:\n\n- alternate screen entry/exit\n- cursor hide/show\n- mouse enable sequences (if enabled)\n- synchronized output enable (if supported)\n- OSC 8 hyperlink sequences appear (and do NOT appear when disabled)\n\n## Approach (Unix)\n\n- Use libc openpty / fork+exec (or an equivalent minimal PTY approach) to spawn:\n  - cargo run --all-features --bin demo_showcase -- --tour --exit-after-tour --max-frames 600 --fps 30\n\nWhy both exit controls?\n\n- `--exit-after-tour` is the intended deterministic terminator.\n- `--max-frames` is a hard safety bound so the PTY test cannot hang if tour logic regresses.\n\n- Capture stdout from the PTY master.\n\n## Assertions\n\nAssert the output stream contains, in some order:\n\n- enter alt screen (CSI ? 1049 h) when alt screen enabled\n- leave alt screen (CSI ? 1049 l) on exit\n- hide cursor (CSI ? 25 l) and show cursor (CSI ? 25 h)\n- mouse enable sequences (1000/1002/1006) when mouse enabled\n- synchronized output enable (CSI ? 2026 h) when supported/enabled\n\nHyperlink coverage:\n\n- run one case with default settings and assert at least one OSC 8 sequence appears (ESC ] 8 ; ; ...)\n- run one case with `--cap-preset no_hyperlinks` (or equivalent disable) and assert OSC 8 sequences are absent\n\nOptional (high-value): threaded mode parity\n\n- run a second spawn with `--threaded` and assert the same terminal lifecycle sequences appear\n\nAlso assert:\n\n- demo exits 0 within a timeout\n- output is non-trivial (bytes > some threshold)\n\n## Logging / Artifacts\n\n- Use the structured logger utilities in `tests/common/harness.rs` to:\n  - log key milestones (spawned, bytes captured, exit status)\n  - write captured ANSI bytes to artifacts (both raw + hex/escaped view)\n\nControlled via HARNESS_ARTIFACTS=1.\n\n## Test Placement\n\n- Mark PTY tests as #[ignore] by default to avoid CI flakiness.\n- Provide a script (separate bead) to run them locally and collect artifacts.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:49:04.613268330Z","created_by":"ubuntu","updated_at":"2026-01-27T23:12:33.389722159Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","e2e","testing"],"dependencies":[{"issue_id":"bd-61g0","depends_on_id":"bd-2iv","type":"blocks","created_at":"2026-01-27T22:49:27.862668126Z","created_by":"ubuntu"},{"issue_id":"bd-61g0","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-01-27T22:49:04.631306455Z","created_by":"ubuntu"},{"issue_id":"bd-61g0","depends_on_id":"bd-3o0","type":"blocks","created_at":"2026-01-27T22:49:28.902157577Z","created_by":"ubuntu"},{"issue_id":"bd-61g0","depends_on_id":"bd-3vjm","type":"blocks","created_at":"2026-01-27T23:12:19.691230196Z","created_by":"ubuntu"},{"issue_id":"bd-61g0","depends_on_id":"bd-z1b","type":"blocks","created_at":"2026-01-27T22:49:26.694765952Z","created_by":"ubuntu"}]}
{"id":"bd-8yf","title":"Optimize BufferDiff::compute() with pre-allocated Vec","description":"BufferDiff::compute() creates Vec::new() for changed_cells. Could pre-allocate with estimated capacity based on typical change rate, or use a reusable scratch buffer.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-21T16:54:52.939084594Z","created_by":"ubuntu","updated_at":"2026-01-21T17:16:53.872340399Z","closed_at":"2026-01-21T17:16:53.871467724Z","close_reason":"Pre-allocated changed_cells Vec based on total size heuristic; cargo check/clippy/fmt clean","compaction_level":0,"original_size":0}
{"id":"bd-bb2","title":"Fix clippy pedantic lints in tests and source files","description":"68 clippy errors found. Mostly similar_names, many_single_char_names, uninlined_format_args, missing_const_for_fn, semicolon_if_nothing_returned, format_collect lints.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-21T08:09:28.502462752Z","created_by":"ubuntu","updated_at":"2026-01-21T10:06:34.124269151Z","closed_at":"2026-01-21T10:06:34.123780311Z","close_reason":"Clippy/Check/Fmt clean; no warnings with cargo clippy --all-targets -- -D warnings","compaction_level":0,"original_size":0}
{"id":"bd-bqd1","title":"demo_showcase tests: tour determinism regression (scripted steps -> stable output)","description":"# demo_showcase Tests — Tour Determinism Regression (Scripted Steps → Stable Output)\n\n## Purpose\n\nTour mode is a flagship feature and also our best deterministic “integration test” for:\n\n- input routing\n- overlays\n- panel switching\n- pixel/alpha/unicode/link features\n\nThis bead adds regression tests that ensure the tour produces stable, deterministic outputs.\n\n## Strategy\n\nRun the demo in headless mode and execute the tour script (no real TTY).\n\nRecommended CLI shape (keep it strict):\n\n- --headless-smoke --tour --headless-dump-json\n\nOptional safety bound (should not be needed if tour completes, but prevents hangs):\n\n- --max-frames <N>\n\nThe JSON output must include:\n\n- step index + step title\n- per-frame (or per-step) dirty cell counts\n- sentinel markers proving that step’s feature is active\n\n## What To Assert\n\nFor each tour step (from `bd-1gy`):\n\n- the expected step title appears in the JSON\n- the expected feature markers are present, e.g.:\n  - palette open marker on the command palette step\n  - unicode strings (ZWJ emoji) on the grapheme pool step\n  - at least one OSC8 link marker on the hyperlinks step\n  - pixel preview active marker on the pixel step\n\nAdditionally:\n\n- tour output is deterministic across runs (snapshot the JSON via insta or compare stable hashes)\n- tour terminates cleanly (headless tour run exits 0)\n\n## Logging\n\n- Print a clear reproduction command on failure.\n- Store JSON and logs as artifacts when HARNESS_ARTIFACTS=1.\n\n## Acceptance Notes\n\n- A CI test fails loudly if tour output changes unexpectedly.\n- The logged diff is sufficient to diagnose what changed.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:48:31.832960799Z","created_by":"ubuntu","updated_at":"2026-01-27T23:14:28.496790059Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","testing","tour"],"dependencies":[{"issue_id":"bd-bqd1","depends_on_id":"bd-2el","type":"blocks","created_at":"2026-01-27T22:48:53.529196779Z","created_by":"ubuntu"},{"issue_id":"bd-bqd1","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-01-27T22:48:31.852222684Z","created_by":"ubuntu"},{"issue_id":"bd-bqd1","depends_on_id":"bd-3o0","type":"blocks","created_at":"2026-01-27T22:48:52.933298797Z","created_by":"ubuntu"}]}
{"id":"bd-c75","title":"[EPIC] demo_showcase: UI layout + components (dashboard/editor/preview/logs)","description":"# Epic: demo_showcase — UI Layout + Components\n\n## Purpose\n\nBuild the actual “app” the user sees.\n\nThe demo should present a believable multi-panel workflow:\n\n- Top bar (branding, time, mode, quick actions)\n- Sidebar navigation (projects / sections)\n- Main editor panel (real editing + highlighting)\n- Preview panel (pixel/graphics + charts)\n- Logs/notifications panel (events + hyperlinks)\n- Command palette overlay + help overlay\n\nAll of these must strongly exercise OpenTUI primitives: scissor, opacity, blending, styled text, pooling.","acceptance_criteria":"Checklist:\n- [ ] Layout feels like a real modern TUI app\n- [ ] Every panel is clipped correctly (scissor)\n- [ ] Overlays feel “glassy” (opacity + blending)\n- [ ] Editor is fully interactive and highlighted\n- [ ] Preview panel demonstrates pixel rendering and compositing\n- [ ] Logs panel demonstrates hyperlinks and event visualization","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:04:17.719974057Z","created_by":"ubuntu","updated_at":"2026-01-27T22:04:26.625591657Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","epic","ui"],"dependencies":[{"issue_id":"bd-c75","depends_on_id":"bd-1co","type":"parent-child","created_at":"2026-01-27T22:04:17.742038951Z","created_by":"ubuntu"}]}
{"id":"bd-gtp","title":"Add Line Duplication and Movement Methods","description":"## Overview\nAdd line duplication and movement methods to EditBuffer.\n\n## Already Implemented (NO WORK NEEDED)\nThe following methods already exist in `src/text/edit.rs`:\n- `delete_line()` at line 381 ✓\n- `goto_line()` at line 292 ✓\n\n## Scope (Methods to Add)\n```rust\nimpl EditBuffer {\n    /// Duplicate the current line (insert copy below).\n    pub fn duplicate_line(&mut self) {\n        let row = self.cursor.row;\n        if let Some(line) = self.buffer.rope().line(row) {\n            let line_text = line.to_string();\n            let line_end = self.buffer.rope().line_to_char(row) + line.len_chars();\n            \n            // Insert newline + line content after current line\n            let insert_pos = if line_text.ends_with('\\n') {\n                line_end\n            } else {\n                // At last line without trailing newline\n                line_end\n            };\n            \n            self.begin_edit_group();\n            if !line_text.ends_with('\\n') {\n                self.insert_at(insert_pos, \"\\n\");\n            }\n            self.insert_at(insert_pos + if line_text.ends_with('\\n') { 0 } else { 1 }, &line_text);\n            self.end_edit_group();\n        }\n    }\n\n    /// Move current line up (swap with line above).\n    pub fn move_line_up(&mut self) {\n        if self.cursor.row == 0 {\n            return; // Can't move first line up\n        }\n        \n        let current_row = self.cursor.row;\n        let prev_row = current_row - 1;\n        \n        self.begin_edit_group();\n        // Get both lines\n        let current_line = self.buffer.rope().line(current_row).map(|l| l.to_string());\n        let prev_line = self.buffer.rope().line(prev_row).map(|l| l.to_string());\n        \n        if let (Some(curr), Some(prev)) = (current_line, prev_line) {\n            // Delete both lines and reinsert in swapped order\n            let start = self.buffer.rope().line_to_char(prev_row);\n            let end = self.buffer.rope().line_to_char(current_row) + \n                self.buffer.rope().line(current_row).map(|l| l.len_chars()).unwrap_or(0);\n            \n            self.delete_range_offsets(start, end);\n            self.insert_at(start, &format!(\"{}{}\", curr, prev));\n            \n            // Move cursor to new position (one line up)\n            self.goto_line(prev_row);\n        }\n        self.end_edit_group();\n    }\n\n    /// Move current line down (swap with line below).\n    pub fn move_line_down(&mut self) {\n        let current_row = self.cursor.row;\n        let next_row = current_row + 1;\n        \n        if next_row >= self.buffer.len_lines() {\n            return; // Can't move last line down\n        }\n        \n        self.begin_edit_group();\n        // Similar to move_line_up but swap in opposite direction\n        let current_line = self.buffer.rope().line(current_row).map(|l| l.to_string());\n        let next_line = self.buffer.rope().line(next_row).map(|l| l.to_string());\n        \n        if let (Some(curr), Some(next)) = (current_line, next_line) {\n            let start = self.buffer.rope().line_to_char(current_row);\n            let end = self.buffer.rope().line_to_char(next_row) + \n                self.buffer.rope().line(next_row).map(|l| l.len_chars()).unwrap_or(0);\n            \n            self.delete_range_offsets(start, end);\n            self.insert_at(start, &format!(\"{}{}\", next, curr));\n            \n            // Move cursor to new position (one line down)\n            self.goto_line(next_row);\n        }\n        self.end_edit_group();\n    }\n}\n```\n\n## Files to Modify\n- src/text/edit.rs - Add the 3 new methods\n\n## Testing Requirements\n\n### Unit Tests (add to existing tests in src/text/edit.rs)\n```rust\n#[test]\nfn test_duplicate_line() {\n    let mut buffer = EditBuffer::with_text(\"line 1\\nline 2\\nline 3\");\n    buffer.goto_line(1);  // Move to \"line 2\"\n    \n    eprintln!(\"[TEST] Initial text:\\n{}\", buffer.text());\n    eprintln!(\"[TEST] Cursor on line {}\", buffer.cursor().row);\n    \n    buffer.duplicate_line();\n    \n    eprintln!(\"[TEST] After duplicate_line:\\n{}\", buffer.text());\n    \n    assert_eq!(buffer.len_lines(), 4, \"Should have 4 lines now\");\n    \n    let lines: Vec<&str> = buffer.text().lines().collect();\n    eprintln!(\"[TEST] Lines: {:?}\", lines);\n    \n    assert_eq!(lines[1], \"line 2\");\n    assert_eq!(lines[2], \"line 2\", \"Duplicated line should match\");\n    \n    // Test undo\n    buffer.undo();\n    assert_eq!(buffer.len_lines(), 3);\n    eprintln!(\"[TEST] After undo: {} lines\", buffer.len_lines());\n    \n    eprintln!(\"[TEST] PASS: duplicate_line works with undo\");\n}\n\n#[test]\nfn test_duplicate_last_line_no_newline() {\n    let mut buffer = EditBuffer::with_text(\"line 1\\nline 2\");  // No trailing newline\n    buffer.goto_line(1);  // Last line\n    \n    eprintln!(\"[TEST] Text (no trailing newline): {:?}\", buffer.text());\n    \n    buffer.duplicate_line();\n    \n    eprintln!(\"[TEST] After duplicate: {:?}\", buffer.text());\n    \n    assert_eq!(buffer.len_lines(), 3);\n    let lines: Vec<&str> = buffer.text().lines().collect();\n    assert_eq!(lines[1], \"line 2\");\n    assert_eq!(lines[2], \"line 2\");\n    \n    eprintln!(\"[TEST] PASS: duplicate_line handles last line without newline\");\n}\n\n#[test]\nfn test_move_line_up() {\n    let mut buffer = EditBuffer::with_text(\"line 1\\nline 2\\nline 3\");\n    buffer.goto_line(1);  // \"line 2\"\n    \n    eprintln!(\"[TEST] Initial text:\\n{}\", buffer.text());\n    eprintln!(\"[TEST] Moving line 2 up\");\n    \n    buffer.move_line_up();\n    \n    eprintln!(\"[TEST] After move_line_up:\\n{}\", buffer.text());\n    eprintln!(\"[TEST] Cursor now on line {}\", buffer.cursor().row);\n    \n    let lines: Vec<&str> = buffer.text().lines().collect();\n    assert_eq!(lines[0], \"line 2\", \"Line 2 should be first now\");\n    assert_eq!(lines[1], \"line 1\", \"Line 1 should be second now\");\n    assert_eq!(buffer.cursor().row, 0, \"Cursor should follow line up\");\n    \n    // Test undo\n    buffer.undo();\n    let lines: Vec<&str> = buffer.text().lines().collect();\n    assert_eq!(lines[0], \"line 1\");\n    eprintln!(\"[TEST] After undo: first line is {:?}\", lines[0]);\n    \n    eprintln!(\"[TEST] PASS: move_line_up works with undo\");\n}\n\n#[test]\nfn test_move_line_down() {\n    let mut buffer = EditBuffer::with_text(\"line 1\\nline 2\\nline 3\");\n    buffer.goto_line(1);  // \"line 2\"\n    \n    eprintln!(\"[TEST] Initial text:\\n{}\", buffer.text());\n    eprintln!(\"[TEST] Moving line 2 down\");\n    \n    buffer.move_line_down();\n    \n    eprintln!(\"[TEST] After move_line_down:\\n{}\", buffer.text());\n    \n    let lines: Vec<&str> = buffer.text().lines().collect();\n    assert_eq!(lines[1], \"line 3\", \"Line 3 should be second now\");\n    assert_eq!(lines[2], \"line 2\", \"Line 2 should be third now\");\n    assert_eq!(buffer.cursor().row, 2, \"Cursor should follow line down\");\n    \n    eprintln!(\"[TEST] PASS: move_line_down works\");\n}\n\n#[test]\nfn test_move_line_at_boundaries() {\n    let mut buffer = EditBuffer::with_text(\"first\\nmiddle\\nlast\");\n    \n    // Move first line up - should be no-op\n    buffer.goto_line(0);\n    buffer.move_line_up();\n    let lines: Vec<&str> = buffer.text().lines().collect();\n    assert_eq!(lines[0], \"first\", \"First line can't move up\");\n    eprintln!(\"[TEST] move_line_up on first line is no-op\");\n    \n    // Move last line down - should be no-op\n    buffer.goto_line(2);\n    buffer.move_line_down();\n    let lines: Vec<&str> = buffer.text().lines().collect();\n    assert_eq!(lines[2], \"last\", \"Last line can't move down\");\n    eprintln!(\"[TEST] move_line_down on last line is no-op\");\n    \n    eprintln!(\"[TEST] PASS: Line move operations handle boundaries\");\n}\n\n#[test]\nfn test_line_operations_preserve_cursor_column() {\n    let mut buffer = EditBuffer::with_text(\"short\\nthis is a longer line\\nend\");\n    buffer.goto_line(1);\n    buffer.move_to(1, 10);  // Middle of \"longer line\"\n    \n    eprintln!(\"[TEST] Cursor at row={} col={}\", buffer.cursor().row, buffer.cursor().col);\n    \n    buffer.duplicate_line();\n    \n    // Cursor should stay on original line\n    eprintln!(\"[TEST] After duplicate: row={} col={}\", buffer.cursor().row, buffer.cursor().col);\n    \n    eprintln!(\"[TEST] PASS: Line operations preserve cursor column\");\n}\n```\n\n## Acceptance Criteria\n- [ ] `duplicate_line()` inserts copy of current line below\n- [ ] `duplicate_line()` handles last line without trailing newline\n- [ ] `move_line_up()` swaps current line with line above\n- [ ] `move_line_down()` swaps current line with line below\n- [ ] Move operations are no-ops at buffer boundaries\n- [ ] Cursor follows the moved/duplicated line\n- [ ] All operations integrate with undo/redo\n- [ ] All 6 new unit tests pass with detailed logging\n- [ ] Existing EditBuffer tests still pass (no regression)","acceptance_criteria":"- [ ] delete_line removes line and newline\n- [ ] goto_line moves cursor correctly\n- [ ] goto_line clamps to valid range\n- [ ] Line operations integrate with undo\n- [ ] All 8+ unit tests pass\n\n---","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:08:22.545647283Z","closed_at":"2026-01-19T22:08:22.545599323Z","close_reason":"Implemented duplicate_line(), move_line_up(), move_line_down() with comprehensive tests. All tests pass.","compaction_level":0,"original_size":0}
{"id":"bd-hc0","title":"demo_showcase runtime: content + initial state wiring (editor/logs/metrics/nav)","description":"# demo_showcase Runtime — Content + Initial State Wiring (Editor / Logs / Metrics / Nav)\n\n## Purpose\n\nThe demo should boot into a believable “project workspace” with rich content immediately visible.\n\nThis bead wires the content pack spec (`bd-1ei`) into real runtime state:\n\n- initial editor buffers\n- initial sidebar navigation structure\n- initial logs stream\n- deterministic metrics sources\n\n## What To Build\n\nInside the demo binary, define a single source of truth for demo content:\n\n- `DemoContent` struct:\n  - `files: Vec<DemoFile { name, language_hint, text }>`\n  - `links: DemoLinks { repo_url, docs_url, ... }`\n  - `seed_logs: Vec<LogEntry>`\n  - `metric_params: MetricParams`\n\nAnd a single initializer:\n\n- `fn App::new(content: DemoContent, ...) -> App`\n\n## Design Notes\n\n- The editor’s initial file should be Rust and highlight well with the built-in tokenizer registry.\n- The preview panel should have data available immediately (no empty state).\n- Logs should start with a small backlog so scrolling is demonstrable.\n- Metrics should come from deterministic functions (sin waves, ramps) so tour mode is reproducible.\n\n## Acceptance Notes\n\n- Launching the demo immediately looks “alive” (content everywhere) without needing user actions.\n- The same run on the same terminal size produces the same initial content.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:25:34.644052627Z","created_by":"ubuntu","updated_at":"2026-01-27T23:00:34.119219042Z","compaction_level":0,"original_size":0,"labels":["content","demo_showcase","runtime"],"dependencies":[{"issue_id":"bd-hc0","depends_on_id":"bd-1ei","type":"blocks","created_at":"2026-01-27T22:32:10.064578696Z","created_by":"ubuntu"},{"issue_id":"bd-hc0","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:25:34.662342935Z","created_by":"ubuntu"},{"issue_id":"bd-hc0","depends_on_id":"bd-35g","type":"blocks","created_at":"2026-01-27T23:00:34.119189096Z","created_by":"ubuntu"}]}
{"id":"bd-ix0","title":"demo_showcase runtime: resize handling (SIGWINCH/crossterm-style events) + safe relayout","description":"# demo_showcase Runtime — Resize Handling + Safe Relayout\n\n## Purpose\n\nThe demo must survive resizes without flicker or panics.\n\n## Inputs\n\n- Primary: `Event::Resize(ResizeEvent { width, height })` from `InputParser`\n- Secondary fallback: periodic `terminal_size()` polling (optional) if resize events are missing\n\n## Behavior\n\nOn resize:\n\n1. Call `renderer.resize(new_w, new_h)`\n2. Recompute layout rectangles\n3. Reset scroll positions if out of bounds\n4. Push a toast: `Resized to WxH`\n\n## Pitfalls\n\n- Ensure we never compute negative/overflowing rects.\n- Ensure compact-mode triggers below minimum sizes.","acceptance_criteria":"Checklist:\n- [ ] Resize event triggers `renderer.resize` and full relayout\n- [ ] No panics for tiny sizes\n- [ ] Compact layout engages when needed\n- [ ] Scroll offsets are clamped after resize","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:11:00.308536814Z","created_by":"ubuntu","updated_at":"2026-01-27T22:12:28.744424548Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","runtime"],"dependencies":[{"issue_id":"bd-ix0","depends_on_id":"bd-1m9","type":"blocks","created_at":"2026-01-27T22:12:26.354314403Z","created_by":"ubuntu"},{"issue_id":"bd-ix0","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:11:00.321652289Z","created_by":"ubuntu"},{"issue_id":"bd-ix0","depends_on_id":"bd-3ii","type":"blocks","created_at":"2026-01-27T22:12:28.744401625Z","created_by":"ubuntu"}]}
{"id":"bd-j7g","title":"Terminal Capability Queries","description":"## Overview\nSend actual capability queries to the terminal instead of just checking environment variables. This enables accurate feature detection for advanced terminal features.\n\n## Scope\nQuery sequences to send (per spec Section 2.7):\n- DA1 (Primary Device Attributes): `ESC[c`\n- DA2 (Secondary Device Attributes): `ESC[>c`\n- XTVERSION: `ESC[>0q`\n- Pixel resolution: `ESC[14t`\n- Kitty keyboard protocol: `ESC[?u`\n\nParse responses to detect:\n- Terminal type and version\n- True color support\n- Kitty keyboard protocol support\n- Synchronized output support\n- Sixel graphics support\n- SGR pixel mouse mode\n\n## Implementation Details\n\n### Query Sequences\n```rust\n// In src/terminal/queries.rs\npub const DA1_QUERY: &str = \"\\x1b[c\";           // Primary device attributes\npub const DA2_QUERY: &str = \"\\x1b[>c\";          // Secondary device attributes\npub const XTVERSION_QUERY: &str = \"\\x1b[>0q\";   // Terminal version\npub const PIXEL_SIZE_QUERY: &str = \"\\x1b[14t\";  // Window pixel size\npub const KITTY_KEYBOARD_QUERY: &str = \"\\x1b[?u\"; // Kitty keyboard support\n```\n\n### Response Parser\n```rust\nimpl Terminal {\n    /// Send capability queries and collect responses.\n    /// Uses timeout to avoid blocking if terminal doesn't respond.\n    pub fn query_capabilities(&mut self, timeout: Duration) -> io::Result<()>;\n\n    /// Parse a terminal response sequence.\n    fn parse_response(&mut self, response: &[u8]) -> Option<TerminalResponse>;\n\n    /// Check for pending responses (non-blocking).\n    pub fn poll_responses(&mut self) -> Vec<TerminalResponse>;\n}\n\npub enum TerminalResponse {\n    DeviceAttributes { \n        primary: bool,  // DA1 vs DA2\n        params: Vec<u32>,\n    },\n    XtVersion { \n        name: String, \n        version: String,\n    },\n    PixelSize { \n        width: u16, \n        height: u16,\n    },\n    KittyKeyboard { \n        flags: u32,\n    },\n    Unknown(Vec<u8>),\n}\n```\n\n### Response Format Parsing\n```\nDA1 response: ESC [ ? Ps ; Ps ; ... c\n  - Parse params to detect features (e.g., 4 = sixel)\n  \nDA2 response: ESC [ > Pp ; Pv ; Pc c\n  - Pp = terminal type, Pv = firmware version, Pc = ROM cartridge\n  \nXTVERSION response: ESC P > | text ST\n  - text contains terminal name and version\n  \nPixel size response: ESC [ 4 ; height ; width t\n  - Window size in pixels\n\nKitty keyboard response: ESC [ ? flags u\n  - flags indicates supported modes\n```\n\n### Capability Updates\nMap responses to Capabilities struct updates:\n- DA1 param 4 → sixel = true\n- XTVERSION contains \"kitty\" → kitty_keyboard = true, kitty_graphics = true\n- XTVERSION contains \"foot\"/\"alacritty\"/\"wezterm\" → rgb = true\n- Pixel size response → store for sixel/image calculations\n\n## Files to Create/Modify\n- src/terminal/queries.rs - new file for query constants and response types (~100 lines)\n- src/terminal/mod.rs - add query methods and response handling (~150 lines)\n- src/terminal/capabilities.rs - update from parsed responses (~50 lines)\n\n## Testing Requirements\n\n### Unit Tests (minimum 10 tests)\n```rust\n// Response parsing tests\n#[test] fn test_parse_da1_response_basic()\n#[test] fn test_parse_da1_response_with_sixel()\n#[test] fn test_parse_da2_response()\n#[test] fn test_parse_xtversion_kitty()\n#[test] fn test_parse_xtversion_alacritty()\n#[test] fn test_parse_pixel_size_response()\n#[test] fn test_parse_kitty_keyboard_response()\n#[test] fn test_parse_unknown_response()\n\n// Query generation tests\n#[test] fn test_query_sequences_correct()\n#[test] fn test_query_all_sends_all_queries()\n\n// Integration tests\n#[test] fn test_capabilities_updated_from_da1()\n#[test] fn test_timeout_returns_partial_results()\n```\n\n### E2E Test (tests/e2e/capability_queries.rs)\n```rust\n/// Interactive test that queries real terminal and logs results.\n/// Run with: cargo test --test capability_e2e -- --nocapture\n#[test]\nfn e2e_query_real_terminal() {\n    // Setup logging\n    env_logger::init();\n    \n    let mut terminal = Terminal::new()?;\n    \n    log::info!(\"Sending capability queries...\");\n    terminal.query_capabilities(Duration::from_secs(2))?;\n    \n    for response in terminal.poll_responses() {\n        log::info!(\"Response: {:?}\", response);\n    }\n    \n    log::info!(\"Final capabilities: {:?}\", terminal.capabilities());\n}\n```\n\n## Acceptance Criteria\n- [ ] All 5 query sequences sent in correct format\n- [ ] DA1 response parsed correctly, sixel detected\n- [ ] DA2 response parsed correctly\n- [ ] XTVERSION response extracts terminal name/version\n- [ ] Pixel size response extracts dimensions\n- [ ] Kitty keyboard response parsed\n- [ ] Unknown responses don't crash (return Unknown variant)\n- [ ] Timeout prevents hanging on non-responsive terminals\n- [ ] Capabilities struct updated from parsed responses\n- [ ] All 10+ unit tests pass\n- [ ] E2E test logs all responses clearly","acceptance_criteria":"- [ ] Queries sent in correct format\n- [ ] Responses parsed correctly\n- [ ] Capabilities updated from responses\n- [ ] Timeout prevents hanging\n- [ ] All 6+ unit tests pass\n\n---","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:39:27.027350423Z","closed_at":"2026-01-19T22:39:27.027254532Z","compaction_level":0,"original_size":0}
{"id":"bd-jfno","title":"demo_showcase tests: core logic unit suite (layout/config/palette/log models)","description":"# demo_showcase Tests — Core Logic “Unit” Suite (Headless Checks)\n\n## Purpose\n\nWe want unit-level confidence for the demo’s core logic without requiring a real TTY.\n\nBecause most demo code lives in the binary, the most reliable approach is to expose deterministic headless “checks” and validate them from integration tests.\n\nThis bead adds tests that cover:\n\n- CLI/config parsing (flag combinations)\n- layout math invariants (no negative rects, no overflow, compact mode triggers)\n- command palette scoring + selection behavior\n- log model behavior (ring buffer, selection, hyperlink row formatting)\n- hit ID mapping invariants (IDs stable, no overlap across ranges)\n\n## Approach\n\nExtend headless support with a deterministic sub-mode that runs specific checks and emits JSON:\n\n- --headless-check <name>\n\nExamples:\n\n- --headless-check layout\n- --headless-check palette\n- --headless-check hitgrid\n\nEach check should:\n\n- run without a TTY\n- produce structured JSON with:\n  - inputs\n  - outputs\n  - key derived values\n- exit 0 on pass, non-zero on failure\n\nIntegration tests then:\n\n- run cargo run --bin demo_showcase -- --headless-check <name> --headless-dump-json\n- snapshot the JSON with insta\n\n## Logging\n\n- Always print a short summary line to stdout.\n- On failure, dump detailed context to stderr.\n- When HARNESS_ARTIFACTS=1, write JSON to target/test-artifacts.\n\n## Acceptance Notes\n\n- The suite catches regressions in layout/palette/ID mapping before they show up as UI glitches.\n- Failures are easy to diagnose from logs and JSON snapshots.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:50:08.436032991Z","created_by":"ubuntu","updated_at":"2026-01-27T22:51:00.588392750Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","testing"],"dependencies":[{"issue_id":"bd-jfno","depends_on_id":"bd-1w9","type":"blocks","created_at":"2026-01-27T22:50:58.873257268Z","created_by":"ubuntu"},{"issue_id":"bd-jfno","depends_on_id":"bd-2c6","type":"blocks","created_at":"2026-01-27T22:51:00.588365689Z","created_by":"ubuntu"},{"issue_id":"bd-jfno","depends_on_id":"bd-2el","type":"blocks","created_at":"2026-01-27T22:50:56.997493692Z","created_by":"ubuntu"},{"issue_id":"bd-jfno","depends_on_id":"bd-2iv","type":"blocks","created_at":"2026-01-27T22:50:57.654657671Z","created_by":"ubuntu"},{"issue_id":"bd-jfno","depends_on_id":"bd-35rk","type":"blocks","created_at":"2026-01-27T22:50:59.919227325Z","created_by":"ubuntu"},{"issue_id":"bd-jfno","depends_on_id":"bd-383","type":"parent-child","created_at":"2026-01-27T22:50:08.447911428Z","created_by":"ubuntu"},{"issue_id":"bd-jfno","depends_on_id":"bd-3ii","type":"blocks","created_at":"2026-01-27T22:50:58.207386414Z","created_by":"ubuntu"}]}
{"id":"bd-jqv","title":"demo_showcase UI: tour overlay + spotlight (step HUD + highlight)","description":"# demo_showcase UI — Tour Overlay + Spotlight (Step HUD + Highlight)\n\n## Purpose\n\nTour mode is a core “unattended demo” deliverable. Visually, it needs a HUD that makes the tour understandable:\n\n- what step we’re on\n- what feature is being demonstrated\n- what the viewer should notice\n\nAnd it needs a “spotlight” effect so the viewer’s eye goes to the right area.\n\n## Visual Requirements\n\n- A compact step HUD overlay (top-right or centered) with:\n  - step title\n  - step counter (e.g., `3/12`)\n  - short callout text (“Notice the alpha blended glass overlay”) \n  - controls: `Next`, `Pause`, `Exit` (clickable)\n\n- A spotlight/highlight effect:\n  - dim the entire screen with a translucent tint\n  - “punch out” or brighten the target rectangle (panel or UI element)\n  - optionally add an animated outline/glow around the target\n\nImplementation note: since we don’t have true compositing masks, approximate punch-out by drawing dim backdrop first, then redraw the target region at full opacity and add a border.\n\n## Input\n\n- Keyboard: `Space` next, `P` pause, `Esc` exit tour\n- Mouse: clicking `Next/Pause/Exit` uses HitGrid\n\n## Integration\n\n- Tour overlay rendering must be driven by the tour script state (`bd-1gy`) and tour runtime driver.\n- The overlay should not require the command palette or help overlay; it is its own UI layer.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:24:55.998651790Z","created_by":"ubuntu","updated_at":"2026-01-27T22:32:08.966436353Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","ui"],"dependencies":[{"issue_id":"bd-jqv","depends_on_id":"bd-1al","type":"blocks","created_at":"2026-01-27T22:32:07.895805744Z","created_by":"ubuntu"},{"issue_id":"bd-jqv","depends_on_id":"bd-1gy","type":"blocks","created_at":"2026-01-27T22:32:08.433392382Z","created_by":"ubuntu"},{"issue_id":"bd-jqv","depends_on_id":"bd-3o0","type":"blocks","created_at":"2026-01-27T22:32:08.966407429Z","created_by":"ubuntu"},{"issue_id":"bd-jqv","depends_on_id":"bd-c75","type":"parent-child","created_at":"2026-01-27T22:24:56.010957522Z","created_by":"ubuntu"}]}
{"id":"bd-pnln","title":"opentui API: expose terminal capabilities from Renderer (for inspector/gating)","description":"# OpenTUI API — Expose Terminal Capabilities from Renderer\n\n## Purpose\n\nThe demo_showcase (and real applications) need to make capability decisions and display capability state:\n\n- true color vs 256-color\n- synchronized output support\n- hyperlink support\n- mouse / focus / bracketed paste availability\n\nToday, `Terminal` exposes `capabilities()`, but `Renderer` does not.\n\nThis bead adds a small, ergonomic API surface so applications can query what the renderer believes about the terminal.\n\n## Proposed API\n\n- Renderer::capabilities(&self) -> &Capabilities\n\nOptional (only if needed):\n\n- Renderer::capabilities_mut(&mut self) -> &mut Capabilities (generally avoid unless the demo needs manual overrides)\n\n## Notes\n\n- Capabilities are currently populated by `Capabilities::detect()` plus any query responses that the terminal parser applies.\n- Even if query responses are not fully wired in the renderer loop, exposing the detected capabilities is still valuable.\n\n## Acceptance Notes\n\n- demo_showcase inspector panel can display capability flags without re-detecting.\n- No behavioral change for existing code (this is a pure accessor).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-27T22:54:53.616746157Z","created_by":"ubuntu","updated_at":"2026-01-27T22:55:05.892217149Z","compaction_level":0,"original_size":0,"labels":["api","demo_showcase"],"dependencies":[{"issue_id":"bd-pnln","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:54:53.629301807Z","created_by":"ubuntu"}]}
{"id":"bd-po1","title":"demo_showcase runtime: render pass orchestration (z-order, scissor/opacity conventions)","description":"# demo_showcase Runtime — Render Pass Orchestration\n\n## Purpose\n\nDefine a consistent render pipeline so the demo has a stable “z-order” and the code remains understandable.\n\n## Proposed Pass Order (Back-to-Front)\n\n1. **Background**\n   - Fill screen with `BG0`\n   - Subtle gradient noise/pulse (low alpha)\n\n2. **Chrome**\n   - Top bar (gradient header)\n   - Status bar (key hints + stats)\n\n3. **Panels** (each clipped)\n   - Sidebar\n   - Editor\n   - Preview\n   - Logs\n\n4. **Overlays** (semi-transparent, “glass”)\n   - Help\n   - Command palette\n   - Tour overlay\n\n5. **Toasts**\n   - Small ephemeral notifications stacked in a corner\n\n6. **Debug / Perf Overlay**\n   - OpenTUI’s `Renderer::set_debug_overlay(true)` is separate, but we can also draw our own lightweight stats.\n\n## Scissor + Opacity Conventions\n\n- Every panel uses:\n  - `push_scissor(inner_rect)` before content\n  - optional `push_opacity(alpha)` for “glass” content areas\n  - then pop in reverse order\n\n- Overlays:\n  - full-screen scissor\n  - first draw dimming rectangle with opacity\n  - then draw modal panel\n\n## Grapheme Pool Conventions\n\n- Default UI text can use `buffer.draw_text`.\n- Any place we want to **prove multi-codepoint graphemes** must use pool-aware drawing:\n  - `let (buf, pool) = renderer.buffer_with_pool();`\n  - `buf.draw_text_with_pool(pool, ...)` or `TextBufferView::render_to_with_pool(...)`\n\n## HitGrid Conventions\n\n- `renderer.clear()` already clears the hit grid.\n- While rendering, register hit areas *after* layout is computed.\n- For nested hit areas, use `push_hit_scissor()` matching the visual scissor so clicks align with clipped visuals.","acceptance_criteria":"Checklist:\n- [ ] Render pass order is implemented and documented in code\n- [ ] Scissor/opacity usage follows a consistent convention\n- [ ] Pool-aware rendering is used intentionally where needed\n- [ ] HitGrid registration aligns with visual layout + clipping","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:10:19.480963690Z","created_by":"ubuntu","updated_at":"2026-01-27T22:46:49.843285918Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","rendering","runtime"],"dependencies":[{"issue_id":"bd-po1","depends_on_id":"bd-1ok","type":"blocks","created_at":"2026-01-27T22:12:17.874683866Z","created_by":"ubuntu"},{"issue_id":"bd-po1","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:10:19.504111190Z","created_by":"ubuntu"},{"issue_id":"bd-po1","depends_on_id":"bd-35g","type":"related","created_at":"2026-01-27T22:46:49.843230976Z","created_by":"ubuntu"},{"issue_id":"bd-po1","depends_on_id":"bd-3ii","type":"blocks","created_at":"2026-01-27T22:12:15.346407203Z","created_by":"ubuntu"}]}
{"id":"bd-qgg","title":"Optimize fill_rect() to compute scissor intersection once","description":"Currently fill_rect() calls set() which checks scissor visibility for each cell. Could compute the intersection of fill rect and scissor rect once upfront and use direct index writes.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-21T16:54:40.748937999Z","created_by":"ubuntu","updated_at":"2026-01-21T17:01:25.827227408Z","closed_at":"2026-01-21T17:01:25.826168742Z","close_reason":"Precompute scissor intersection in fill_rect; direct slice fill with opacity; cargo check/clippy/fmt clean","compaction_level":0,"original_size":0}
{"id":"bd-qn5","title":"demo_showcase UI: preview panel (PixelBuffer/Grayscale + charts + compositing)","description":"# demo_showcase UI — Preview Panel (Pixels + Charts + Compositing)\n\n## Purpose\n\nThis panel is the “wow” canvas:\n\n- demonstrate `PixelBuffer` supersampling / quadrant rendering\n- demonstrate `GrayscaleBuffer` shading\n- demonstrate alpha blending overlays (glass + shadow)\n- demonstrate scissor clipping within a panel\n\n## Content\n\n- A small animated pixel scene (e.g., rotating gradient orb)\n- A tiny sparkline chart (CPU/FPS)\n- A “layer stack” demo: translucent panels over the pixel scene\n\n## Implementation Notes\n\n- Use `PixelBuffer::new(w*2, h*2)` so each cell is 2×2 pixels.\n- Render into the `OptimizedBuffer` using:\n  - `draw_supersample_buffer`\n  - `draw_grayscale_buffer_unicode`\n\n- Use scissor to clip the drawing to the preview panel’s inner rect.\n\n## Alpha Blending\n\nOverlay examples:\n\n- semi-transparent card showing metrics\n- drop-shadow-ish effect by drawing a darker translucent rect offset by 1","acceptance_criteria":"Checklist:\n- [ ] PixelBuffer supersampling output renders in preview panel\n- [ ] Grayscale output renders (ASCII or Unicode shades)\n- [ ] Animations are smooth and deterministic\n- [ ] Alpha overlays visibly blend (not just opaque boxes)\n- [ ] Scissor clipping prevents drawing outside panel","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:14:02.973227571Z","created_by":"ubuntu","updated_at":"2026-01-27T22:33:27.331161022Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","graphics","ui"],"dependencies":[{"issue_id":"bd-qn5","depends_on_id":"bd-1pd","type":"blocks","created_at":"2026-01-27T22:31:55.065627624Z","created_by":"ubuntu"},{"issue_id":"bd-qn5","depends_on_id":"bd-2t3","type":"blocks","created_at":"2026-01-27T22:31:56.175361670Z","created_by":"ubuntu"},{"issue_id":"bd-qn5","depends_on_id":"bd-35g","type":"blocks","created_at":"2026-01-27T22:31:55.612698965Z","created_by":"ubuntu"},{"issue_id":"bd-qn5","depends_on_id":"bd-3ii","type":"blocks","created_at":"2026-01-27T22:33:18.057812975Z","created_by":"ubuntu"},{"issue_id":"bd-qn5","depends_on_id":"bd-c75","type":"parent-child","created_at":"2026-01-27T22:14:02.992233416Z","created_by":"ubuntu"},{"issue_id":"bd-qn5","depends_on_id":"bd-hc0","type":"blocks","created_at":"2026-01-27T22:33:22.206776469Z","created_by":"ubuntu"},{"issue_id":"bd-qn5","depends_on_id":"bd-po1","type":"blocks","created_at":"2026-01-27T22:33:27.331134582Z","created_by":"ubuntu"}]}
{"id":"bd-rqd","title":"Add Selection Extension Methods","description":"## Overview\nAdd methods to start and extend selections in EditorView.\n\n## Already Implemented (NO WORK NEEDED)\nThe following already exists in `src/text/editor.rs`:\n- `scroll_margin` field ✓\n- `set_scroll_margin()` at line 117 ✓\n- `selection_follow_cursor` field ✓\n- `set_selection_follow_cursor()` at line 122 ✓\n- `set_selection()` for setting selection range ✓\n- `clear_selection()` at line 142 ✓\n\n## Scope (Methods to Add)\n```rust\nimpl EditorView {\n    /// Start a new selection at current cursor position.\n    pub fn start_selection(&mut self) {\n        let offset = self.edit_buffer.cursor().offset;\n        self.selection = Some(Selection::new(offset, offset, self.selection_style));\n    }\n\n    /// Extend selection to current cursor position.\n    pub fn extend_selection_to_cursor(&mut self) {\n        if let Some(sel) = &mut self.selection {\n            sel.end = self.edit_buffer.cursor().offset;\n        } else {\n            // If no selection, start one\n            self.start_selection();\n        }\n    }\n\n    /// Get the selected text, if any.\n    pub fn selected_text(&self) -> Option<String> {\n        self.selection.map(|sel| {\n            let (start, end) = (sel.start.min(sel.end), sel.start.max(sel.end));\n            self.edit_buffer.buffer()\n                .rope()\n                .slice(start..end)\n                .map(|s| s.to_string())\n        }).flatten()\n    }\n}\n```\n\n## Files to Modify\n- src/text/editor.rs - Add the 3 new methods\n\n## Testing Requirements\n\n### Unit Tests (add to existing tests in src/text/editor.rs)\n```rust\n#[test]\nfn test_start_selection() {\n    let buffer = EditBuffer::with_text(\"Hello, World!\");\n    let mut view = EditorView::new(buffer);\n    \n    view.edit_buffer_mut().move_to_offset(7);  // After \", \"\n    eprintln!(\"[TEST] Cursor at offset 7\");\n    \n    view.start_selection();\n    \n    assert!(view.selection.is_some());\n    let sel = view.selection.unwrap();\n    eprintln!(\"[TEST] Selection: start={} end={}\", sel.start, sel.end);\n    \n    assert_eq!(sel.start, 7);\n    assert_eq!(sel.end, 7, \"New selection should have same start and end\");\n    \n    eprintln!(\"[TEST] PASS: start_selection creates selection at cursor\");\n}\n\n#[test]\nfn test_extend_selection_to_cursor() {\n    let buffer = EditBuffer::with_text(\"Hello, World!\");\n    let mut view = EditorView::new(buffer);\n    \n    // Start selection at position 0\n    view.start_selection();\n    eprintln!(\"[TEST] Started selection at 0\");\n    \n    // Move cursor and extend\n    view.edit_buffer_mut().move_to_offset(5);  // After \"Hello\"\n    view.extend_selection_to_cursor();\n    \n    let sel = view.selection.unwrap();\n    eprintln!(\"[TEST] After extending: start={} end={}\", sel.start, sel.end);\n    \n    assert_eq!(sel.start, 0);\n    assert_eq!(sel.end, 5, \"Selection should extend to cursor\");\n    \n    // Extend further\n    view.edit_buffer_mut().move_to_offset(13);  // End\n    view.extend_selection_to_cursor();\n    \n    let sel = view.selection.unwrap();\n    eprintln!(\"[TEST] Extended to end: start={} end={}\", sel.start, sel.end);\n    assert_eq!(sel.end, 13);\n    \n    eprintln!(\"[TEST] PASS: extend_selection_to_cursor works\");\n}\n\n#[test]\nfn test_extend_selection_backward() {\n    let buffer = EditBuffer::with_text(\"Hello, World!\");\n    let mut view = EditorView::new(buffer);\n    \n    // Start selection in middle\n    view.edit_buffer_mut().move_to_offset(7);\n    view.start_selection();\n    \n    // Extend backward\n    view.edit_buffer_mut().move_to_offset(0);\n    view.extend_selection_to_cursor();\n    \n    let sel = view.selection.unwrap();\n    eprintln!(\"[TEST] Backward selection: start={} end={}\", sel.start, sel.end);\n    \n    // start > end is valid (indicates backward selection)\n    assert_eq!(sel.start, 7);\n    assert_eq!(sel.end, 0);\n    \n    eprintln!(\"[TEST] PASS: Selection can extend backward\");\n}\n\n#[test]\nfn test_selected_text() {\n    let buffer = EditBuffer::with_text(\"Hello, World!\");\n    let mut view = EditorView::new(buffer);\n    \n    // No selection initially\n    assert!(view.selected_text().is_none());\n    eprintln!(\"[TEST] No selection initially\");\n    \n    // Create selection\n    view.set_selection(0, 5);  // \"Hello\"\n    \n    let text = view.selected_text();\n    eprintln!(\"[TEST] Selected text: {:?}\", text);\n    \n    assert_eq!(text, Some(\"Hello\".to_string()));\n    \n    // Backward selection should also work\n    view.set_selection(13, 7);  // \"World!\" backward\n    let text = view.selected_text();\n    eprintln!(\"[TEST] Backward selection text: {:?}\", text);\n    assert_eq!(text, Some(\"World!\".to_string()));\n    \n    eprintln!(\"[TEST] PASS: selected_text returns correct content\");\n}\n\n#[test]\nfn test_selection_with_cursor_movement() {\n    let buffer = EditBuffer::with_text(\"Line 1\\nLine 2\\nLine 3\");\n    let mut view = EditorView::new(buffer);\n    \n    // Start selection\n    view.start_selection();\n    eprintln!(\"[TEST] Started selection at line 0\");\n    \n    // Move down and extend\n    view.edit_buffer_mut().move_down();\n    view.extend_selection_to_cursor();\n    \n    let sel = view.selection.unwrap();\n    eprintln!(\"[TEST] Selection after move_down: {} to {}\", sel.start, sel.end);\n    \n    // Should have selected \"Line 1\\n\" (or part of it)\n    let text = view.selected_text().unwrap();\n    eprintln!(\"[TEST] Selected: {:?}\", text);\n    \n    assert!(text.contains(\"Line\"));\n    \n    eprintln!(\"[TEST] PASS: Selection works with cursor movement\");\n}\n\n#[test]\nfn test_selection_follow_cursor_mode() {\n    let buffer = EditBuffer::with_text(\"Hello, World!\");\n    let mut view = EditorView::new(buffer);\n    \n    // Enable selection follow cursor\n    view.set_selection_follow_cursor(true);\n    view.set_selection(0, 0);\n    \n    eprintln!(\"[TEST] Selection follow cursor enabled\");\n    \n    // Move cursor - selection should extend automatically\n    view.edit_buffer_mut().move_to_offset(5);\n    view.scroll_to_cursor(80, 24);  // This triggers selection follow\n    \n    let sel = view.selection.unwrap();\n    eprintln!(\"[TEST] After cursor move: selection end={}\", sel.end);\n    \n    assert_eq!(sel.end, 5, \"Selection should follow cursor\");\n    \n    eprintln!(\"[TEST] PASS: selection_follow_cursor mode works\");\n}\n```\n\n## Acceptance Criteria\n- [ ] `start_selection()` creates selection at current cursor position\n- [ ] `extend_selection_to_cursor()` extends selection to cursor position\n- [ ] Selection can extend both forward and backward\n- [ ] `selected_text()` returns the selected content\n- [ ] Selection works correctly with cursor movement operations\n- [ ] All 6 new unit tests pass with detailed logging\n- [ ] Existing EditorView tests still pass (no regression)","acceptance_criteria":"- [ ] Scroll margin prevents cursor at edge\n- [ ] Selection extends correctly with cursor movement\n- [ ] All 6+ unit tests pass\n\n---","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:32:45.644852908Z","closed_at":"2026-01-19T22:32:45.644792224Z","close_reason":"done","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-rqd","depends_on_id":"bd-1tl","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-skg","title":"Fix Tab Character Highlight Rendering","description":"## Overview\nFix a bug where tab characters don't preserve highlight/styled segment colors during rendering.\n\n## Bug Description (CORRECTED)\n**Previous description was INCORRECT.** The original bead claimed that `render_line()` doesn't call `style_at()`, but this is **wrong**.\n\n**Actual behavior:**\n- At line 528 in `src/text/view.rs`, regular graphemes DO correctly call `self.buffer.style_at(byte_offset)` ✓\n- At line 483, tab characters use `self.buffer.default_style()` instead of `style_at()` ✗\n\nThis means if you have highlighted text containing tabs, the tabs will render with the default style instead of the highlight color.\n\n## Steps to Reproduce\n1. Create a TextBuffer: `buffer.set_text(\"Hello\\tWorld\")`\n2. Add a highlight spanning the tab: `buffer.add_highlight(0..11, Style::bold(), 1)`\n3. Render with TextBufferView\n4. Observe: \"Hello\" and \"World\" are bold, but the tab spaces between them are NOT bold\n\n## Current Broken Code (line 483 in view.rs)\n```rust\nif grapheme == \"\\t\" {\n    let tab_width = self.buffer.tab_width().max(1) as u32;\n    let spaces_to_next = tab_width - (col % tab_width);\n    for space_idx in 0..spaces_to_next {\n        let screen_col = col as i32 - scroll_x + dest_x;\n        if screen_col >= dest_x && col < self.viewport.width + self.scroll_x {\n            if screen_col >= 0 {\n                let mut style = self.buffer.default_style();  // BUG: Should use style_at()\n                // ... rest of tab rendering\n            }\n        }\n    }\n}\n```\n\n## Required Fix\n```rust\nif grapheme == \"\\t\" {\n    let tab_width = self.buffer.tab_width().max(1) as u32;\n    let spaces_to_next = tab_width - (col % tab_width);\n    let byte_offset = rope.char_to_byte(global_char_offset);  // ADD THIS\n    let base_style = self.buffer.style_at(byte_offset);       // FIX: Get actual style\n    \n    for space_idx in 0..spaces_to_next {\n        let screen_col = col as i32 - scroll_x + dest_x;\n        if screen_col >= dest_x && col < self.viewport.width + self.scroll_x {\n            if screen_col >= 0 {\n                let mut style = base_style;  // Use the actual style from buffer\n                // ... rest of tab rendering\n            }\n        }\n    }\n}\n```\n\n## Files to Modify\n- src/text/view.rs - Fix tab handling in `render_line()` to call `style_at()`\n\n## Testing Requirements\n\n### Unit Tests (add to src/text/view.rs tests module)\n```rust\n#[test]\nfn test_render_tab_preserves_highlight() {\n    use crate::buffer::OptimizedBuffer;\n    \n    let mut buffer = TextBuffer::new();\n    buffer.set_text(\"Hello\\tWorld\");\n    buffer.add_highlight(0..11, Style::bold(), 1);\n    \n    eprintln!(\"[TEST] Text: {:?}\", buffer.to_string());\n    eprintln!(\"[TEST] Highlight: 0..11 (entire text including tab)\");\n    \n    let view = TextBufferView::new(&buffer).viewport(0, 0, 40, 1);\n    let mut output = OptimizedBuffer::new(40, 1);\n    view.render_to(&mut output, 0, 0);\n    \n    // Log each cell\n    for x in 0..20 {\n        if let Some(cell) = output.get(x, 0) {\n            let ch = cell.content.grapheme.as_deref().unwrap_or(\" \");\n            let is_bold = cell.style.attrs.bold;\n            eprintln!(\"[TEST] Cell[{}]: {:?} bold={}\", x, ch, is_bold);\n        }\n    }\n    \n    // Verify \"Hello\" cells (0-4) are bold\n    for x in 0..5 {\n        let cell = output.get(x, 0).expect(\"Cell should exist\");\n        assert!(cell.style.attrs.bold, \"Cell {} 'Hello' should be bold\", x);\n    }\n    \n    // Verify tab spaces (cells 5-7 assuming tab_width=4) are also bold\n    for x in 5..8 {\n        let cell = output.get(x, 0).expect(\"Tab cell should exist\");\n        assert!(cell.style.attrs.bold, \n            \"Tab cell {} should be bold (preserving highlight), style={:?}\", \n            x, cell.style);\n    }\n    \n    // Verify \"World\" cells are bold\n    for x in 8..13 {\n        if let Some(cell) = output.get(x, 0) {\n            assert!(cell.style.attrs.bold, \"Cell {} 'World' should be bold\", x);\n        }\n    }\n    \n    eprintln!(\"[TEST] PASS: Tab characters preserve highlight style\");\n}\n\n#[test]\nfn test_render_tab_with_selection() {\n    use crate::buffer::OptimizedBuffer;\n    \n    let mut buffer = TextBuffer::new();\n    buffer.set_text(\"A\\tB\");\n    \n    eprintln!(\"[TEST] Text: {:?}\", buffer.to_string());\n    \n    let selection_style = Style::builder().bg(Rgba::from_rgb_u8(60, 60, 120)).build();\n    let mut view = TextBufferView::new(&buffer).viewport(0, 0, 20, 1);\n    view.set_selection(0, 3, selection_style);  // Select \"A\\tB\"\n    \n    let mut output = OptimizedBuffer::new(20, 1);\n    view.render_to(&mut output, 0, 0);\n    \n    // Log cells\n    for x in 0..10 {\n        if let Some(cell) = output.get(x, 0) {\n            let ch = cell.content.grapheme.as_deref().unwrap_or(\" \");\n            let has_bg = cell.style.bg.is_some();\n            eprintln!(\"[TEST] Cell[{}]: {:?} has_bg={}\", x, ch, has_bg);\n        }\n    }\n    \n    // All selected cells (A, tab spaces, B) should have selection background\n    let cell_a = output.get(0, 0).unwrap();\n    assert!(cell_a.style.bg.is_some(), \"Cell 'A' should have selection bg\");\n    \n    // Tab cells (1-3 or so) should also have selection bg\n    for x in 1..4 {\n        if let Some(cell) = output.get(x, 0) {\n            assert!(cell.style.bg.is_some(), \n                \"Tab cell {} should have selection bg, style={:?}\", x, cell.style);\n        }\n    }\n    \n    eprintln!(\"[TEST] PASS: Tab characters show selection style\");\n}\n\n#[test]\nfn test_render_multiple_highlights_with_tabs() {\n    use crate::buffer::OptimizedBuffer;\n    \n    let mut buffer = TextBuffer::new();\n    buffer.set_text(\"red\\tgreen\\tblue\");\n    \n    // Different highlights for each word\n    buffer.add_highlight(0..3, Style::fg(Rgba::RED), 1);      // \"red\"\n    buffer.add_highlight(4..9, Style::fg(Rgba::GREEN), 1);    // \"green\"  \n    buffer.add_highlight(10..14, Style::fg(Rgba::BLUE), 1);   // \"blue\"\n    \n    eprintln!(\"[TEST] Text with multiple highlights separated by tabs\");\n    \n    let view = TextBufferView::new(&buffer).viewport(0, 0, 40, 1);\n    let mut output = OptimizedBuffer::new(40, 1);\n    view.render_to(&mut output, 0, 0);\n    \n    // Verify colors (tabs should NOT have highlight colors since they're between words)\n    let cell_r = output.get(0, 0).unwrap();\n    eprintln!(\"[TEST] 'r' cell fg: {:?}\", cell_r.style.fg);\n    \n    eprintln!(\"[TEST] PASS: Multiple highlights with tabs render correctly\");\n}\n```\n\n## Acceptance Criteria\n- [ ] Tab characters within highlighted regions render with the highlight style\n- [ ] Tab characters within selections render with the selection style  \n- [ ] Tab indicator (if enabled) still works with highlights\n- [ ] Multiple highlights with tabs between them render correctly\n- [ ] All 3 new unit tests pass with detailed logging\n- [ ] Existing view tests still pass (no regression)\n- [ ] Visual verification in terminal shows tabs with correct colors","acceptance_criteria":"- [ ] Highlights from add_highlight() render with correct style\n- [ ] Selection renders with selection style\n- [ ] Selection style takes priority over highlights\n- [ ] Multiple overlapping highlights use priority ordering\n- [ ] UTF-8/grapheme boundaries don't break highlighting\n- [ ] All 6+ unit tests pass\n- [ ] Visual verification in terminal shows colored text\n\n---","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:01:41.916831110Z","closed_at":"2026-01-19T22:01:41.916788139Z","close_reason":"done","compaction_level":0,"original_size":0}
{"id":"bd-u5n","title":"Address GitHub large-file warning for target-sagebeacon artifact","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-26T04:05:32.104810030Z","created_by":"ubuntu","updated_at":"2026-01-27T06:54:11.736762921Z","closed_at":"2026-01-27T06:54:11.736685737Z","close_reason":"Added target-sagebeacon/ to .gitignore to prevent large build artifact tracking","compaction_level":0,"original_size":0}
{"id":"bd-vde","title":"Add Comprehensive Mouse Input Tests","description":"## Overview\nThe mouse input parser is already fully implemented. This bead is for adding comprehensive tests with detailed logging to verify all mouse functionality works correctly.\n\n## Already Implemented (NO WORK NEEDED)\nThe following functionality already exists in `src/input/parser.rs` and `src/terminal/mouse.rs`:\n- SGR mouse parsing (`parse_sgr_mouse()`) ✓\n- X11 mouse parsing (`parse_x11_mouse()`) ✓\n- `MouseEvent`, `MouseButton`, `MouseEventKind` types ✓\n- Button press/release detection (M vs m) ✓\n- Coordinate conversion (1-indexed to 0-indexed) ✓\n- Modifier detection (Shift, Ctrl, Alt) ✓\n- Scroll wheel events (Up, Down, Left, Right) ✓\n- Motion/drag events ✓\n- Existing tests: `test_parse_sgr_mouse`, `test_parse_sgr_mouse_release`, `test_mouse_event`, `test_mouse_scroll`, `test_mouse_modifiers` ✓\n\n## Scope (Tests Only)\nAdd additional unit tests with detailed logging to verify edge cases and ensure complete coverage.\n\n## Files to Modify\n- src/input/parser.rs - Add more tests to the existing test module\n- src/terminal/mouse.rs - Add more tests to the existing test module\n\n## Testing Requirements\n\n### Additional Unit Tests (in src/input/parser.rs)\n```rust\n#[test]\nfn test_parse_sgr_mouse_middle_click() {\n    let mut parser = InputParser::new();\n    // Middle click: button=1\n    let input = b\"\\x1b[<1;20;10M\";\n    eprintln!(\"[TEST] Input: {:?}\", input);\n    \n    let (event, _) = parser.parse(input).unwrap();\n    let mouse = event.mouse().unwrap();\n    \n    eprintln!(\"[TEST] Mouse event: {:?}\", mouse);\n    eprintln!(\"[TEST] Button: {:?}\", mouse.button);\n    \n    assert_eq!(mouse.button, MouseButton::Middle);\n    assert_eq!(mouse.kind, MouseEventKind::Press);\n    eprintln!(\"[TEST] PASS: Middle click detected\");\n}\n\n#[test]\nfn test_parse_sgr_mouse_right_click() {\n    let mut parser = InputParser::new();\n    // Right click: button=2\n    let input = b\"\\x1b[<2;20;10M\";\n    eprintln!(\"[TEST] Input: {:?}\", input);\n    \n    let (event, _) = parser.parse(input).unwrap();\n    let mouse = event.mouse().unwrap();\n    \n    eprintln!(\"[TEST] Button: {:?}\", mouse.button);\n    assert_eq!(mouse.button, MouseButton::Right);\n    eprintln!(\"[TEST] PASS: Right click detected\");\n}\n\n#[test]\nfn test_parse_sgr_mouse_with_modifiers() {\n    let mut parser = InputParser::new();\n    // Ctrl+Left click: button=0 + ctrl(16) = 16\n    let input = b\"\\x1b[<16;30;15M\";\n    eprintln!(\"[TEST] Input: {:?}\", input);\n    eprintln!(\"[TEST] Button byte: 16 = 0(left) + 16(ctrl)\");\n    \n    let (event, _) = parser.parse(input).unwrap();\n    let mouse = event.mouse().unwrap();\n    \n    eprintln!(\"[TEST] Mouse event: {:?}\", mouse);\n    eprintln!(\"[TEST] Button: {:?}, Ctrl: {}, Shift: {}, Alt: {}\", \n        mouse.button, mouse.ctrl, mouse.shift, mouse.alt);\n    \n    assert_eq!(mouse.button, MouseButton::Left);\n    assert!(mouse.ctrl, \"Ctrl modifier should be set\");\n    eprintln!(\"[TEST] PASS: Ctrl modifier detected\");\n}\n\n#[test]\nfn test_parse_sgr_mouse_scroll() {\n    let mut parser = InputParser::new();\n    // Scroll up: 64\n    let input = b\"\\x1b[<64;10;5M\";\n    eprintln!(\"[TEST] Testing scroll up\");\n    \n    let (event, _) = parser.parse(input).unwrap();\n    let mouse = event.mouse().unwrap();\n    \n    eprintln!(\"[TEST] Event kind: {:?}\", mouse.kind);\n    assert_eq!(mouse.kind, MouseEventKind::ScrollUp);\n    \n    // Scroll down: 65\n    let input = b\"\\x1b[<65;10;5M\";\n    let (event, _) = parser.parse(input).unwrap();\n    let mouse = event.mouse().unwrap();\n    assert_eq!(mouse.kind, MouseEventKind::ScrollDown);\n    \n    eprintln!(\"[TEST] PASS: Scroll events detected\");\n}\n\n#[test]\nfn test_parse_sgr_mouse_motion() {\n    let mut parser = InputParser::new();\n    // Motion with left button held: 32 (motion flag) + 0 (left) = 32\n    let input = b\"\\x1b[<32;50;25M\";\n    eprintln!(\"[TEST] Testing drag motion\");\n    \n    let (event, _) = parser.parse(input).unwrap();\n    let mouse = event.mouse().unwrap();\n    \n    eprintln!(\"[TEST] Event kind: {:?}, Button: {:?}\", mouse.kind, mouse.button);\n    assert_eq!(mouse.kind, MouseEventKind::Move);\n    eprintln!(\"[TEST] PASS: Motion event detected\");\n}\n\n#[test]\nfn test_parse_sgr_mouse_large_coordinates() {\n    let mut parser = InputParser::new();\n    // Large coordinates (common in high-res terminals)\n    let input = b\"\\x1b[<0;999;500M\";\n    eprintln!(\"[TEST] Testing large coordinates (999, 500)\");\n    \n    let (event, _) = parser.parse(input).unwrap();\n    let mouse = event.mouse().unwrap();\n    \n    eprintln!(\"[TEST] Coordinates: ({}, {})\", mouse.x, mouse.y);\n    assert_eq!(mouse.x, 998, \"X should be 999-1=998 (0-indexed)\");\n    assert_eq!(mouse.y, 499, \"Y should be 500-1=499 (0-indexed)\");\n    eprintln!(\"[TEST] PASS: Large coordinates handled\");\n}\n\n#[test]\nfn test_parse_x11_mouse_basic() {\n    let mut parser = InputParser::new();\n    // X11 encoding: ESC[M followed by button+32, x+32, y+32\n    // Left click at (10, 5): button=0+32=32, x=10+32=42, y=5+32=37\n    let input = b\"\\x1b[M *%\"; // 32=' ', 42='*', 37='%'\n    eprintln!(\"[TEST] Testing X11 mouse encoding\");\n    eprintln!(\"[TEST] Input bytes: {:?}\", input);\n    \n    let (event, consumed) = parser.parse(input).unwrap();\n    eprintln!(\"[TEST] Consumed: {} bytes\", consumed);\n    \n    let mouse = event.mouse().unwrap();\n    eprintln!(\"[TEST] Mouse: ({}, {}) {:?}\", mouse.x, mouse.y, mouse.button);\n    \n    // X11 coordinates are also 1-indexed, converted to 0-indexed\n    assert_eq!(mouse.x, 9);\n    assert_eq!(mouse.y, 4);\n    assert_eq!(mouse.button, MouseButton::Left);\n    eprintln!(\"[TEST] PASS: X11 mouse parsed correctly\");\n}\n```\n\n### E2E Interactive Test (tests/e2e/mouse_interactive.rs)\n```rust\n/// Run this test in a real terminal to verify mouse handling.\n/// Usage: cargo test --test mouse_interactive -- --nocapture --ignored\n#[test]\n#[ignore]\nfn test_mouse_interactive() {\n    use opentui::*;\n    use std::io::{stdin, stdout, Read, Write};\n    \n    // Enable SGR mouse mode\n    print!(\"\\x1b[?1000h\\x1b[?1006h\");\n    stdout().flush().unwrap();\n    \n    eprintln!(\"[E2E] Mouse mode enabled\");\n    eprintln!(\"[E2E] Click anywhere, scroll, drag. Press 'q' to quit.\");\n    eprintln!(\"[E2E] Testing: left/right/middle click, scroll, drag, modifiers\\n\");\n    \n    let mut parser = InputParser::new();\n    let mut buf = [0u8; 64];\n    let mut event_count = 0u32;\n    \n    let stdin = stdin();\n    let mut stdin_handle = stdin.lock();\n    \n    loop {\n        let n = stdin_handle.read(&mut buf).unwrap();\n        let raw = &buf[..n];\n        \n        eprintln!(\"[E2E] Raw input ({} bytes): {:02x?}\", n, raw);\n        \n        match parser.parse(raw) {\n            Ok((event, _)) => {\n                event_count += 1;\n                match event {\n                    Event::Key(key) if key.code == KeyCode::Char('q') => {\n                        print!(\"\\x1b[?1006l\\x1b[?1000l\");\n                        stdout().flush().unwrap();\n                        eprintln!(\"\\n[E2E] Test complete. {} events captured.\", event_count);\n                        return;\n                    }\n                    Event::Mouse(mouse) => {\n                        eprintln!(\"[E2E] #{}: Mouse {:?} {:?} at ({}, {}) mods=[shift={}, ctrl={}, alt={}]\",\n                            event_count, mouse.kind, mouse.button, \n                            mouse.x, mouse.y, mouse.shift, mouse.ctrl, mouse.alt);\n                    }\n                    other => {\n                        eprintln!(\"[E2E] #{}: {:?}\", event_count, other);\n                    }\n                }\n            }\n            Err(e) => {\n                eprintln!(\"[E2E] Parse error: {:?}\", e);\n            }\n        }\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] All new unit tests pass with detailed logging\n- [ ] Test coverage includes: left/middle/right click, release, scroll, motion, drag\n- [ ] Test coverage includes: Shift, Ctrl, Alt modifiers\n- [ ] Test coverage includes: large coordinates\n- [ ] Test coverage includes: X11 encoding (legacy)\n- [ ] Interactive E2E test works in real terminal\n- [ ] Each test logs input bytes, parsed values, and assertions\n- [ ] No regressions in existing tests\n\nDependencies:\n  -> bd-219 (blocks) - Fix Bracketed Paste Mode Bug","acceptance_criteria":"- [ ] All mouse button types detected correctly\n- [ ] Press vs release distinguished (M vs m)\n- [ ] Coordinates parsed correctly (convert from 1-indexed)\n- [ ] Modifiers detected (Ctrl+click, Shift+click)\n- [ ] Scroll wheel events parsed\n- [ ] Motion events with/without button\n- [ ] All 12+ unit tests pass\n- [ ] Manual testing with real terminal mouse\n\n---","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-19T21:02:52.119462179Z","updated_at":"2026-01-19T22:14:17.183785219Z","closed_at":"2026-01-19T22:14:17.183729253Z","close_reason":"Added 17 comprehensive mouse input tests covering: left/middle/right click, release, scroll (up/down/left/right), motion/drag, shift/ctrl/alt modifiers, combined modifiers, large coordinates, X11 encoding. All 21 mouse tests pass with detailed logging.","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-vde","depends_on_id":"bd-219","type":"blocks","created_at":"2026-01-27T06:52:24Z","created_by":"import"}]}
{"id":"bd-x48","title":"Improve error handling in terminal/queries.rs","description":"UBS flagged several panic! macros in library code at terminal/queries.rs (lines 293, 317, 332). These panics occur when unexpected DeviceAttributes or XtVersion responses are received. Consider: (1) Converting panics to proper error returns, (2) Using debug_assert! instead of panic! for internal invariants, (3) Documenting when these states could occur.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-27T17:40:56.821470266Z","created_by":"ubuntu","updated_at":"2026-01-27T17:43:39.658663090Z","closed_at":"2026-01-27T17:43:39.658604771Z","close_reason":"False positive from UBS - all flagged panic! macros are in test code (#[cfg(test)] mod tests), not library code. Using panic! in tests is idiomatic Rust and completely acceptable.","compaction_level":0,"original_size":0}
{"id":"bd-z1b","title":"demo_showcase: add bin target + skeleton main loop","description":"# demo_showcase — Add Binary Target + Skeleton Main Loop\n\n## Purpose\n\nCreate the new standalone binary entry point:\n\n- `src/bin/demo_showcase.rs`\n- `fn main() -> io::Result<()>`\n- Minimal but real terminal lifecycle:\n  - determine terminal size\n  - create `Renderer::new_with_options`\n  - enable raw mode if needed\n  - run a basic loop\n  - clean shutdown\n\nThis bead is intentionally “thin” and should compile immediately.\n\n## Implementation Outline\n\n- File: `src/bin/demo_showcase.rs`\n- Structure:\n  - `Config` parsed from args (placeholder until config bead)\n  - `App` state placeholder\n  - `run()` that owns renderer + loop\n\nPseudo:\n\n```rust\nfn main() -> io::Result<()> {\n    let config = Config::from_args(std::env::args_os());\n    run(config)\n}\n\nfn run(config: Config) -> io::Result<()> {\n    let (w, h) = terminal_size().unwrap_or((80, 24));\n    let mut renderer = Renderer::new_with_options(w.into(), h.into(), config.renderer_options())?;\n    // loop { draw; present; pump input; }\n    Ok(())\n}\n```\n\n## Constraints\n\n- Do not add new dependencies just for arg parsing.\n- Keep everything in one file initially (avoid file proliferation).","acceptance_criteria":"Checklist:\n- [ ] `src/bin/demo_showcase.rs` exists and builds\n- [ ] `cargo run --bin demo_showcase` launches and exits cleanly\n- [ ] Minimal input path exists to quit (Ctrl+Q)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-27T22:08:27.851706803Z","created_by":"ubuntu","updated_at":"2026-01-27T22:08:40.004344869Z","compaction_level":0,"original_size":0,"labels":["demo_showcase","runtime"],"dependencies":[{"issue_id":"bd-z1b","depends_on_id":"bd-29z","type":"parent-child","created_at":"2026-01-27T22:08:27.876324595Z","created_by":"ubuntu"}]}
